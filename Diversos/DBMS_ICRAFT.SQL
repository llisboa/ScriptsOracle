
-- --------------------------------------------------------------------------------
-- 
-- INTERCRAFT SOLUTIONS INFORMÁTICA LTDA
-- 08 DE AGOSTO DE 2007 - BASE COMUM PARA SOLUÇÕES PLSQL ICRAFT
-- BIBLIOTECA PADRÃO PARA SITE ASPNET E APL VB - IMPLEMENTAÇÃO ORACLE
-- 
-- 
-- OBSERVAÇÕES:::
--   - xxobservaçãoxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-- 
-- ALTERAÇÕES:::
--   - dd/mmm/yyyy xtécnico xxmotivotodocomletrasminúsculasxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
--   - 08/ago/2011 lucianol implementação de rotina para carga de arquivos a partir dos diretórios de repositório
--   - 02/dez/2011 lucianol trim_carac para eliminar caracter de borda
--   - 02/dez/2011 lucianol expr_expr para concatenar com delimitador
--   - 02/dez/2011 lucianol instr_i para procurar a partir de um início
--   - 02/dez/2011 lucianol limita_texto para quebrar campo em trechos limitados por quantidade de caracteres
--   - 05/dez/2011 lucianol str_end para retornar uma string contendo de modo padronizado todos os elementos de endereço: ...
--   - 05/dez/2011 lucianol expr_expr como sobrecarga
--   - 31/jan/2012 lucianol criação da função exibe_data para formatação de datas
--   - 31/jan/2012 lucianol criação da função litem busca pela posição do item informado no texto informado
--   - 31/jan/2012 lucianol criação da função litem que considera múltiplos itens
--   - 06/jan/2012 lucianol criação do procedimento desconecta_usuario ajuda a desconectar todas as sessões de um usuário
--   - 14/mar/2012 lucianol usuarios_bloqueia_outros inclusão para travamento de outros usuários que não aquele conectado
--   - 14/mar/2012 lucianol modifica_campo para facilitar alterações de campos preenchidos. não utilizar com campos relacionados
--   - 14/mar/2012 lucianol qtditens para buscar quantidade de itens em expressoes do tipo um;dois;tres
--   - 14/mar/2012 lucianol obtem_item função similar à litem com abordagem diferenciada para obtenção de itens do tipo um;dois;tres. item 2 por exemplo seria: dois
--   - 14/mar/2012 lucianol repl_repl para trocar (replace) até não existir mais ocorrência do texto procurado
--   - 14/mar/2012 lucianol so_email_str para recuperar em expressão do tipo 'Luciano Lisbôa' [lucianol@icraft.com.br] apenas o email: lucianol@icraft.com.br
--   - 14/mar/2012 lucianol email_str para formatar expressões de um modo geral com nome email em padrão "Luciano Lisbôa" <lucianol@icraft.com.br>, padrão dos correios eletrônicos
--   - 14/mar/2012 lucianol usuarios_bloqueia para bloquear todos os usuários. acesso continua permitido apenas para sysdba alter user account lock
--   - 14/mar/2012 lucianol usuarios_libera para liberar usuários alter user account unlock
--   - 14/mar/2012 lucianol envia_email nos para permitir envio de formato html possibilitando endereçamento de múltiplos destinatários no padrão email_str
--
--   
-- IDÉIAS/NECESSIDADES:::
--   - xtecnico xxcomentárioxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-- 
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'DICT_OBJ';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE DICT_OBJ FORCE';
    DBMS_OUTPUT.PUT_LINE('TYPE DICT_OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE DICT_OBJ  AS  OBJECT  ( CHAVE  VARCHAR2 (70), CONTEUDO VARCHAR2 (4000) )
/


DECLARE
  QTD NUMBER;
BEGIN
SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'DICT_TBL';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE DICT_TBL FORCE';
    DBMS_OUTPUT.PUT_LINE('OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE DICT_TBL AS  TABLE OF DICT_OBJ;
/


DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'MANUT_OBJ';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE MANUT_OBJ FORCE';
    DBMS_OUTPUT.PUT_LINE('OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE MANUT_OBJ AS OBJECT (
      SEQ NUMBER,
      TABELA VARCHAR2(100),
      MANUT_MOMENTO_STR VARCHAR2(50),
      CRIA_MOMENTO DATE,
      ATUALIZA_MOMENTO DATE,
      MANUT_MOMENTO DATE,
      MANUT_USUARIO VARCHAR2(100),
      MANUT_LOCAL VARCHAR2(100),
      MAP MEMBER FUNCTION GET_IDNO RETURN NUMBER
)
/

CREATE OR REPLACE TYPE BODY MANUT_OBJ AS
  MAP MEMBER FUNCTION GET_IDNO RETURN NUMBER IS
  BEGIN
    RETURN SEQ;
  END;
END;
/

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

DECLARE
  QTD NUMBER;
BEGIN
SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'MANUT_TBL';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE MANUT_TBL FORCE';
    DBMS_OUTPUT.PUT_LINE('OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE MANUT_TBL AS TABLE OF MANUT_OBJ;
/

-- DICT, MANTIDA POR COMPATIBILIDADE. UTILIZAR DICT QUE ESTÁ EM DBMS_ICRAFT.
CREATE OR REPLACE FUNCTION DICT
  (
    LISTA VARCHAR2,
    DELIM VARCHAR2 := ';',
    ATRIB VARCHAR2 := ':' )
  RETURN DICT_TBL PIPELINED
                  IS
  POS PLS_INTEGER := 1;
  PROX PLS_INTEGER;
  TERMO VARCHAR2(4000);
  PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
  WHILE POS<=LENGTH(LISTA)
  LOOP
    PROX    := INSTR(LISTA, DELIM, POS);
    IF PROX <> 0 THEN
      TERMO := SUBSTR(LISTA, POS, PROX-POS);
      POS   := PROX                   +1;
    ELSE
      TERMO := SUBSTR(LISTA, POS);
      POS   := LENGTH(LISTA)+1;
    END IF;
    PROX        := INSTR(TERMO, ATRIB);
    IF PROX     <>0 THEN
      PAR.CHAVE := SUBSTR(TERMO, 1, PROX-1);
    ELSE
      PAR.CHAVE := '';
    END IF;
    PAR.CONTEUDO := SUBSTR(TERMO, PROX+1);
    PIPE ROW(PAR);
  END LOOP;
END DICT;
/


DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'NUM_OBJ';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE NUM_OBJ FORCE';
    DBMS_OUTPUT.PUT_LINE('TYPE NUM_OBJ EXCLUÍDO');
  END IF;
END;
/

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE TYPE NUM_OBJ  AS  OBJECT  ( NUMERO INTEGER )
/


DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'NUM_TBL';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE NUM_TBL FORCE';
    DBMS_OUTPUT.PUT_LINE('TYPE NUM_TBL EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE NUM_TBL AS  TABLE OF NUM_OBJ
/

DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'ITEM_TEXTO_OBJ';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE ITEM_TEXTO_OBJ FORCE';
    DBMS_OUTPUT.PUT_LINE('TYPE ITEM_TEXTO_OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE ITEM_TEXTO_OBJ  AS  OBJECT  ( SEQ INTEGER,
CONTEUDO VARCHAR2(4000))
/

DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'ITEM_TEXTO_TBL';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE ITEM_TEXTO_TBL FORCE';
    DBMS_OUTPUT.PUT_LINE('TYPE ITEM_TEXTO_TBL EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE ITEM_TEXTO_TBL AS  TABLE OF ITEM_TEXTO_OBJ
/


-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

create or replace
PACKAGE DBMS_ICRAFT IS
FUNCTION MANUT_ULTIMO_MOMENTO(ESQUEMA_PRINC VARCHAR2) RETURN DATE;
FUNCTION MANUT_ULTIMAS(ESQUEMA_PRINC IN VARCHAR2, QTD IN INTEGER) RETURN MANUT_TBL PIPELINED;
FUNCTION DICT (LISTA VARCHAR2, DELIM VARCHAR2 := ';',  ATRIB VARCHAR2 := ':' ) RETURN DICT_TBL PIPELINED;
FUNCTION DATEDIFF(FORMATO VARCHAR2,INICIO DATE, FINAL DATE, CASASDECIMAIS INTEGER DEFAULT 0) RETURN FLOAT;
FUNCTION OBTEM_CONFIG_USUARIO_PADRAO(ESQUEMA VARCHAR2 ,PARAM VARCHAR2 ,USUARIO VARCHAR2 ,USUARIO_PADRAO VARCHAR2 ) RETURN DICT_TBL PIPELINED;
FUNCTION OBJ_ID_MAX RETURN INTEGER;
FUNCTION SERVIDOR_IP RETURN VARCHAR2;
FUNCTION SERVIDOR_NOME RETURN VARCHAR2;
PROCEDURE DEL_OBJ_APARTIR_ID(ID NUMBER);
FUNCTION CARREGA_ARQUIVO(CAMINHO VARCHAR2) RETURN BLOB;
PROCEDURE INDEX_REBUILD(ESQUEMA VARCHAR2);
PROCEDURE USUARIOS_BLOQUEIA_OUTROS;
FUNCTION QTDOBJ(TIPO VARCHAR2 DEFAULT '', ESQUEMA VARCHAR2 DEFAULT '', OBJ VARCHAR2 DEFAULT '') RETURN NUMBER;
PROCEDURE ALL_OBJ_COMPILE(ESQUEMA VARCHAR2);
PROCEDURE EXEC_SQL(SQL_CAMPO_COMA VARCHAR2);
FUNCTION IMED_SEQ(INICIO INTEGER, FINAL INTEGER) RETURN NUM_TBL PIPELINED;
FUNCTION CONSULTA_ITEM_TEXTO(CONSULTA VARCHAR2) RETURN ITEM_TEXTO_TBL PIPELINED;
PROCEDURE CONSTRAINTS_APAGA(ESQUEMA VARCHAR2);
PROCEDURE TRIGGERS_APAGA(ESQUEMA VARCHAR2);
PROCEDURE OBJ_TEMP_APAGA;
PROCEDURE DB_BLOQUEIA;
PROCEDURE DB_LIBERA;
PROCEDURE REPL_DESATIVA(USUARIO VARCHAR2, BANCO_ORIGEM VARCHAR2, BANCO_DESTINO VARCHAR2);
PROCEDURE REPL_ELIMINA(USUARIO VARCHAR2, BANCO_ORIGEM VARCHAR2, BANCO_DESTINO VARCHAR2);
PROCEDURE MODIFICA_CAMPO(ESQUEMA VARCHAR2, TABELA VARCHAR2, CAMPO VARCHAR2, TIPO_NOVO VARCHAR2);
PROCEDURE DESCONECTA_USUARIO(USUARIO VARCHAR2);
FUNCTION DB_SUGEST_TB_FILENAME(NOME VARCHAR2) RETURN VARCHAR2;
FUNCTION INSTR_REV(TEXTO VARCHAR2, PROCURA VARCHAR2) RETURN INTEGER;
PROCEDURE INCLUI_INFRA_SYS(ESQUEMA VARCHAR2);
FUNCTION DATE_MAX(DATA1 DATE, DATA2 DATE) RETURN DATE DETERMINISTIC;
FUNCTION TRIM_CARAC(TEXTO VARCHAR2, CARAC VARCHAR2) RETURN VARCHAR2;
FUNCTION EXPR_EXPR(DELIM VARCHAR2, DELIM_ALTERNATIVO VARCHAR2, PARAM VARCHAR2 DEFAULT '', COMPL VARCHAR2 DEFAULT '') RETURN VARCHAR2;
FUNCTION INSTR_I(INICIO  INTEGER, TEXTO   VARCHAR2, PROCURA VARCHAR2) RETURN INTEGER;
FUNCTION LIMITA_TEXTO(TEXTO VARCHAR2, TAM INTEGER, NRLINHAS INTEGER) RETURN VARCHAR2;
FUNCTION EXPR_EXPR(DELIM VARCHAR2, DELIM_ALT VARCHAR2, PARAM1 VARCHAR2, PARAM2 VARCHAR2, PARAM3 VARCHAR2, PARAM4 VARCHAR2 DEFAULT '', PARAM5 VARCHAR2 DEFAULT '', PARAM6 VARCHAR2 DEFAULT '' ) RETURN VARCHAR2;
FUNCTION STR_END(ENDERECO VARCHAR2, NUMERO VARCHAR2, COMPLEMENTO VARCHAR2, BAIRRO VARCHAR2, CIDADE VARCHAR2, PAIS VARCHAR2, ESTADO VARCHAR2, ESTADO_EX VARCHAR2, CEP VARCHAR2) RETURN VARCHAR2;
FUNCTION EXIBE_DATA (MOMENTO IN DATE, FORMATO IN VARCHAR2 DEFAULT '') RETURN VARCHAR2;
FUNCTION LITEM (TEXTO IN VARCHAR2, ITEM  IN NUMBER, SEP IN VARCHAR2 DEFAULT '') RETURN VARCHAR2;
FUNCTION LITEM (TEXTO IN VARCHAR2, ITEM  IN VARCHAR2, SEP IN VARCHAR2 DEFAULT '') RETURN NUMBER;
FUNCTION QTD_ITENS (TEXTO IN VARCHAR2, DELIM IN VARCHAR2) RETURN INTEGER;
FUNCTION OBTEM_ITEM (TEXTO IN VARCHAR2, DELIM IN VARCHAR2, ITEM IN INTEGER) RETURN VARCHAR2;
FUNCTION REPL_REPL(TEXTO IN VARCHAR2, DE IN VARCHAR2, PARA IN VARCHAR2) RETURN VARCHAR2;
FUNCTION SO_EMAIL_STR(EMAILSTR VARCHAR2) RETURN VARCHAR2;
FUNCTION EMAIL_STR(EMAILSTR IN VARCHAR2) RETURN VARCHAR2;
PROCEDURE USUARIOS_BLOQUEIA;
PROCEDURE USUARIOS_LIBERA;
PROCEDURE ENVIA_EMAIL(De IN VARCHAR, Para IN VARCHAR, Assunto IN VARCHAR, Texto IN VARCHAR);
FUNCTION SQL_PARA_HTML(SQLTEXT IN VARCHAR2, QTDCOLS number, NENHUM VARCHAR2 DEFAULT 'Nenhuma linha.') RETURN CLOB;
PROCEDURE JOB_APAGA_TODOS(ESQUEMA IN VARCHAR2);
PROCEDURE JOB_APAGA(TRECHO IN VARCHAR2);
PROCEDURE JOB_CRIA(TITULO IN VARCHAR2, EXEC IN VARCHAR2, MOMENTO_EXEC IN DATE DEFAULT SYSDATE+1/86400, CALC_PROC_EXEC VARCHAR2 DEFAULT 'SYSDATE + 1');
FUNCTION NOTIFICA_PROX(NOTIFICA VARCHAR2, MOMENTO DATE DEFAULT SYSDATE, VEZES INTEGER DEFAULT 1) RETURN DATE;
END;
/


create or replace
PACKAGE BODY DBMS_ICRAFT AS
FUNCTION MANUT_ULTIMO_MOMENTO (ESQUEMA_PRINC VARCHAR2) RETURN DATE
  -- EXEMPLO PARA TESTES
  -- SELECT TO_CHAR(DBMS_ICRAFT.MANUT_ULTIMO_MOMENTO('SBDB'),'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
AS
  DT DATE;
  DT_ACUM DATE := NULL;
  COMANDO VARCHAR2(4000);
BEGIN
  FOR CUR IN
  (SELECT OWNER,
    TABLE_NAME
     FROM ALL_TABLES
    WHERE OWNER IN
    (SELECT USERNAME
       FROM ALL_USERS
      WHERE USER_ID >=
      (SELECT USER_ID FROM ALL_USERS WHERE USERNAME=ESQUEMA_PRINC
      )
    )
  )

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

  LOOP
    BEGIN
      IF INSTR(';SYS_CONFIG_GLOBAL;SYS_CONFIG_USUARIO;SYS_LOCALID;SYS_OCORRENCIA;',';' || CUR.TABLE_NAME || ';')=0 THEN
        IF CUR.TABLE_NAME                                                                                       =

'SYS_DELETE' THEN
          COMANDO                                                                                              :=

'SELECT MAX(MOMENTO) FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME ;
        ELSE
          COMANDO := 'SELECT GREATEST(NVL(MAXC,MAXA),NVL(MAXA,MAXC)) FROM (SELECT MAX(SYS_MOMENTO_CRIA) AS MAXC, MAX

(SYS_MOMENTO_ATUALIZA) AS MAXA FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ')';
        END IF;
        EXECUTE IMMEDIATE COMANDO INTO DT;
         SELECT GREATEST(NVL(DT,DT_ACUM), NVL(DT_ACUM,DT)) INTO DT_ACUM FROM DUAL;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      NULL;
    END;
  END LOOP;
  RETURN DT_ACUM;
END;
FUNCTION DICT
  (
    LISTA VARCHAR2,
    DELIM VARCHAR2 := ';',
    ATRIB VARCHAR2 := ':' )
  RETURN DICT_TBL PIPELINED
                  IS
  POS PLS_INTEGER := 1;
  PROX PLS_INTEGER;
  TERMO VARCHAR2(4000);
  PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
  WHILE POS<=LENGTH(LISTA)
  LOOP
    PROX    := INSTR(LISTA, DELIM, POS);
    IF PROX <> 0 THEN
      TERMO := SUBSTR(LISTA, POS, PROX-POS);
      POS   := PROX                   +1;
    ELSE
      TERMO := SUBSTR(LISTA, POS);
      POS   := LENGTH(LISTA)+1;
    END IF;
    PROX        := INSTR(TERMO, ATRIB);
    IF PROX     <>0 THEN
      PAR.CHAVE := SUBSTR(TERMO, 1, PROX-1);
    ELSE
      PAR.CHAVE := '';
    END IF;
    PAR.CONTEUDO := SUBSTR(TERMO, PROX+1);
    PIPE ROW(PAR);
  END LOOP;
END DICT;
FUNCTION MANUT_ULTIMAS(ESQUEMA_PRINC IN VARCHAR2, QTD IN INTEGER) RETURN MANUT_TBL PIPELINED AS
M_REG MANUT_OBJ := MANUT_OBJ(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
  -- EXEMPLO PARA TESTES
  -- SELECT * FROM TABLE(DBMS_ICRAFT.MANUT_ULTIMAS('SBDB','10'))
  --
  -- ESTRUTURA PARA GUARDAR MANUTENÇÕES
  -- MANUT_MOMENTO_STR É A CHAVE E PERMITIRÁ ORGANIZAR A TAB POR MOMENTO DE MANUTENÇÃO
  --
  TYPE MANUT_TBL_ORD is table of MANUT_OBJ index by VARCHAR2(200);
  MANUT MANUT_TBL := NEW MANUT_TBL();
  --
  -- MANUT2 SERVE PARA JUNTAR AS CONSULTAS. DEPOIS DE JUNTAR VOU PEGAR SOMENTE OS N ÚLTIMOS
  --
  MANUT2 MANUT_TBL;
  --
  -- MANUTS SERVE PARA ORDENAR A JUNÇÃO DE PESQUISAS
  --
  MANUTS MANUT_TBL_ORD;
  --
  --
  --
  COMANDO VARCHAR2(4000);
  CONST1_INICIO VARCHAR2(1000);
  CONST1_FIM VARCHAR2(1000);
  ORD INTEGER;
  CHAVE VARCHAR2(50);
  --
  --
  TYPE C_T IS REF CURSOR;
  C C_T;
  REG_SEQ INTEGER;
  REG_BUSCA VARCHAR2(50);
  --
BEGIN
  --
  -- LOOPING NAS TABELAS OBTIDAS A PARTIR DO ESQUEMA PRINCIPAL
  --
  FOR CUR    IN
  (SELECT OWNER,
    TABLE_NAME
     FROM ALL_TABLES
    WHERE OWNER IN
    (SELECT USERNAME
       FROM ALL_USERS
      WHERE USER_ID >=
      (SELECT USER_ID FROM ALL_USERS WHERE USERNAME=ESQUEMA_PRINC
      )
    )
  )
  LOOP
    IF INSTR(';SYS_DELETE;SYS_CONFIG_GLOBAL;SYS_CONFIG_USUARIO;SYS_LOCALID;SYS_OCORRENCIA;',';' || CUR.TABLE_NAME ||

';')=0 THEN
    --
    --
    --
    -- OBTENDO REGISTROS MAIS ATUAIS
    --
    COMANDO := 'SELECT SEQ, ''' || CUR.TABLE_NAME || ''' TABELA, TO_CHAR(MANUT_MOMENTO_STR,''YYYY-MM-DD HH24:MI:SS'')

MANUT_MOMENTO_STR, CRIA_MOMENTO, ATUALIZA_MOMENTO, MANUT_MOMENTO, MANUT_USUARIO, MANUT_LOCAL
    FROM
    (SELECT ROWNUM SEQ,
    SYS_MOMENTO_CRIA CRIA_MOMENTO,
    SYS_MOMENTO_ATUALIZA ATUALIZA_MOMENTO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END AS MANUT_MOMENTO_STR,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END AS MANUT_MOMENTO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_USUARIO_ATUALIZA
      ELSE SYS_USUARIO_CRIA
    END AS MANUT_USUARIO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_LOCAL_ATUALIZA
      ELSE SYS_LOCAL_CRIA
    END AS MANUT_LOCAL FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ' ORDER BY
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END DESC
    )
    WHERE SEQ <= ' || QTD;
    --
    --
    --
    --
    -- JOGA PARA MANUT.... E JUNTA COM MANUT2
    --
    BEGIN
      --
      MANUT.DELETE;
      OPEN C FOR COMANDO;
      --
      LOOP
        --
        --
        BEGIN
          FETCH c INTO M_REG.SEQ, M_REG.TABELA, M_REG.MANUT_MOMENTO_STR, M_REG.CRIA_MOMENTO, M_REG.ATUALIZA_MOMENTO,

M_REG.MANUT_MOMENTO, M_REG.MANUT_USUARIO, M_REG.MANUT_LOCAL;
          EXIT WHEN C%NOTFOUND;
        EXCEPTION
          WHEN OTHERS THEN
                 -- DBMS_OUTPUT.PUT_LINE('FETCH ' || CUR.TABLE_NAME || '>>' || SQLERRM);
           NULL;
        END;
        MANUT.EXTEND;
        MANUT(MANUT.COUNT) := M_REG;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
   -- DBMS_OUTPUT.PUT_LINE('OPEN ' || CUR.TABLE_NAME || '>>' || SQLERRM);
           NULL;
    END;

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

    --
    --
    --
    IF MANUT2 IS NULL THEN
      MANUT2 := MANUT;
    ELSE
      MANUT2 := MANUT MULTISET UNION MANUT2;
    END IF;
    --
    --
    -- ORDENA ITENS PEGANDO SÓ A QUANTIDADE MÁXIMA SOLICITADA
    --
    IF MANUT2.COUNT > 0 THEN
	MANUTS.DELETE;
        -- DBMS_OUTPUT.PUT_LINE('TABELA ' || CUR.TABLE_NAME || ' ... ANTES');
        FOR Z IN MANUT2.FIRST .. MANUT2.LAST LOOP
          IF NOT MANUT2(Z).MANUT_MOMENTO_STR IS NULL THEN
            -- DBMS_OUTPUT.PUT_LINE(MANUT2(Z).MANUT_MOMENTO_STR);
            REG_SEQ := 1;
	    LOOP
              REG_BUSCA := MANUT2(Z).MANUT_MOMENTO_STR || '-' || TO_CHAR(REG_SEQ,'0000');
              EXIT WHEN NOT MANUTS.EXISTS(REG_BUSCA);
              REG_SEQ := REG_SEQ + 1;
            END LOOP;
            MANUTS(REG_BUSCA) := MANUT2(Z);
          END IF;
        END LOOP;
	MANUT2.DELETE;
        ORD := 1;
        CHAVE := MANUTS.LAST;
        -- DBMS_OUTPUT.PUT_LINE('TABELA ' || CUR.TABLE_NAME || ' ... DEPOIS');
        LOOP
          EXIT WHEN ORD > QTD OR CHAVE IS NULL;
          -- DBMS_OUTPUT.PUT_LINE(CHAVE);
          MANUT2.EXTEND;
          MANUT2(ORD) := MANUTS(CHAVE);
          ORD := ORD + 1;
          CHAVE := MANUTS.PRIOR(CHAVE);
        END LOOP;
        -- DBMS_OUTPUT.PUT_LINE('..........');
    END IF;
    --
    --
    --
    END IF;
  END LOOP;
  --
  --
  --
  -- DANDO SAÍDA NO RESULTADO
  --
  CHAVE := MANUT2.FIRST;
  LOOP
    EXIT WHEN CHAVE IS NULL;
    PIPE ROW (MANUT2(CHAVE));
    CHAVE := MANUT2.NEXT(CHAVE);
  END LOOP;
  --
  --
  --
  RETURN;
END MANUT_ULTIMAS;


FUNCTION DATEDIFF(FORMATO VARCHAR2,INICIO DATE, FINAL DATE, CASASDECIMAIS INTEGER DEFAULT 0) RETURN FLOAT AS
  RET FLOAT;
BEGIN
  IF FORMATO = 'ANO' THEN
    RET := MONTHS_BETWEEN(FINAL, INICIO)/12;
  ELSIF FORMATO = 'MES' THEN
    RET := MONTHS_BETWEEN(FINAL, INICIO);
  ELSIF FORMATO = 'DIA' THEN
    RET := FINAL - INICIO;
  ELSIF FORMATO = 'HORA' THEN
    RET := (FINAL - INICIO)*24;
  ELSIF FORMATO = 'MIN' THEN
    RET := (FINAL - INICIO)*24*60;
  ELSIF FORMATO = 'SEG' THEN
    RET := (FINAL - INICIO)*24*60*60;
  END IF;
  RET := TRUNC(RET,CASASDECIMAIS);
  RETURN RET;
END;


FUNCTION OBTEM_CONFIG_USUARIO_PADRAO(ESQUEMA VARCHAR2 ,PARAM VARCHAR2 ,USUARIO VARCHAR2 ,USUARIO_PADRAO VARCHAR2 )

RETURN DICT_TBL PIPELINED IS
PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
            BEGIN
                        SELECT CONFIG INTO PAR.CONTEUDO FROM SYS_CONFIG_USUARIO S WHERE S.USUARIO=USUARIO AND

S.PARAM=PARAM;
                        PAR.CHAVE := USUARIO;
            EXCEPTION WHEN OTHERS THEN
                        BEGIN
                                   SELECT CONFIG INTO PAR.CONTEUDO FROM SYS_CONFIG_USUARIO S WHERE

S.USUARIO=USUARIO_PADRAO AND S.PARAM=PARAM;
                                   PAR.CHAVE := USUARIO_PADRAO;
                        EXCEPTION WHEN OTHERS THEN
                                   PAR.CHAVE := USUARIO;
                                   PAR.CONTEUDO := '';
                        END;
            END;
            PIPE ROW(PAR);
END;


FUNCTION OBJ_ID_MAX RETURN INTEGER AS
  M  NUMBER;
BEGIN
  SELECT MAX(OBJECT_ID) INTO M FROM ALL_OBJECTS;
  RETURN M;
END;

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------


FUNCTION SERVIDOR_IP RETURN VARCHAR2 AS
  IP VARCHAR2(30);
BEGIN
  SELECT UTL_INADDR.GET_HOST_ADDRESS INTO IP FROM DUAL;
  RETURN IP;
END;


FUNCTION SERVIDOR_NOME RETURN VARCHAR2 AS
  NOME VARCHAR2(30);
BEGIN
  SELECT UTL_INADDR.GET_HOST_NAME INTO NOME FROM DUAL;
  RETURN NOME;
END;


PROCEDURE DEL_OBJ_APARTIR_ID(ID NUMBER) AS
BEGIN
  EXEC_SQL('SELECT ''DROP '' || OBJECT_TYPE || '' '' || OWNER || ''.'' || OBJECT_NAME AS COMA FROM (SELECT OWNER, OBJECT_NAME, OBJECT_TYPE FROM ALL_OBJECTS WHERE OBJECT_ID >' || ID ||')');
END;


FUNCTION CARREGA_ARQUIVO(CAMINHO VARCHAR2) RETURN BLOB IS
f_lob BFILE;
b_lob BLOB;
caminho2 varchar2(1000);
BEGIN
dbms_lob.createtemporary(b_lob,true);
caminho2 := replace(caminho, '\', '/');
caminho2 := replace(caminho2,'~/', '');
f_lob := BFILENAME('REPOSITORIO_RAIZ', caminho2);
dbms_lob.fileopen(f_lob,dbms_lob.file_readonly);
dbms_lob.loadfromfile(b_lob,f_lob,dbms_lob.getlength(f_lob) );
dbms_lob.fileclose(f_lob);
RETURN b_lob;
END;


PROCEDURE INDEX_REBUILD(ESQUEMA VARCHAR2) AS
BEGIN
   BEGIN
      DBMS_OUTPUT.PUT_LINE('RECONSTRUINDO INDEXES');
      EXEC_SQL('SELECT ''ALTER INDEX '' || OWNER || ''.'' || INDEX_NAME || '' REBUILD'' FROM ALL_INDEXES WHERE OWNER ='''  || ESQUEMA ||''' ');
      DBMS_OUTPUT.PUT_LINE('=> OK');
   EXCEPTION WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
   END;
END;

PROCEDURE USUARIOS_BLOQUEIA_OUTROS AS
BEGIN
DBMS_ICRAFT.USUARIOS_BLOQUEIA();
EXECUTE IMMEDIATE 'ALTER USER ' || USER || ' ACCOUNT UNLOCK';
FOR CUR IN (SELECT USERNAME FROM ALL_USERS WHERE USERNAME <> USER) LOOP
  DBMS_ICRAFT.DESCONECTA_USUARIO(CUR.USERNAME);
END LOOP;
END;


FUNCTION QTDOBJ(TIPO VARCHAR2 DEFAULT '', ESQUEMA VARCHAR2 DEFAULT '', OBJ VARCHAR2 DEFAULT '') RETURN NUMBER AS
QTD NUMBER;
BEGIN
    SELECT COUNT(OBJECT_NAME) INTO QTD FROM ALL_OBJECTS WHERE DECODE(TIPO,'',OBJECT_TYPE,TIPO)=OBJECT_TYPE AND DECODE

(ESQUEMA,'',OWNER,ESQUEMA)=OWNER AND DECODE(OBJ,'',OBJECT_NAME,OBJ)=OBJECT_NAME;
    RETURN QTD;
END;


-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE ALL_OBJ_COMPILE(ESQUEMA VARCHAR2) AS
BEGIN
   BEGIN
      DBMS_OUTPUT.PUT_LINE('COMPILANDO OBJS');
      EXEC_SQL('SELECT ''ALTER '' || OBJECT_TYPE || '' '' || OWNER || ''.'' || OBJECT_NAME || '' COMPILE'' FROM ALL_OBJECTS WHERE OWNER =''' || ESQUEMA || ''' AND STATUS = ''INVALID'' AND OBJECT_TYPE IN (''TRIGGER'', ''TYPE'', ''FUNCTION'', ''PROCEDURE'', ''PACKAGE'', ''PACKAGE BODY'', ''VIEW'')');
      DBMS_OUTPUT.PUT_LINE('=> OK');
   EXCEPTION WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
   END;
FOR CUR IN (select * from ALL_OBJECTS where  STATUS = 'INVALID' AND OWNER=''||ESQUEMA ||'') LOOP
    DBMS_OUTPUT.PUT_LINE(CUR.OBJECT_TYPE || ' ' || CUR.OWNER || '.' || CUR.OBJECT_NAME);
END LOOP;
END;


PROCEDURE EXEC_SQL(SQL_CAMPO_COMA VARCHAR2) IS
   CUR INTEGER;
   COR INTEGER;
   COMA VARCHAR2(4000);
BEGIN
   CUR := DBMS_SQL.OPEN_CURSOR;
   DBMS_SQL.PARSE(CUR,SQL_CAMPO_COMA, DBMS_SQL.NATIVE);
   DBMS_SQL.DEFINE_COLUMN(CUR,1,COMA,4000);
   COR := DBMS_SQL.EXECUTE(CUR);
   LOOP
   EXIT WHEN DBMS_SQL.FETCH_ROWS (CUR) = 0;
      DBMS_SQL.COLUMN_VALUE (CUR, 1, COMA);
      DBMS_OUTPUT.PUT_LINE(CHR(13) || CHR(10));
      DBMS_OUTPUT.PUT_LINE(COMA);
      BEGIN
         EXECUTE IMMEDIATE COMA;
         DBMS_OUTPUT.PUT_LINE('=> OK');
      EXCEPTION
       WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE('=> ERR:' || SQLERRM);
      END;
   END LOOP;
      DBMS_SQL.CLOSE_CURSOR(CUR);
END;

FUNCTION IMED_SEQ(INICIO INTEGER, FINAL INTEGER) RETURN NUM_TBL PIPELINED AS
I NUMBER;
ITEM NUM_OBJ := NUM_OBJ(NULL);
BEGIN
FOR I IN INICIO .. FINAL LOOP
ITEM.NUMERO := I;
PIPE ROW(ITEM);
END LOOP;
END;

FUNCTION CONSULTA_ITEM_TEXTO(CONSULTA VARCHAR2) RETURN ITEM_TEXTO_TBL PIPELINED AS
CUR INTEGER;
COR INTEGER;
COMA VARCHAR2(4000);
ITEM ITEM_TEXTO_OBJ := ITEM_TEXTO_OBJ(NULL,NULL);
I NUMBER := 1;
BEGIN
CUR := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE(CUR,CONSULTA, DBMS_SQL.NATIVE);
DBMS_SQL.DEFINE_COLUMN(CUR,1,COMA,4000);
COR := DBMS_SQL.EXECUTE(CUR);
LOOP
      EXIT WHEN DBMS_SQL.FETCH_ROWS (CUR) = 0;
      DBMS_SQL.COLUMN_VALUE (CUR, 1, COMA);
      ITEM.SEQ := I;
      I := I + 1;
      ITEM.CONTEUDO := COMA;
      PIPE ROW(ITEM);
END LOOP;
DBMS_SQL.CLOSE_CURSOR(CUR);
END;

PROCEDURE CONSTRAINTS_APAGA(ESQUEMA VARCHAR2) AS
BEGIN
--NÃO DELATA UNIQUE NEM PRIMARY KEY
   BEGIN
      DBMS_OUTPUT.PUT_LINE('DELETANDO CONSTRAINTS');
      EXEC_SQL('SELECT ''ALTER TABLE '' || OWNER || ''.'' || TABLE_NAME || '' DROP CONSTRAINT '' || CONSTRAINT_NAME  FROM ALL_CONSTRAINTS WHERE (CONSTRAINT_TYPE = ''R'' OR CONSTRAINT_TYPE = ''C'') AND OWNER =''' || ESQUEMA || ''' ');
      DBMS_OUTPUT.PUT_LINE('=> OK');
   EXCEPTION WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
   END;
END;

PROCEDURE TRIGGERS_APAGA(ESQUEMA VARCHAR2) AS
BEGIN
   BEGIN
      DBMS_OUTPUT.PUT_LINE('DELETANDO TRIGGERS');
      EXEC_SQL('SELECT ''DROP TRIGGER '' || OWNER || ''.'' || TRIGGER_NAME || '''' FROM ALL_TRIGGERS WHERE OWNER =''' || ESQUEMA || ''' ');
      DBMS_OUTPUT.PUT_LINE('=> OK');
   EXCEPTION WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
   END;
END;

PROCEDURE OBJ_TEMP_APAGA AS
BEGIN
   BEGIN
      DBMS_OUTPUT.PUT_LINE('DELETANDO OBJS TEMPORÁRIOS');
      EXECUTE IMMEDIATE 'PURGE RECYCLEBIN';
      DBMS_OUTPUT.PUT_LINE('=> OK');
   EXCEPTION WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
   END;
END;


PROCEDURE USUARIOS_BLOQUEIA AS
BEGIN
                FOR CUR IN (SELECT USERNAME FROM ALL_USERS) LOOP
                BEGIN
                EXECUTE IMMEDIATE 'ALTER USER ' || CUR.USERNAME || ' ACCOUNT LOCK';
                EXCEPTION
                WHEN OTHERS THEN
                               NULL;
                END;
                END LOOP;
END;


PROCEDURE USUARIOS_LIBERA AS
BEGIN
                FOR CUR IN (SELECT USERNAME FROM ALL_USERS) LOOP
                BEGIN
                EXECUTE IMMEDIATE 'ALTER USER ' || CUR.USERNAME || ' ACCOUNT UNLOCK';
                EXCEPTION
                WHEN OTHERS THEN
                               NULL;
                END;
                END LOOP;
END;


PROCEDURE DB_BLOQUEIA AS
BEGIN
                FOR CUR IN (SELECT NAME TABLESPACE_NAME FROM V$TABLESPACE) LOOP
                BEGIN
                EXECUTE IMMEDIATE 'ALTER TABLESPACE ' || CUR.TABLESPACE_NAME || ' READ ONLY';
                EXCEPTION
                WHEN OTHERS THEN
                               NULL;
                END;
                END LOOP;
END;

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE DB_LIBERA AS
BEGIN
                FOR CUR IN (SELECT NAME TABLESPACE_NAME FROM V$TABLESPACE) LOOP
                BEGIN
                EXECUTE IMMEDIATE 'ALTER TABLESPACE ' || CUR.TABLESPACE_NAME || ' READ WRITE';
                EXCEPTION
                WHEN OTHERS THEN
                               NULL;
                END;
                END LOOP;
END;

PROCEDURE REPL_DESATIVA(USUARIO VARCHAR2, BANCO_ORIGEM VARCHAR2, BANCO_DESTINO VARCHAR2) AS
APPLY VARCHAR2(200);
CAPTURE_QUEUE VARCHAR2(200);
APPLY_QUEUE VARCHAR2(200);
BEGIN
APPLY := 'APPLY_' || USUARIO || '_' || BANCO_ORIGEM || '_' || BANCO_DESTINO;
CAPTURE_QUEUE := 'CQ_' || USUARIO || '_' || BANCO_ORIGEM || '_' || BANCO_DESTINO;
APPLY_QUEUE := 'AQ_' || USUARIO || '_' || BANCO_ORIGEM || '_' || BANCO_DESTINO;

BEGIN
DBMS_OUTPUT.PUT_LINE('ELIMINANDO ERROS DA FILA');
DBMS_APPLY_ADM.DELETE_ALL_ERRORS(APPLY);
DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

BEGIN
DBMS_OUTPUT.PUT_LINE('PARANDO APPLY');
DBMS_APPLY_ADM.STOP_APPLY(APPLY, TRUE);
DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

BEGIN
DBMS_OUTPUT.PUT_LINE('ELIMINANDO APPLY');
DBMS_APPLY_ADM.DROP_APPLY(APPLY, TRUE);
DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

BEGIN
DBMS_OUTPUT.PUT_LINE('REMOVENDO QUEUE CAPTURE');
DBMS_STREAMS_ADM.REMOVE_QUEUE(CAPTURE_QUEUE,TRUE,TRUE);
DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

BEGIN
DBMS_OUTPUT.PUT_LINE('REMOVENDO QUEUE APPLY');
DBMS_STREAMS_ADM.REMOVE_QUEUE(APPLY_QUEUE,TRUE,TRUE);
DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

END;

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------


PROCEDURE REPL_ELIMINA(USUARIO VARCHAR2, BANCO_ORIGEM VARCHAR2, BANCO_DESTINO VARCHAR2) AS
BEGIN
-- DESATIVA REPLICAÇÃO
-- FOR CUR IN (SELECT .. FROM ...) LOOP
REPL_DESATIVA(USUARIO,BANCO_ORIGEM,BANCO_DESTINO);
-- END LOOP;
-- ELIMINA USUÁRIO
BEGIN
DBMS_OUTPUT.PUT_LINE('ELIMINANDO USUÁRIO');
EXECUTE IMMEDIATE 'DROP USER ' || USUARIO || ' CASCADE';
DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;
-- ELIMINA TABLESPACE
BEGIN
DBMS_OUTPUT.PUT_LINE('ELIMINANDO TABLESPACE');
EXECUTE IMMEDIATE 'DROP TABLESPACE T_' || USUARIO || '_REPL INCLUDING CONTENTS';
DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

END;

PROCEDURE MODIFICA_CAMPO(ESQUEMA   VARCHAR2, TABELA    VARCHAR2, CAMPO     VARCHAR2, TIPO_NOVO VARCHAR2)
IS
BEGIN
  EXECUTE IMMEDIATE 'ALTER TABLE ' || ESQUEMA || '.' || TABELA || ' ADD ("' || CAMPO || '_" ' || TIPO_NOVO || ')';
  BEGIN
    EXECUTE IMMEDIATE 'UPDATE ' || ESQUEMA || '.' || TABELA || ' SET "' || CAMPO || '_"' || ' = "' || CAMPO || '"';
    EXECUTE IMMEDIATE 'ALTER TABLE ' || ESQUEMA || '.' || TABELA || ' DROP ("' || CAMPO || '")';
  EXCEPTION
  WHEN OTHERS THEN
    EXECUTE IMMEDIATE 'ALTER TABLE ' || ESQUEMA || '.' || TABELA || ' DROP ("' || CAMPO || '_")';
    RAISE_APPLICATION_ERROR(-20000, SQLERRM);
  END;
  EXECUTE IMMEDIATE 'ALTER TABLE ' || ESQUEMA || '.' || TABELA || ' RENAME COLUMN "' || CAMPO || '_" TO "' || CAMPO || '"' ;
END;

PROCEDURE DESCONECTA_USUARIO(USUARIO VARCHAR2) IS
BEGIN
FOR CUR IN (SELECT SID, SERIAL# FROM V$SESSION WHERE USERNAME=USUARIO) LOOP
  EXECUTE IMMEDIATE 'ALTER SYSTEM DISCONNECT SESSION ''' || CUR.SID || ',' || CUR."SERIAL#" || ''' IMMEDIATE';
END LOOP;
END;

FUNCTION INSTR_REV(TEXTO VARCHAR2, PROCURA VARCHAR2) RETURN INTEGER AS
POS INTEGER;
BEGIN
SELECT INSTR(REVERSE(TEXTO),PROCURA) INTO POS FROM DUAL;
IF POS<>0 THEN
POS := LENGTH(TEXTO)+1 - POS;
END IF;
RETURN POS;
END;


FUNCTION DB_SUGEST_TB_FILENAME(NOME VARCHAR2) RETURN VARCHAR2 AS
DIR_TAB VARCHAR2(4000);
POS INTEGER;
BEGIN
-- ESTAR NO MESMO DIRETÓRIO DO ÚLTIMO ESQUEMA ONLINE
SELECT DISTINCT FIRST_VALUE(NAME) OVER(ORDER BY CREATION_TIME DESC) INTO DIR_TAB FROM V$DATAFILE  WHERE STATUS = 'ONLINE';
SELECT INSTR_REV(DIR_TAB,'\') INTO POS FROM DUAL;
IF POS = 0 THEN
 DIR_TAB := NOME;
ELSE
 SELECT LPAD(DIR_TAB, POS) || NOME INTO DIR_TAB FROM DUAL;
END IF;
RETURN DIR_TAB;
END;

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------


FUNCTION DATE_MAX(DATA1 DATE, DATA2 DATE) RETURN DATE DETERMINISTIC AS
BEGIN
IF DATA1 IS NULL THEN
RETURN DATA2;
ELSE
IF DATA2 IS NULL THEN
  RETURN DATA1;
ELSE
  IF DATA1 > DATA2 THEN
   RETURN DATA1;
  ELSE
   RETURN DATA2;
  END IF;
END IF;
END IF;
END;

PROCEDURE INCLUI_INFRA_SYS(ESQUEMA VARCHAR2) AS
COMA VARCHAR2(2000);
BEGIN
FOR CUR IN (SELECT TABLE_NAME, OWNER FROM ALL_TABLES WHERE OWNER = ESQUEMA) LOOP

BEGIN
 DBMS_OUTPUT.PUT_LINE('INCLUINDO SYS_MOMENTO EM ' || CUR.OWNER || '.' || CUR.TABLE_NAME);
 COMA := 'ALTER TABLE ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ' ADD (SYS_MOMENTO DATE)';
 EXECUTE IMMEDIATE COMA;
 DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

BEGIN
 DBMS_OUTPUT.PUT_LINE('ATIVANDO TRIGGER BEF_' || CUR.TABLE_NAME || '_SMOM');
 COMA := 'CREATE OR REPLACE TRIGGER ' || CUR.OWNER || 'BEF_' || CUR.TABLE_NAME || '_SMOM BEFORE UPDATE OR INSERT ON ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ' FOR EACH ROW BEGIN :NEW.SYS_MOMENTO := SYSDATE; END;' ;
 EXECUTE IMMEDIATE COMA;
 DBMS_OUTPUT.PUT_LINE('=> OK');
EXCEPTION WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
END;

END LOOP;
END;

-- PARA ELIMINAR CARACTER DE BORDA
FUNCTION TRIM_CARAC(TEXTO VARCHAR2, CARAC VARCHAR2) RETURN VARCHAR2 IS
RET VARCHAR2(4000) := TEXTO;
BEGIN
                IF SUBSTR(RET,LENGTH(RET)-LENGTH(CARAC)+1) = CARAC THEN
                               RET := SUBSTR(RET, 1, LENGTH(RET)-LENGTH(CARAC));
                END IF;
                IF SUBSTR(RET,1,LENGTH(CARAC)) = CARAC THEN
                               RET := SUBSTR(RET, LENGTH(CARAC)+1);
                END IF;
                RETURN RET;
END;

-- PARA CONCATENAR COM DELIMITADOR
FUNCTION EXPR_EXPR(DELIM VARCHAR2, DELIM_ALTERNATIVO VARCHAR2, PARAM VARCHAR2 DEFAULT '', COMPL VARCHAR2 DEFAULT '') RETURN VARCHAR2 IS
PARAM1 VARCHAR2(4000) := PARAM;
PARAM2 VARCHAR2(4000) := COMPL;
RESULT VARCHAR2(4000);
BEGIN
PARAM1 := TRIM(NVL(PARAM1,''));
PARAM2 := TRIM(NVL(PARAM2, ''));
IF LENGTH(DELIM_ALTERNATIVO)<>0 THEN
SELECT REPLACE(PARAM1, DELIM_ALTERNATIVO, DELIM) INTO PARAM1 FROM DUAL;
SELECT REPLACE(PARAM2, DELIM_ALTERNATIVO, DELIM) INTO PARAM2 FROM DUAL;
END IF;
IF LENGTH(PARAM1)<>0 AND LENGTH(PARAM2)<>0 THEN
IF SUBSTR(PARAM1,LENGTH(PARAM1)-LENGTH(DELIM)+1) = DELIM AND SUBSTR(PARAM2,1,LENGTH(DELIM)) = DELIM THEN
RESULT := PARAM1 || SUBSTR(PARAM2, LENGTH(DELIM)+1);
ELSIF SUBSTR(PARAM1,LENGTH(PARAM1)-LENGTH(DELIM)+1) = DELIM OR SUBSTR(PARAM2,1,LENGTH(DELIM)) = DELIM THEN
RESULT := PARAM1 || PARAM2;
ELSE
RESULT := PARAM1 || DELIM || PARAM2;
END IF;
ELSE
RESULT := TRIM_CARAC(PARAM1,DELIM) || TRIM_CARAC(PARAM2,DELIM);
END IF;
RETURN RESULT;
END;

-- PROCURA A PARTIR DE UM INÍCIO
  FUNCTION INSTR_I(INICIO  INTEGER, TEXTO VARCHAR2, PROCURA VARCHAR2) RETURN INTEGER IS
    TRECHO VARCHAR2(4000);
    POS INTEGER;
  BEGIN
    TRECHO := SUBSTR(TEXTO,INICIO);
    POS := INSTR(TRECHO, PROCURA);
    IF POS  = 0 THEN
      POS  := LENGTH(TRECHO)+1;
    END IF;
    POS := POS + INICIO - 1;
    RETURN POS;
  END;

-- LIMITA_TEXTO PARA QUEBRAR CAMPO EM TRECHOS LIMITADOS POR QUANTIDADE DE CARACTERES
FUNCTION LIMITA_TEXTO(TEXTO VARCHAR2, TAM INTEGER, NRLINHAS INTEGER) RETURN VARCHAR2 IS
RET VARCHAR2(4000) := TEXTO;
POS INTEGER;
LINHA INTEGER;
PPOS INTEGER;
PENTER INTEGER;
Z INTEGER;
ENCONTRO VARCHAR2(10);
BEGIN
      IF TAM = 0 THEN
        RAISE_APPLICATION_ERROR(-20000, 'Informe a quantidade de caracteres.');
      END IF;
                POS := 1;
                LINHA := 1;
                WHILE POS <= LENGTH(RET) LOOP
                               IF NRLINHAS <> 0 AND LINHA > NRLINHAS THEN
                                               EXIT;
                               END IF;
                               PPOS := POS + TAM;
                               PENTER := INSTR_I(POS, RET, CHR(13) || CHR(10));
                               IF PPOS = 0 THEN
                                               PENTER := LENGTH(RET) + 1;
                               END IF;
                               IF PENTER < PPOS THEN
                                               PPOS := PENTER;
                               END IF;
                               IF (SUBSTR(RET, PPOS, 2) <> CHR(13) || CHR(10)) AND (PPOS <= LENGTH(RET)) THEN
                                                                                              Z := PPOS;
                                                                                              WHILE Z >= (POS+1) LOOP
                                                               SELECT REGEXP_INSTR(SUBSTR(RET,Z,1), '[ ,\[\(\)\{\}]') INTO ENCONTRO FROM DUAL;
                                                               IF ENCONTRO<>0 THEN
                                                                              EXIT;
                                                               END IF;
                                                                                                                             Z := Z - 1;
                                               END LOOP;
                                               IF Z >= (POS + 1) THEN
                                                               PPOS := Z;
                                               END IF;
                                               RET := SUBSTR(RET, 1, PPOS -1) || CHR(13) || CHR(10) || TRIM(SUBSTR(RET, PPOS));
                               END IF;
                                                      LINHA := LINHA + 1;
                                                      POS := PPOS + 2;
                END LOOP;
                RETURN RET;
END;

FUNCTION EXPR_EXPR(DELIM VARCHAR2, DELIM_ALT VARCHAR2, PARAM1 VARCHAR2, PARAM2 VARCHAR2, PARAM3 VARCHAR2, PARAM4 VARCHAR2 DEFAULT '', PARAM5 VARCHAR2 DEFAULT '', PARAM6 VARCHAR2 DEFAULT '' ) RETURN VARCHAR2 IS
RET VARCHAR2(4000);
BEGIN
  RET := DBMS_ICRAFT.EXPR_EXPR(DELIM, DELIM_ALT, PARAM1, PARAM2);
  RET := DBMS_ICRAFT.EXPR_EXPR(DELIM, DELIM_ALT, RET, PARAM3);
  RET := DBMS_ICRAFT.EXPR_EXPR(DELIM, DELIM_ALT, RET, PARAM4);
  RET := DBMS_ICRAFT.EXPR_EXPR(DELIM, DELIM_ALT, RET, PARAM5);
  RET := DBMS_ICRAFT.EXPR_EXPR(DELIM, DELIM_ALT, RET, PARAM6);
  RETURN RET;
END;

FUNCTION STR_END(ENDERECO VARCHAR2, NUMERO VARCHAR2, COMPLEMENTO VARCHAR2, BAIRRO VARCHAR2, CIDADE VARCHAR2, PAIS VARCHAR2, ESTADO VARCHAR2, ESTADO_EX VARCHAR2, CEP VARCHAR2) RETURN VARCHAR2 IS
PAIS_X VARCHAR2(200);
ESTADO_X VARCHAR2 (200);
ESTADO_EX_X VARCHAR2 (200);
CEP_X VARCHAR2 (100) := CEP;
RET VARCHAR2(4000);
BEGIN

  PAIS_X := REPLACE(NVL(PAIS,''), '--', '');
  ESTADO_X := REPLACE(NVL(ESTADO, ''), '--', '');
  ESTADO_EX_X := REPLACE(NVL(ESTADO_EX, ''), '--', '');
  
  CEP_X := TRIM(NVL(CEP_X,''));
  IF LENGTH(CEP_X) = 0 OR CEP_X = '-' OR CEP_X = '00000-000' THEN
      CEP_X := '';
  ELSE
      CEP_X := 'CEP:' || CEP;
  END IF;
  
  SELECT EXPR_EXPR(' - ', '', EXPR_EXPR(', ', '', ENDERECO, NUMERO, COMPLEMENTO), 
  BAIRRO, 
  CIDADE,
  DECODE(PAIS_X, 'BRASIL', ESTADO_X, ESTADO_EX_X),
  PAIS_X,
  DECODE(NVL(CEP,''), '', '', CEP_X)) INTO RET FROM DUAL;
  
  RETURN RET;
END;

FUNCTION EXIBE_DATA (MOMENTO IN DATE, FORMATO IN VARCHAR2 DEFAULT '') RETURN VARCHAR2 AS
  VDIA      INTEGER;
  VMES      INTEGER;
  VANO      INTEGER;
  VHORA     INTEGER;
  VMINUTO   INTEGER;
  VSEGUNDO  INTEGER;
  VMESEXTPT VARCHAR2(200);
  VMESEXTEN VARCHAR2(200);
  VMESEXTES VARCHAR2(200);
  VSUF      INTEGER;
  VCONDICAO VARCHAR2(2);
  BEGIN
    VDIA        := EXTRACT(DAY FROM MOMENTO);
  VMES        := EXTRACT(MONTH FROM MOMENTO);
  VANO        := EXTRACT(YEAR FROM MOMENTO);
  VHORA       := EXTRACT(HOUR FROM TO_TIMESTAMP(MOMENTO));
  VMINUTO     := EXTRACT(MINUTE FROM TO_TIMESTAMP(MOMENTO));
  VSEGUNDO    := EXTRACT(SECOND FROM TO_TIMESTAMP(MOMENTO));
  VMESEXTPT   := 'Janeiro,Fevereiro,Março,Abril,Maio,Junho,Julho,Agosto,Setembro,Outubro,Novembro,Dezembro';
  VMESEXTEN   := 'January,February,March,April,May,June,July,August,September,October,November,December';
  VMESEXTES   := 'Enero,Febrero,Marzo,Abril,Mayo,Junio,Julio,Agosto,Septiembre,Octubre,Noviembre,Diciembre';
  VSUF        := VDIA MOD 10;
  IF (VDIA     > 10) AND (VDIA < 14 ) THEN
    VCONDICAO := 'th';
  ELSIF VSUF   = 1 THEN
    VCONDICAO := 'st';
  ELSIF VSUF   = 2 THEN
    VCONDICAO := 'nd';
  ELSIF VSUF   = 3 THEN
    VCONDICAO := 'rd';
  ELSE
    VCONDICAO := 'th';
  END IF;
  CASE
  WHEN (FORMATO = 'sh') THEN
  RETURN TO_CHAR(MOMENTO,'TS'); -- Simples Hora 24H:MI:SS
WHEN (FORMATO = 'p') OR (FORMATO = 'dd de mmmm de yyyy') THEN
  RETURN LPAD(VDIA,2,'0') || ' de ' || LITEM(VMESEXTPT,VMES,',') || ' de ' || LPAD(VANO,4,'0');
WHEN (FORMATO = 'c') OR (FORMATO = 'dd de mmmm de yyyy c') THEN
  RETURN LPAD(VDIA,2,'0') || ' de ' || LITEM(VMESEXTES,VMES,',') || ' de ' || LPAD(VANO,4,'0');
WHEN (FORMATO = 'i') OR (FORMATO = 'mmmm dth, yyyy') OR (FORMATO = 'mmmm dth yyyy') THEN
  RETURN LITEM(VMESEXTEN,VMES,',') || ' ' || VDIA || VCONDICAO || ', ' || VANO;
WHEN (FORMATO = 'a') OR (FORMATO = 'dd mmm yyyy') THEN
  RETURN LPAD(VDIA,2,'0') || ' ' || LITEM(VMESEXTPT,VMES,',') || ', ' || VANO;
WHEN (FORMATO = 'ai') OR (FORMATO = 'dd mmm yyyy i') THEN
  RETURN LPAD(VDIA,2,'0') || ' ' || UPPER(LITEM(VMESEXTEN,VMES,',')) || ', ' || LPAD(VANO,4,'0');
WHEN (FORMATO = 'mmm dd, yyyy') OR (FORMATO = 'mmm dd yyyy') THEN
  RETURN SUBSTR(UPPER(LITEM(VMESEXTPT,VMES,',')),1,3) || ' ' || VDIA || ', ' || LPAD(VANO,4,'0');
WHEN (FORMATO = 'mmm dd, yyyy i') OR (FORMATO = 'mmm dd yyyy i') THEN
  RETURN SUBSTR(UPPER(LITEM(VMESEXTEN,VMES,',')),1,3) || ' ' || VDIA || ', ' || LPAD(VANO,4,'0');
WHEN (FORMATO = 'mmm dd, yyyy c') OR (FORMATO = 'mmm dd yyyy c') THEN
  RETURN SUBSTR(UPPER(LITEM(VMESEXTES,VMES,',')),1,3) || ' ' || VDIA || ', ' || LPAD(VANO,4,'0');
WHEN (FORMATO = 'mmmm, yyyy') OR (FORMATO = 'mmmm yyyy') THEN
  RETURN LITEM(VMESEXTPT,VMES,',') || ', ' || LPAD(VANO,4,'0');
WHEN (FORMATO = 'mmmm, yyyy i') OR (FORMATO = 'mmmm yyyy i') THEN
  RETURN LITEM(VMESEXTEN,VMES,',') || ', ' || VANO;
WHEN (FORMATO = 'mmmm, yyyy c') OR (FORMATO = 'mmmm yyyy c') THEN
  RETURN LITEM(VMESEXTES,VMES,',') || ', ' || VANO;
WHEN (FORMATO = 'mmmm/yy') OR (FORMATO = 'mmmm yy') THEN
  RETURN LITEM(VMESEXTPT,VMES,',') || '/' || SUBSTR(VANO,3,2);
WHEN (FORMATO = 'mmm') THEN
  RETURN SUBSTR(UPPER(LITEM(VMESEXTPT,VMES,',')),1,3);
WHEN (FORMATO = 'mmm i') THEN
  RETURN SUBSTR(UPPER(LITEM(VMESEXTEN,VMES,',')),1,3);
WHEN (FORMATO = 'mmm c') THEN
  RETURN SUBSTR(UPPER(LITEM(VMESEXTES,VMES,',')),1,3);
WHEN (FORMATO = 'mmmm') THEN
  RETURN LITEM(VMESEXTPT,VMES,',');
WHEN (FORMATO = 'mmmm i') THEN
  RETURN LITEM(VMESEXTEN,VMES,',');
WHEN (FORMATO = 'mmmm c') THEN
  RETURN LITEM(VMESEXTES,VMES,',');
ELSE
  RETURN LPAD (VDIA,2,'0') || '/' || LPAD (VMES,2,'0') || '/' || VANO || ' ' || VHORA || ':' || VMINUTO || ':' || LPAD (VSEGUNDO,2,'0');
END CASE;
END EXIBE_DATA;
  
  FUNCTION LITEM (TEXTO IN VARCHAR2, ITEM  IN NUMBER, SEP IN VARCHAR2 DEFAULT '') RETURN VARCHAR2 AS
  POS   NUMBER;
  POS2  NUMBER;
  BUSCA NUMBER;
  LIMIT VARCHAR2(500);

  BEGIN
    IF NVL(SEP,'') = '' THEN
    IF INSTR(TEXTO, ';') <> 0 THEN
      LIMIT              := ';';
    ELSE
      LIMIT := '.';
    END IF;
  ELSE
    LIMIT := SEP;
  END IF;
  BUSCA     := 0;
  POS       := 1;
  WHILE POS <= LENGTH(TEXTO)
  LOOP
    POS2   := INSTR(TEXTO, LIMIT, POS);
    IF POS2 = 0 THEN
      POS2 := LENGTH(TEXTO)+1;
    END IF;
    BUSCA   := BUSCA + 1;
    IF BUSCA = ITEM THEN
      RETURN SUBSTR(TEXTO, POS, POS2-POS);
    ELSE
      POS := POS2 + 1;
    END IF;
  END LOOP;
  RETURN '';
EXCEPTION
WHEN OTHERS THEN
  RAISE_APPLICATION_ERROR ( -20000, 'erro em litem: ' || SQLERRM);
  END LITEM;

  FUNCTION LITEM (TEXTO IN VARCHAR2, ITEM  IN VARCHAR2, SEP IN VARCHAR2 DEFAULT '') RETURN NUMBER AS
    POS   NUMBER;
  POS2  NUMBER;
  BUSCA NUMBER;
  LIMIT VARCHAR2(500);
  BEGIN
    IF NVL(SEP,'') = '' THEN
    IF INSTR(TEXTO, ';') <> 0 THEN
      LIMIT              := ';';
    ELSE
      LIMIT := '.';
    END IF;
  ELSE
    LIMIT := SEP;
  END IF;
  BUSCA     := 0;
  POS       := 1;
  WHILE POS <= LENGTH(TEXTO)
  LOOP
    POS2   := INSTR(TEXTO, LIMIT, POS);
    IF POS2 = 0 THEN
      POS2 := LENGTH(TEXTO)+1;
    END IF;
    BUSCA                            := BUSCA + 1;
    IF NOT ITEM                      IS NULL THEN
      IF SUBSTR(TEXTO, POS, POS2-POS) = ITEM THEN
        RETURN BUSCA;
      END IF;
    END IF;
    POS := POS2 + 1;
  END LOOP;
  RETURN 0;
EXCEPTION
WHEN OTHERS THEN
  RAISE_APPLICATION_ERROR ( -20000, 'erro em litem: ' || SQLERRM);
  END LITEM;
    
FUNCTION QTD_ITENS(TEXTO VARCHAR2, DELIM VARCHAR2) RETURN INTEGER AS
  POS INTEGER := 1;
  QTD INTEGER := 1;
BEGIN
  IF TEXTO IS NULL THEN
    QTD    := 0;
  ELSE
    WHILE POS <= LENGTH(TEXTO)
    LOOP
      POS    := DBMS_ICRAFT.INSTR_I(POS, TEXTO, DELIM);
      IF POS <= LENGTH(TEXTO) THEN
        QTD  := QTD + 1;
        POS  := POS + LENGTH(DELIM);
      END IF;
    END LOOP;
  END IF;
  RETURN QTD;
END;

FUNCTION OBTEM_ITEM(TEXTO VARCHAR2, DELIM VARCHAR2, ITEM  INTEGER) RETURN VARCHAR2 AS
  POS      INTEGER := 1;
  POS_PROX INTEGER;
  ITEM_IND INTEGER := 1;
BEGIN
  WHILE POS <= LENGTH(TEXTO)
  LOOP
    POS_PROX   := DBMS_ICRAFT.INSTR_I(POS, TEXTO, DELIM);
    IF ITEM_IND = ITEM THEN
      RETURN SUBSTR(TEXTO, POS, POS_PROX-POS);
    END IF;
    POS      := POS_PROX +LENGTH(DELIM);
    ITEM_IND := ITEM_IND + 1;
  END LOOP;
  RETURN '';
END;

FUNCTION REPL_REPL(TEXTO VARCHAR2, DE VARCHAR2, PARA VARCHAR2) RETURN VARCHAR2 AS
  TEXTO2 VARCHAR2(4000);
BEGIN
  TEXTO2                := TEXTO;
  WHILE INSTR(TEXTO2,DE)<>0
  LOOP
    TEXTO2 := REPLACE(TEXTO2, DE, PARA);
  END LOOP;
  RETURN TEXTO2;
END;

FUNCTION SO_EMAIL_STR(EMAILSTR VARCHAR2) RETURN VARCHAR2 AS
    EMAIL VARCHAR2(400);
  BEGIN
    SELECT REGEXP_REPLACE(EMAILSTR, '".*"', '') INTO EMAIL FROM DUAL;
    SELECT REGEXP_SUBSTR(EMAIL, '[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+')
    INTO EMAIL
    FROM DUAL;
    RETURN EMAIL;
  END;
  
  FUNCTION EMAIL_STR(EMAILSTR IN VARCHAR2) RETURN VARCHAR2 AS
  EMAIL   VARCHAR2(500);
  SOEMAIL VARCHAR2(500);
BEGIN
  EMAIL               := TRIM(EMAILSTR);
  EMAIL               := REPLACE(REPLACE(REPLACE(EMAIL, '[', '<'),']','>'),CHR(160),' ');
  IF SUBSTR(EMAIL,1,1) = '''' THEN
    SELECT REGEXP_REPLACE(EMAIL,'''(.*)''','"\1"') INTO EMAIL FROM dual;
  END IF;
  EMAIL   := REPLACE(EMAIL, '''', '`');
  SOEMAIL := SO_EMAIL_STR(EMAIL);
  EMAIL   := REPLACE(EMAIL, '<' || SOEMAIL || '>','');
  EMAIL   := REPLACE(EMAIL, SOEMAIL, '');
  EMAIL   := REPLACE(EMAIL, CHR(9), '');
  EMAIL   := TRIM(REPL_REPL(EMAIL, '  ', ' '));
  EMAIL   := SBDB.DBMS_ICRAFT.TRIM_CARAC(EMAIL, CHR(34));
  EMAIL   := SBDB.DBMS_ICRAFT.TRIM_CARAC(EMAIL, '''');
  SELECT REGEXP_REPLACE(EMAIL, '`(.*)´', '\1') INTO EMAIL FROM DUAL;
  IF LENGTH(EMAIL) > 0 THEN
    EMAIL         := '"' || EMAIL || '"';
  END IF;
  EMAIL := SBDB.DBMS_ICRAFT.EXPR_EXPR(' ', '', EMAIL, '<' || SOEMAIL || '>');
  RETURN EMAIL;
END;

PROCEDURE ENVIA_EMAIL(DE in varchar2, PARA in varchar2, ASSUNTO in varchar2, TEXTO in CLOB, SERVIDOR_SMTP in varchar2 default 'SMTPI', SERVIDOR_PORTA in INTEGER DEFAULT 25) as
  smtp utl_smtp.connection;
  DominioOrigem VARCHAR(15);
  ServNome      VARCHAR2(100);
BEGIN
  DOMINIOORIGEM := SERVIDOR_SMTP;
  
  smtp := utl_smtp.open_connection(SERVIDOR_SMTP,SERVIDOR_PORTA);
  UTL_SMTP.EHLO(SMTP, DOMINIOORIGEM);
  UTL_SMTP.MAIL(SMTP, '<' || IM.DBMS_ICRAFT.SO_EMAIL_STR(DE) || '>');
  FOR Z IN 1..IM.DBMS_ICRAFT.QTD_ITENS(PARA,';')
  LOOP
    UTL_SMTP.RCPT(smtp, '<'|| IM.DBMS_ICRAFT.SO_EMAIL_STR(IM.DBMS_ICRAFT.OBTEM_ITEM(PARA,';',Z)) ||'>');
  END LOOP;
  UTL_SMTP.OPEN_DATA(SMTP);
  UTL_SMTP.WRITE_DATA(SMTP, 'From: ' || IM.DBMS_ICRAFT.EMAIL_STR(DE) || UTL_TCP.CRLF);
  FOR Z IN 1..IM.DBMS_ICRAFT.QTD_ITENS(PARA,';')
  LOOP
    UTL_SMTP.WRITE_DATA(SMTP, 'To: ' || IM.DBMS_ICRAFT.EMAIL_STR(IM.DBMS_ICRAFT.OBTEM_ITEM(PARA,';',Z)) || UTL_TCP.CRLF);
  END LOOP;
  SELECT machine
  INTO ServNome
  FROM v$session
  WHERE program LIKE 'ORACLE.EXE%'
  AND type  ='BACKGROUND'
  AND ROWNUM=1;
  utl_smtp.write_raw_data(smtp,utl_raw.cast_to_raw('Subject:' || Assunto));
  UTL_SMTP.WRITE_DATA(smtp,UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'MIME-Version: 1.0' || UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Type: multipart/mixed;'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,CHR(9)||'boundary="MENSAGEM"'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'X-Priority: 1 (Highest)'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'X-MSMail-Priority: High'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'X-Mailer: Microsoft Office Outlook, Build 11.0.5510'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1807'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Importance: High'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'--MENSAGEM'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Type: multipart/related;'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,CHR(9)||'boundary="CONTEUDOHTML"'||UTL_TCP.CRLF||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'--CONTEUDOHTML'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Type: text/html;'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,CHR(9)||'charset="iso-8859-1"'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Transfer-Encoding: quoted-printable'||UTL_TCP.CRLF||UTL_TCP.CRLF);
  utl_smtp.write_raw_data(smtp,utl_raw.cast_to_raw(Texto));
  UTL_SMTP.CLOSE_DATA(smtp);
  UTL_SMTP.QUIT(smtp);
EXCEPTION
WHEN utl_smtp.transient_error OR utl_smtp.permanent_error THEN
  BEGIN
    UTL_SMTP.QUIT(smtp);
  EXCEPTION
  WHEN UTL_SMTP.TRANSIENT_ERROR OR UTL_SMTP.PERMANENT_ERROR THEN
    NULL; 
  END;
END;

FUNCTION SQL_PARA_HTML(SQLTEXT IN VARCHAR2, QTDCOLS number, NENHUM VARCHAR2 DEFAULT 'Nenhuma linha.') RETURN CLOB AS
    TEXTO CLOB;
  TYPE CONSULTA_REF
IS
  REF
  CURSOR;
    CONSULTA CONSULTA_REF;
    C01 VARCHAR2(400);
    C02 VARCHAR2(400);
    C03 VARCHAR2(400);
    C04 VARCHAR2(400);
    C05 VARCHAR2(400);
    C06 VARCHAR2(400);
    C07 VARCHAR2(400);
    C08 VARCHAR2(400);
    C09 VARCHAR2(400);
    C10 VARCHAR2(400);
    C11 VARCHAR2(400);
    C12 VARCHAR2(400);
    C13 VARCHAR2(400);
    C14 VARCHAR2(400);
    C15 VARCHAR2(400);
    C16 VARCHAR2(400);
    C17 VARCHAR2(400);
    C18 VARCHAR2(400);
    C19 VARCHAR2(400);
    C20 VARCHAR2(400);

    QTDLIN NUMBER;
  BEGIN
    IF QTDCOLS > 20 THEN
       RAISE_APPLICATION_ERROR(-20000, 'Num max de colunas permitido: 20');
    END IF;
    TEXTO := '';
    QTDLIN := 1;
    OPEN CONSULTA FOR SQLTEXT;
    LOOP
      CASE QTDCOLS
    WHEN 1 THEN
        FETCH CONSULTA INTO C01;
    WHEN 2 THEN
      FETCH CONSULTA INTO C01, C02;
    WHEN 3 THEN
      FETCH CONSULTA INTO C01, C02, C03;
    WHEN 4 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04;
    WHEN 5 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05;
    WHEN 6 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06;
    WHEN 7 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07;
    WHEN 8 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08;
    WHEN 9 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09;
    WHEN 10 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10;
    WHEN 11 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11;
    WHEN 12 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12;
    WHEN 13 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13;
    WHEN 14 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13, C14;
    WHEN 15 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13, C14, C15;
    WHEN 16 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13, C14, C15, C16;
    WHEN 17 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13, C14, C15, C16, C17;
    WHEN 18 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13, C14, C15, C16, C17, C18;
    WHEN 19 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19;
    WHEN 20 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19, C20;

    END CASE;

      EXIT when CONSULTA%NOTFOUND;
    TEXTO := TEXTO || '<tr ';
    if MOD(QTDLIN,2)=1 then
       TEXTO := TEXTO || 'class  =  ''odd''  ';
    ELSE
       TEXTO := TEXTO || '';
    END IF;
    TEXTO   := TEXTO || '>';
    FOR IND IN 1..qtdcols
    LOOP
      TEXTO := TEXTO || '<td>';
      CASE IND
      WHEN 1 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C01);
      WHEN 2 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C02);
      WHEN 3 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C03);
      WHEN 4 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C04);
      WHEN 5 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C05);
      WHEN 6 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C06);
      WHEN 7 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C07);
      WHEN 8 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C08);
      WHEN 9 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C09);
      WHEN 10 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C10);
      WHEN 11 THEN
                TEXTO := TEXTO || HTF.ESCAPE_SC(C11);
      WHEN 12 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C12);
      WHEN 13 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C13);
      WHEN 14 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C14);
      WHEN 15 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C15);
      WHEN 16 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C16);
      WHEN 17 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C17);
      WHEN 18 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C18);
      WHEN 19 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C19);
      WHEN 20 THEN
        TEXTO := TEXTO || HTF.ESCAPE_SC(C20);
      END CASE;
      TEXTO := TEXTO || '</td>';
    END LOOP;
    TEXTO := TEXTO || '</tr>';
    QTDLIN := QTDLIN + 1;
  END LOOP;
  if length(TEXTO)<>0 then
TEXTO := '<table>' || TEXTO || '</table>';
  ELSE
TEXTO := '<table><tr><td>' || NENHUM || '</td></tr></table>';
  END IF;
  
  
TEXTO := '<style>


table {
border:3px solid #a0a0a0;
font: 12px Verdana, sans-serif;
color:black;
}

table tr{
background-color:#f0f0f0;
}

table tr{
background-color:#f0f0f0;
}

table tr.odd {
background-color:#d0d0d0;
}

table tr td {
padding: 4px;
}

</style>

' || TEXTO;

RETURN TEXTO;
end SQL_PARA_HTML;

PROCEDURE JOB_APAGA_TODOS(ESQUEMA VARCHAR2) AS
BEGIN
  FOR CUR IN
  (SELECT job, SCHEMA_USER schema,WHAT FROM DBA_JOBS
  )
  LOOP
    IF ESQUEMA IS NULL OR CUR.schema = ESQUEMA THEN
      DBMS_OUTPUT.PUT_LINE('ELIMINANDO JOB ' || CUR.job || ' - ' || CUR.WHAT);
      BEGIN
        SYS.DBMS_IJOB.REMOVE(CUR.job);
        DBMS_OUTPUT.PUT_LINE('=> OK');
      EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('=> ERRO: ' || SQLERRM);
      END;
    END IF;
  END LOOP;
END;

PROCEDURE JOB_APAGA(TRECHO VARCHAR2) AS
BEGIN
  FOR CUR IN
  (SELECT job
  FROM DBA_JOBS
  WHERE UPPER(WHAT) LIKE '%/* %'
    || UPPER(TRECHO)
    || '% */%'
  )
  LOOP
    BEGIN
      SYS.DBMS_JOB.REMOVE(CUR.job);
    EXCEPTION
    WHEN OTHERS THEN
      NULL;
    END;
  END LOOP;
END;

PROCEDURE JOB_CRIA(TITULO IN VARCHAR2, EXEC IN VARCHAR2, MOMENTO_EXEC IN DATE DEFAULT SYSDATE+1/86400, CALC_PROC_EXEC VARCHAR2 DEFAULT 'SYSDATE + 1') AS
  job BINARY_INTEGER;
BEGIN
  BEGIN
    JOB_APAGA(TITULO);
  EXCEPTION
  WHEN OTHERS THEN
    NULL;
  END;
  DBMS_JOB.SUBMIT(job, '/* ' || TITULO || ' */ begin ' || EXEC || ';end;', MOMENTO_EXEC, CALC_PROC_EXEC);
END;

FUNCTION NOTIFICA_PROX(NOTIFICA VARCHAR2, MOMENTO DATE DEFAULT SYSDATE, VEZES INTEGER DEFAULT 1) RETURN DATE
  IS
    DIAS_DO_MES VARCHAR2 (200);
    HORAS       VARCHAR2 (200);
    DE_EM       INTEGER;
    UNID        VARCHAR2(50);
    EMAIL       VARCHAR2(200);
    OUTROS      VARCHAR2(200);
    MOMENTO_CALC DATE := MOMENTO;
    MES   VARCHAR2(3);
    SEM   VARCHAR2(3);
    VALID BOOLEAN;
  BEGIN
    FOR CUR IN
    (SELECT * FROM TABLE (DBMS_ICRAFT.DICT(NOTIFICA, '|', ':'))
    )
    LOOP
      CASE TRIM(CUR.CHAVE)
      WHEN 'DIAS_DO_MES' THEN
        DIAS_DO_MES := TRIM(CUR.CONTEUDO);
      WHEN 'DE' THEN
        DE_EM := TO_NUMBER(DBMS_ICRAFT.OBTEM_ITEM(TRIM(CUR.CONTEUDO), ' EM ', 1));
        UNID  := DBMS_ICRAFT.OBTEM_ITEM(TRIM(CUR.CONTEUDO), ' EM ', 2);
        UNID  := REGEXP_SUBSTR(UNID,'[^0-9]+');
      WHEN 'EMAILS' THEN
        EMAIL := TRIM(CUR.CONTEUDO);
      WHEN 'HORAS' THEN
        HORAS := TRIM(CUR.CONTEUDO);
      ELSE
        OUTROS := TRIM(CUR.CONTEUDO);
      END CASE;
    END LOOP;
    FOR Z IN 1..VEZES
    LOOP
      VALID := TRUE;
      LOOP
        IF DE_EM          > 0 THEN
          IF VALID        = false THEN
            MOMENTO_CALC := TRUNC(MOMENTO_CALC + 1);
          ELSE
            CASE UPPER(UNID)
            WHEN 'MINUTOS' THEN
              MOMENTO_CALC := MOMENTO_CALC + DE_EM/1440;
            WHEN 'HORAS' THEN
              MOMENTO_CALC := MOMENTO_CALC + DE_EM/24;
            WHEN 'DIAS' THEN
              MOMENTO_CALC := MOMENTO_CALC + DE_EM;
            WHEN 'MESES' THEN
              SELECT ADD_MONTHS(MOMENTO_CALC, DE_EM) INTO MOMENTO_CALC FROM DUAL;
            WHEN 'SEMANAS' THEN
              MOMENTO_CALC := MOMENTO_CALC + DE_EM*7;
            WHEN 'ANOS' THEN
              SELECT ADD_MONTHS(MOMENTO_CALC, DE_EM*12) INTO MOMENTO_CALC FROM DUAL;
            END CASE;
          END IF;
        END IF;
        SELECT DBMS_ICRAFT.EXIBE_DATA(MOMENTO_CALC, 'mmm') INTO MES FROM DUAL;
        SELECT SUBSTR('DOMSEGTERQUAQUISEXSAB', TO_NUMBER(TO_CHAR(MOMENTO_CALC, 'D'))*3-2,3)
        INTO SEM
        FROM DUAL;
        IF extract(YEAR FROM MOMENTO_CALC) > 2020 THEN
          RETURN NULL;
        END IF;
        IF INSTR(' ' || OUTROS || ' ', ' ' || MES || ' ') <> 0 AND INSTR(' ' || OUTROS || ' ', ' ' || SEM || ' ')<>0 THEN
          EXIT;
        END IF;
        VALID := false;
      END LOOP;
    END LOOP;
    RETURN MOMENTO_CALC;
  END;
  
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------


END DBMS_ICRAFT;
/

-- -------------------------------------------------------------------------------------------------------------------------------------------------------------
-- --- DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DESENV INTERCRAFT - BIBLIOTECA DE FUNÇÕES PLSQL ORACLE - DIREITOS RESERVADOS - INTERCRAFT - 2006
-- -------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE PUBLIC SYNONYM DBMS_ICRAFT FOR DBMS_ICRAFT;

