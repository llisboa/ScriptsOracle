SET ECHO ON
SPOOL C:\SBDB_PARTE2.LOG
CONNECT SBDB/XXXX@SBDB;

-- ELIMINA OS JOBS
begin
for cur in (select job from user_jobs where schema_user='SBDB') loop
dbms_job.remove(cur.job);
end loop;
end;
/

-- CRIA ÍNDICES
CREATE UNIQUE INDEX SBDB.GER_USUARIONOME ON SBDB.GER_USUARIO(NOME);
CREATE UNIQUE INDEX SBDB.GER_RELACIONAMENTO_TC_UNICO ON SBDB.GER_RELACIONAMENTO(SISTEMA, TABELA_1, CAMPO_1, TABELA_N, CAMPO_N);


/* **********************************************************************************
   CRIAÇÃO DE RELACIONAMENTOS
*/

ALTER TABLE SBDB."GER_ADICIONAL_OBJ" ADD CONSTRAINT "GER_CLASSE_GER_ADICIONAL_01" FOREIGN KEY("SISTEMA", "CLASSE") REFERENCES SBDB."GER_CLASSE"("SISTEMA", "CLASSE");
ALTER TABLE SBDB."GER_TABELA" ADD CONSTRAINT "GER_CLASSE_GER_TABELA_01" FOREIGN KEY("SISTEMA", "CLASSE") REFERENCES SBDB."GER_CLASSE"("SISTEMA", "CLASSE");
ALTER TABLE SBDB."GER_VISAO" ADD CONSTRAINT "GER_CLASSE_GER_VISAO_01" FOREIGN KEY("SISTEMA", "CLASSE") REFERENCES SBDB."GER_CLASSE"("SISTEMA", "CLASSE");
ALTER TABLE SBDB."GER_ADICIONAL_OBJ" ADD CONSTRAINT "GER_SISTEMA_GER_ADICIONAL_01" FOREIGN KEY("SISTEMA") REFERENCES SBDB."GER_SISTEMA"("NOME");
ALTER TABLE SBDB."GER_CLASSE" ADD CONSTRAINT "GER_SISTEMA_GER_CLASSE_01" FOREIGN KEY("SISTEMA") REFERENCES SBDB."GER_SISTEMA"("NOME");
ALTER TABLE SBDB."GER_DIREITO" ADD CONSTRAINT "GER_SISTEMA_GER_DIREITO_01" FOREIGN KEY("SISTEMA") REFERENCES SBDB."GER_SISTEMA"("NOME");
ALTER TABLE SBDB."GER_GRUPO" ADD CONSTRAINT "GER_SISTEMA_GER_GRUPO_01" FOREIGN KEY("SISTEMA") REFERENCES SBDB."GER_SISTEMA"("NOME");
ALTER TABLE SBDB."GER_TABELA" ADD CONSTRAINT "GER_SISTEMA_GER_TABELA_01" FOREIGN KEY("SISTEMA") REFERENCES SBDB."GER_SISTEMA"("NOME");
ALTER TABLE SBDB."GER_VISAO" ADD CONSTRAINT "GER_SISTEMA_GER_VISAO_01" FOREIGN KEY("SISTEMA") REFERENCES SBDB."GER_SISTEMA"("NOME");
ALTER TABLE SBDB."GER_USUARIO" ADD CONSTRAINT "GER_SISTEMA_GER_USUARIO_01" FOREIGN KEY("SISTEMA") REFERENCES SBDB."GER_SISTEMA"("NOME");
ALTER TABLE SBDB."GER_CAMPO" ADD CONSTRAINT "GER_TABELA_GER_CAMPO_01" FOREIGN KEY("SISTEMA", "TABELA") REFERENCES SBDB."GER_TABELA"("SISTEMA", "TABELA");
ALTER TABLE SBDB."GER_INDICE" ADD CONSTRAINT "GER_TABELA_GER_INDICE_01" FOREIGN KEY("SISTEMA", "TABELA") REFERENCES SBDB."GER_TABELA"("SISTEMA", "TABELA");
ALTER TABLE SBDB."GER_RELACIONAMENTO" ADD CONSTRAINT "GER_TABELA_GER_RELACIONA_01" FOREIGN KEY("SISTEMA", "TABELA_N") REFERENCES SBDB."GER_TABELA"("SISTEMA", "TABELA");
ALTER TABLE SBDB."GER_RELACIONAMENTO" ADD CONSTRAINT "GER_TABELA_GER_RELACIONA_02" FOREIGN KEY("SISTEMA", "TABELA_1") REFERENCES SBDB."GER_TABELA"("SISTEMA", "TABELA");
ALTER TABLE SBDB."GER_ADICIONAL_OBJ" ADD CONSTRAINT "GER_TIPO_OBJ_GER_ADICIONAL_01" FOREIGN KEY("TIPO") REFERENCES SBDB."GER_TIPO_OBJ"("TIPO");
ALTER TABLE SBDB."GER_DIREITO" ADD CONSTRAINT "GER_TIPO_OBJ_GER_DIREITO_01" FOREIGN KEY("OBJETO_TIPO") REFERENCES SBDB."GER_TIPO_OBJ"("TIPO");
ALTER TABLE SBDB."EDITORIAL_TIPO_ASS_ENVIO" ADD CONSTRAINT "EDITO_TIP_EDITO_ENVIO_01" FOREIGN KEY("EDITORIAL_SEQ", "TIPO_ASS_SEQ") REFERENCES SBDB."EDITORIAL_TIPO_ASSINATURA"("EDITORIAL_SEQ", "SEQ");
ALTER TABLE SBDB."SITE_QUEST" ADD CONSTRAINT "SITE_QUEST_SITE_QUEST_TIPO_01" FOREIGN KEY("TIPO") REFERENCES SBDB."SITE_QUEST_TIPO"("COD");
ALTER TABLE SBDB."PAGAMENTO" ADD CONSTRAINT "ARQ_PAGAMENTO_PAGAMENTO_01" FOREIGN KEY("ARQ_SEQ", "ARQ_PAG") REFERENCES SBDB."ARQ_PAGAMENTO"("ARQ_SEQ", "SEQ");
ALTER TABLE SBDB."ARQ_PAGAMENTO" ADD CONSTRAINT "ARQ_RETORNO_ARQ_PAGAMENTO_01" FOREIGN KEY("ARQ_SEQ") REFERENCES SBDB."ARQ_RETORNO"("SEQ");
ALTER TABLE SBDB."BIBLIO_LANCAMENTO" ADD CONSTRAINT "BIBLIO_PEDIDO_BIBLIO_LANCAM_01" FOREIGN KEY("COD_PEDIDO") REFERENCES SBDB."BIBLIO_PEDIDO"("COD");
ALTER TABLE SBDB."BIBLIO_PEDIDO" ADD CONSTRAINT "BIBLIO_REQUIS_BIBLIO_PEDIDO_01" FOREIGN KEY("COD_REQUISITANTE") REFERENCES SBDB."BIBLIO_REQUISITANTE"("COD");
ALTER TABLE SBDB."BIBLIO_PEDIDO" ADD CONSTRAINT "BIBLIO_SERVIC_BIBLIO_PEDIDO_01" FOREIGN KEY("COD_SERVICO") REFERENCES SBDB."BIBLIO_SERVICO"("COD");
ALTER TABLE SBDB."BIBLIO_SERVICO_PRECO" ADD CONSTRAINT "BIBLIO_SERVIC_BIBLIO_SERVIP_01" FOREIGN KEY("COD_SERVICO") REFERENCES SBDB."BIBLIO_SERVICO"("COD");
ALTER TABLE SBDB."ÓRGÃO_GESTÃO" ADD CONSTRAINT "CARGO_ÓRGÃO_GESTÃO_01" FOREIGN KEY("ÓRGÃO_CARGO") REFERENCES SBDB."CARGO"("CARGO");
ALTER TABLE SBDB."ANUIDADE_CATEGORIA" ADD CONSTRAINT "CATEGORIA_ANUIDADE_CATE_01" FOREIGN KEY("CATEGORIA_COD") REFERENCES SBDB."CATEGORIA"("COD");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "CATEGORIA_SÓCIO_01" FOREIGN KEY("CATEGORIA_COD") REFERENCES SBDB."CATEGORIA"("COD");
ALTER TABLE SBDB."SÓCIO_CATEGORIA" ADD CONSTRAINT "CATEGORIA_SÓCIO_CATEGOR_01" FOREIGN KEY("CATEGORIA_COD") REFERENCES SBDB."CATEGORIA"("COD");
ALTER TABLE SBDB."SÓCIO_CONVÊNIO" ADD CONSTRAINT "CONVÊNIO_SÓCIO_CONVÊNI_01" FOREIGN KEY("CONVÊNIO_COD") REFERENCES SBDB."CONVÊNIO"("COD");
ALTER TABLE SBDB."EDITORIAL_TIPO_ASSINATURA" ADD CONSTRAINT "EDITORIAL_EDITORIAL_TIP_01" FOREIGN KEY("EDITORIAL_SEQ") REFERENCES SBDB."EDITORIAL"("SEQ");
ALTER TABLE SBDB."EMCD_PONTO_SÓCIO" ADD CONSTRAINT "EMCD_ATIV_PON_EMCD_PONTO_SÓ_01" FOREIGN KEY("ATIV_COD", "PONTO_COD") REFERENCES SBDB."EMCD_ATIV_PONTO"("ATIV_COD", "PONTO_COD");
ALTER TABLE SBDB."EMCD_ATIV_PONTO" ADD CONSTRAINT "EMCD_ATIVIDAD_EMCD_ATIV_PON_01" FOREIGN KEY("ATIV_COD") REFERENCES SBDB."EMCD_ATIVIDADE"("COD");
ALTER TABLE SBDB."EMCD_ATIVIDADE" ADD CONSTRAINT "EMCD_ATIVIDAD_EMCD_ATIVIDAD_01" FOREIGN KEY("SUPERIOR") REFERENCES SBDB."EMCD_ATIVIDADE"("COD");
ALTER TABLE SBDB."EMCD_PONTO_SÓCIO" ADD CONSTRAINT "EMCD_ATIVIDAD_EMCD_PONTO_SÓ_01" FOREIGN KEY("ATIV_COD") REFERENCES SBDB."EMCD_ATIVIDADE"("COD");
ALTER TABLE SBDB."EMCD_APURAÇÃO" ADD CONSTRAINT "EMCD_FASE_EMCD_APURAÇÃO_01" FOREIGN KEY("APURACAO") REFERENCES SBDB."EMCD_FASE"("FASE");
ALTER TABLE SBDB."EMCD_PONTO_FASE" ADD CONSTRAINT "EMCD_FASE_EMCD_PONTO_FA_01" FOREIGN KEY("APURACAO") REFERENCES SBDB."EMCD_FASE"("FASE");
ALTER TABLE SBDB."EMCD_PONTO_FASE" ADD CONSTRAINT "EMCD_PONTO_SÓ_EMCD_PONTO_FA_01" FOREIGN KEY("SOCIO_MAT", "ATIV_COD", "PONTO_COD") REFERENCES SBDB."EMCD_PONTO_SÓCIO"("SÓCIO_MAT", "ATIV_COD", "PONTO_COD");
ALTER TABLE SBDB."EMCD_ATIV_PONTO" ADD CONSTRAINT "EMCD_TIPO_PON_EMCD_ATIV_PON_01" FOREIGN KEY("PONTO_COD") REFERENCES SBDB."EMCD_TIPO_PONTO"("COD");
ALTER TABLE SBDB."EMCD_PONTO_SÓCIO" ADD CONSTRAINT "EMCD_TIPO_PON_EMCD_PONTO_SÓ_01" FOREIGN KEY("PONTO_COD") REFERENCES SBDB."EMCD_TIPO_PONTO"("COD");
ALTER TABLE SBDB."REGIONAL" ADD CONSTRAINT "ESTADO_REGIONAL_01" FOREIGN KEY("ESTADO") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "ESTADO_SÓCIO_01" FOREIGN KEY("CRM_ESTADO") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "ESTADO_SÓCIO_02" FOREIGN KEY("NATURALIDADE") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "ESTADO_SÓCIO_03" FOREIGN KEY("ESTADO_RESIDENCIAL") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "ESTADO_SÓCIO_04" FOREIGN KEY("ESTADO_COMERCIAL_1") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "ESTADO_SÓCIO_05" FOREIGN KEY("ESTADO_COMERCIAL_2") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."PARCELAMENTO" ADD CONSTRAINT "NEGOCIAÇÃO_PARCELAMENTO_01" FOREIGN KEY("SÓCIO_MAT", "NEG_SEQ") REFERENCES SBDB."NEGOCIAÇÃO"("SÓCIO_MAT", "SEQ");
ALTER TABLE SBDB."PAGAMENTO" ADD CONSTRAINT "OBRIGAÇÃO_PAGAMENTO_01" FOREIGN KEY("SÓCIO_MAT", "OBRIG_SEQ") REFERENCES SBDB."OBRIGAÇÃO"("SÓCIO_MAT", "SEQ");
ALTER TABLE SBDB."PARCELAMENTO" ADD CONSTRAINT "OBRIGAÇÃO_PARCELAMENTO_01" FOREIGN KEY("SÓCIO_MAT", "OBRIG_ANTERIOR") REFERENCES SBDB."OBRIGAÇÃO"("SÓCIO_MAT", "SEQ");
ALTER TABLE SBDB."PARCELAMENTO" ADD CONSTRAINT "OBRIGAÇÃO_PARCELAMENTO_02" FOREIGN KEY("SÓCIO_MAT", "OBRIG_NOVA") REFERENCES SBDB."OBRIGAÇÃO"("SÓCIO_MAT", "SEQ");
ALTER TABLE SBDB."OBRIGAÇÃO" ADD CONSTRAINT "OBRIGAÇÃO_STA_OBRIGAÇÃO_01" FOREIGN KEY("OBRIG_STATUS_COD") REFERENCES SBDB."OBRIGAÇÃO_STATUS"("COD");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "OBRIGAÇÃO_STA_SÓCIO_01" FOREIGN KEY("OBRIG_STATUS_COD") REFERENCES SBDB."OBRIGAÇÃO_STATUS"("COD");
ALTER TABLE SBDB."OBRIGAÇÃO" ADD CONSTRAINT "OBRIGAÇÃO_TIP_OBRIGAÇÃO_01" FOREIGN KEY("OBRIG_TIPO") REFERENCES SBDB."OBRIGAÇÃO_TIPO"("TIPO");
ALTER TABLE SBDB."ÓRGÃO_MEMBRO" ADD CONSTRAINT "ÓRGÃO_GESTÃO_ÓRGÃO_MEMBRO_01" FOREIGN KEY("ÓRGÃO_NOME", "ÓRGÃO_GESTÃO_INI", "ÓRGÃO_CARGO") REFERENCES SBDB."ÓRGÃO_GESTÃO"("ÓRGÃO_NOME", "GESTÃO_INI", "ÓRGÃO_CARGO");
ALTER TABLE SBDB."ÓRGÃO_GESTÃO" ADD CONSTRAINT "ÓRGÃO_ÓRGÃO_GESTÃO_01" FOREIGN KEY("ÓRGÃO_NOME") REFERENCES SBDB."ÓRGÃO"("NOME");
ALTER TABLE SBDB."ÓRGÃO" ADD CONSTRAINT "ÓRGÃO_TIPO_ÓRGÃO_01" FOREIGN KEY("ÓRGÃO_TIPO") REFERENCES SBDB."ÓRGÃO_TIPO"("TIPO");
ALTER TABLE SBDB."ESTADO" ADD CONSTRAINT "REGIÃO_ESTADO_01" FOREIGN KEY("REGIAO") REFERENCES SBDB."REGIÃO"("NOME");
ALTER TABLE SBDB."EMCD_ATIVIDADE" ADD CONSTRAINT "REGIONAL_EMCD_ATIVIDAD_01" FOREIGN KEY("REGIONAL_COD") REFERENCES SBDB."REGIONAL"("COD");
ALTER TABLE SBDB."ÓRGÃO" ADD CONSTRAINT "REGIONAL_ÓRGÃO_01" FOREIGN KEY("REGIONAL_COD") REFERENCES SBDB."REGIONAL"("COD");
ALTER TABLE SBDB."SÓCIO" ADD CONSTRAINT "REGIONAL_SÓCIO_01" FOREIGN KEY("REGIONAL_COD") REFERENCES SBDB."REGIONAL"("COD");
ALTER TABLE SBDB."REUNIAO_SOCIO" ADD CONSTRAINT "REUNIAO_REUNIAO_SOCIO_01" FOREIGN KEY("REUNIAO_SEQ") REFERENCES SBDB."REUNIAO"("SEQ");
ALTER TABLE SBDB."ADM_HIST_TED" ADD CONSTRAINT "SERVIÇO_CREDE_ADM_HIST_TED_01" FOREIGN KEY("SERV_CRED_COD") REFERENCES SBDB."SERVIÇO_CREDENCIADO"("COD");
ALTER TABLE SBDB."SERV_CRED_CORPO_CLINICO" ADD CONSTRAINT "SERVIÇO_CREDE_SERV_CRED_COR_01" FOREIGN KEY("SERV_CRED_COD") REFERENCES SBDB."SERVIÇO_CREDENCIADO"("COD");
ALTER TABLE SBDB."SERV_CRED_FOTO" ADD CONSTRAINT "SERVIÇO_CREDE_SERV_CRED_FOT_01" FOREIGN KEY("SERV_CRED_COD") REFERENCES SBDB."SERVIÇO_CREDENCIADO"("COD");
ALTER TABLE SBDB."SERV_CRED_RENOVAÇÃO" ADD CONSTRAINT "SERVIÇO_CREDE_SERV_CRED_REN_01" FOREIGN KEY("SERV_CRED_COD") REFERENCES SBDB."SERVIÇO_CREDENCIADO"("COD");
ALTER TABLE SBDB."SITE_CALENDARIO_DATA" ADD CONSTRAINT "SITE_CALENDAR_SITE_CALENDAT_01" FOREIGN KEY("TIPO") REFERENCES SBDB."SITE_CALENDARIO_TIPO"("SEQ");
ALTER TABLE SBDB."SITE_EVENTO" ADD CONSTRAINT "ESTADO_SITE_EVENTO_01" FOREIGN KEY("ESTADO") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."SERVIÇO_CREDENCIADO" ADD CONSTRAINT "ESTADO_SERVIÇO_CREDE_01" FOREIGN KEY("ESTADO") REFERENCES SBDB."ESTADO"("SIGLA");
ALTER TABLE SBDB."SERV_CRED_CORPO_ADJ" ADD CONSTRAINT "SERVIÇO_CREDE_SERV_CRED_ADJ_01" FOREIGN KEY("SERV_CRED_COD") REFERENCES SBDB."SERVIÇO_CREDENCIADO"("COD");
ALTER TABLE SBDB."BOLETO" ADD CONSTRAINT "PRODUTO_BOLETO_01" FOREIGN KEY("PRODUTO_SEQ") REFERENCES SBDB."PRODUTO"("SEQ");
ALTER TABLE SBDB."BOLETO" ADD CONSTRAINT "SOCIO_BOLETO_01" FOREIGN KEY("SACADO_SOCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."SITE_QUEST_QUESTAO" ADD CONSTRAINT "SITE_QUEST_MO_SITE_QUEST_QU_01" FOREIGN KEY("MODELO") REFERENCES SBDB."SITE_QUEST_MODELO_RESP"("COD");
ALTER TABLE SBDB."SITE_QUEST_QUESTAO" ADD CONSTRAINT "SITE_QUEST_QU_SITE_QUEST_QU_01" FOREIGN KEY("QUEST_SEQ", "QUESTAO_SUP_SEQ") REFERENCES SBDB."SITE_QUEST_QUESTAO"("QUEST_SEQ", "SEQ");
ALTER TABLE SBDB."SITE_QUEST_RESP" ADD CONSTRAINT "SITE_QUEST_QU_SITE_QUEST_RE_01" FOREIGN KEY("QUEST_SEQ", "QUESTAO_SEQ") REFERENCES SBDB."SITE_QUEST_QUESTAO"("QUEST_SEQ", "SEQ");
ALTER TABLE SBDB."SITE_QUEST_QUESTAO" ADD CONSTRAINT "SITE_QUEST_SITE_QU_QUEST_QU_01" FOREIGN KEY("QUEST_SEQ") REFERENCES SBDB."SITE_QUEST"("SEQ");
ALTER TABLE SBDB."SERV_CRED_RESIDENTE" ADD CONSTRAINT "SERVIÇO_CREDE_SERV_CRED_RES_01" FOREIGN KEY("SERV_CRED_COD") REFERENCES SBDB."SERVIÇO_CREDENCIADO"("COD");
ALTER TABLE SBDB."SERV_CRED_USUARIO" ADD CONSTRAINT "SERVIÇO_CREDE_SERV_CRED_USU_01" FOREIGN KEY("SERV_CRED_COD") REFERENCES SBDB."SERVIÇO_CREDENCIADO"("COD");
ALTER TABLE SBDB."SITE_REVISTA" ADD CONSTRAINT "SITE_REVISTA__SITE_REVISTA_01" FOREIGN KEY("COD_POS_REVISTA") REFERENCES SBDB."SITE_REVISTA_POSICAO"("COD_POS_REVISTA");
ALTER TABLE SBDB."ADM_HIST_TED" ADD CONSTRAINT "SÓCIO_ADM_HIST_TED_01" FOREIGN KEY("SOCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."BIBLIO_PEDIDO" ADD CONSTRAINT "SÓCIO_BIBLIO_PEDIDO_01" FOREIGN KEY("MAT_ASSOCIADO") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."EMCD_APURAÇÃO" ADD CONSTRAINT "SÓCIO_EMCD_APURAÇÃO_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."EMCD_PONTO_SÓCIO" ADD CONSTRAINT "SÓCIO_EMCD_PONTO_SÓ_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."HISTORICO_LICENCIADO" ADD CONSTRAINT "SÓCIO_HISTORICO_LIC_01" FOREIGN KEY("SOCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."HISTORICO_PENALIZADO" ADD CONSTRAINT "SÓCIO_HISTORICO_PEN_01" FOREIGN KEY("SOCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."HISTORICO_SOCIO_ELETRONICO" ADD CONSTRAINT "SÓCIO_HISTORICO_SOC_01" FOREIGN KEY("SOCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."HISTORICO_SOCIO_PUBL_END" ADD CONSTRAINT "SÓCIO_HISTORICO_SOP_01" FOREIGN KEY("SOCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."NEGOCIAÇÃO" ADD CONSTRAINT "SÓCIO_NEGOCIAÇÃO_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."OBRIGAÇÃO" ADD CONSTRAINT "SÓCIO_OBRIGAÇÃO_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."ÓRGÃO_MEMBRO" ADD CONSTRAINT "SÓCIO_ÓRGÃO_MEMBRO_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."PARCELAMENTO" ADD CONSTRAINT "SÓCIO_PARCELAMENTO_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."REUNIAO_SOCIO" ADD CONSTRAINT "SÓCIO_REUNIAO_SOCIO_01" FOREIGN KEY("SOCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."SERVIÇO_CREDENCIADO" ADD CONSTRAINT "SÓCIO_SERVIÇO_CREDE_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."SÓCIO_CATEGORIA" ADD CONSTRAINT "SÓCIO_SÓCIO_CATEGOR_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."SÓCIO_CONVÊNIO" ADD CONSTRAINT "SÓCIO_SÓCIO_CONVÊNI_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."SÓCIO_ISENÇÃO" ADD CONSTRAINT "SÓCIO_SÓCIO_ISENÇÃO_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."SÓCIO_SUB_ESPECIALIDADE" ADD CONSTRAINT "SÓCIO_SÓCIO_SUB_ESP_01" FOREIGN KEY("SÓCIO_MAT") REFERENCES SBDB."SÓCIO"("MAT");
ALTER TABLE SBDB."SÓCIO_SUB_ESPECIALIDADE" ADD CONSTRAINT "SUB_ESPECIALI_SÓCIO_SUB_ESP_01" FOREIGN KEY("SUB_ESPECIAL_COD") REFERENCES SBDB."SUB_ESPECIALIDADE"("COD");


/* **********************************************************************************
   CONSTRAINTS BASE EM CHECK
*/

ALTER TABLE SBDB."EMCD_LOTE" ADD CONSTRAINT "CHECK_EMCD_LOTE" CHECK (
"SEQ" IS NOT NULL
)
/

ALTER TABLE SBDB."EMCD_LOTE_PONTO" ADD CONSTRAINT "CHECK_EMCD_LOTE_PONTO" CHECK (
"LOTE_SEQ" IS NOT NULL AND "SEQ" IS NOT NULL
)
/

ALTER TABLE SBDB."EMCD_LOTE_PONTO_STATUS" ADD CONSTRAINT "CHECK_EMCD_LOTE_PONTO_STATUS" CHECK (
"STATUS" IS NOT NULL
)
/

ALTER TABLE SBDB."EMCD_LOTE_STATUS" ADD CONSTRAINT "CHECK_EMCD_LOTE_STATUS" CHECK (
"STATUS" IS NOT NULL
)
/

/* **********************************************************************************
   CRIAÇÃO DE TRIGGERS PARA REGISTRO DE INCLUSÃO, ATUALIZAÇÃO E EXCLUSÃO
*/

CREATE OR REPLACE TRIGGER SBDB.BEF_ADM_HIST_TED BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ADM_HIST_TED FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ADM_HIST_TED' AND CHAVE || '' = :OLD.SOCIO_MAT || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ADM_HIST_TED', :OLD.SOCIO_MAT || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ADM_HIST_TED' AND CHAVE || ''= :OLD.SOCIO_MAT || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ANUIDADE_CATEGORIA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ANUIDADE_CATEGORIA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ANUIDADE_CATEGORIA' AND CHAVE || '' = :OLD.ANUIDADE_REF || :OLD.CATEGORIA_COD || :OLD.DATA_DESCONTO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ANUIDADE_CATEGORIA', :OLD.ANUIDADE_REF || :OLD.CATEGORIA_COD || :OLD.DATA_DESCONTO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ANUIDADE_CATEGORIA' AND CHAVE || ''= :OLD.ANUIDADE_REF || :OLD.CATEGORIA_COD || :OLD.DATA_DESCONTO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ARQ_PAGAMENTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ARQ_PAGAMENTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ARQ_PAGAMENTO' AND CHAVE || '' = :OLD.ARQ_SEQ || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ARQ_PAGAMENTO', :OLD.ARQ_SEQ || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ARQ_PAGAMENTO' AND CHAVE || ''= :OLD.ARQ_SEQ || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ARQ_REMESSA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ARQ_REMESSA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ARQ_REMESSA' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ARQ_REMESSA', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ARQ_REMESSA' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ARQ_RETORNO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ARQ_RETORNO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ARQ_RETORNO' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ARQ_RETORNO', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ARQ_RETORNO' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_BIBLIO_LANCAMENTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.BIBLIO_LANCAMENTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'BIBLIO_LANCAMENTO' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('BIBLIO_LANCAMENTO', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'BIBLIO_LANCAMENTO' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_BIBLIO_PEDIDO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.BIBLIO_PEDIDO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'BIBLIO_PEDIDO' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('BIBLIO_PEDIDO', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'BIBLIO_PEDIDO' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_BIBLIO_REQUISITANTE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.BIBLIO_REQUISITANTE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'BIBLIO_REQUISITANTE' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('BIBLIO_REQUISITANTE', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'BIBLIO_REQUISITANTE' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_BIBLIO_SERVICO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.BIBLIO_SERVICO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'BIBLIO_SERVICO' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('BIBLIO_SERVICO', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'BIBLIO_SERVICO' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_BIBLIO_SERVICO_PRECO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.BIBLIO_SERVICO_PRECO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'BIBLIO_SERVICO_PRECO' AND CHAVE || '' = :OLD.COD_SERVICO || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('BIBLIO_SERVICO_PRECO', :OLD.COD_SERVICO || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'BIBLIO_SERVICO_PRECO' AND CHAVE || ''= :OLD.COD_SERVICO || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_BOLETO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.BOLETO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'BOLETO' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('BOLETO', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'BOLETO' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_CARGO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.CARGO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'CARGO' AND CHAVE || '' = :OLD.CARGO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('CARGO', :OLD.CARGO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'CARGO' AND CHAVE || ''= :OLD.CARGO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_CATEGORIA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.CATEGORIA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'CATEGORIA' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('CATEGORIA', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'CATEGORIA' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_CONVÊNIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.CONVÊNIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'CONVÊNIO' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('CONVÊNIO', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'CONVÊNIO' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EDITORIAL BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EDITORIAL FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EDITORIAL' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EDITORIAL', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EDITORIAL' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EDITORIAL_TIPO_ASS_ENVIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EDITORIAL_TIPO_ASS_ENVIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EDITORIAL_TIPO_ASS_ENVIO' AND CHAVE || '' = :OLD.SEQ || :OLD.EDITORIAL_SEQ || :OLD.TIPO_ASS_SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EDITORIAL_TIPO_ASS_ENVIO', :OLD.SEQ || :OLD.EDITORIAL_SEQ || :OLD.TIPO_ASS_SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EDITORIAL_TIPO_ASS_ENVIO' AND CHAVE || ''= :OLD.SEQ || :OLD.EDITORIAL_SEQ || :OLD.TIPO_ASS_SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EDITORIAL_TIPO_ASSINATURA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EDITORIAL_TIPO_ASSINATURA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EDITORIAL_TIPO_ASSINATURA' AND CHAVE || '' = :OLD.EDITORIAL_SEQ || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EDITORIAL_TIPO_ASSINATURA', :OLD.EDITORIAL_SEQ || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EDITORIAL_TIPO_ASSINATURA' AND CHAVE || ''= :OLD.EDITORIAL_SEQ || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_APURAÇÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_APURAÇÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_APURAÇÃO' AND CHAVE || '' = :OLD.APURACAO || :OLD.SÓCIO_MAT || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_APURAÇÃO', :OLD.APURACAO || :OLD.SÓCIO_MAT, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_APURAÇÃO' AND CHAVE || ''= :OLD.APURACAO || :OLD.SÓCIO_MAT || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_ATIV_PONTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_ATIV_PONTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_ATIV_PONTO' AND CHAVE || '' = :OLD.ATIV_COD || :OLD.PONTO_COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_ATIV_PONTO', :OLD.ATIV_COD || :OLD.PONTO_COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_ATIV_PONTO' AND CHAVE || ''= :OLD.ATIV_COD || :OLD.PONTO_COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_ATIVIDADE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_ATIVIDADE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_ATIVIDADE' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_ATIVIDADE', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_ATIVIDADE' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_FASE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_FASE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_FASE' AND CHAVE || '' = :OLD.FASE || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_FASE', :OLD.FASE, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_FASE' AND CHAVE || ''= :OLD.FASE || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_LOTE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_LOTE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_LOTE' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_LOTE', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_LOTE' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_LOTE_PONTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_LOTE_PONTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_LOTE_PONTO' AND CHAVE || '' = :OLD.LOTE_SEQ || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_LOTE_PONTO', :OLD.LOTE_SEQ || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_LOTE_PONTO' AND CHAVE || ''= :OLD.LOTE_SEQ || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_LOTE_PONTO_STATUS BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_LOTE_PONTO_STATUS FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_LOTE_PONTO_STATUS' AND CHAVE || '' = :OLD.STATUS || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_LOTE_PONTO_STATUS', :OLD.STATUS, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_LOTE_PONTO_STATUS' AND CHAVE || ''= :OLD.STATUS || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_LOTE_STATUS BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_LOTE_STATUS FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_LOTE_STATUS' AND CHAVE || '' = :OLD.STATUS || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_LOTE_STATUS', :OLD.STATUS, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_LOTE_STATUS' AND CHAVE || ''= :OLD.STATUS || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_PONTO_FASE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_PONTO_FASE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_PONTO_FASE' AND CHAVE || '' = :OLD.SOCIO_MAT || :OLD.ATIV_COD || :OLD.APURACAO || :OLD.PONTO_COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_PONTO_FASE', :OLD.SOCIO_MAT || :OLD.ATIV_COD || :OLD.APURACAO || :OLD.PONTO_COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_PONTO_FASE' AND CHAVE || ''= :OLD.SOCIO_MAT || :OLD.ATIV_COD || :OLD.APURACAO || :OLD.PONTO_COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_PONTO_SÓCIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_PONTO_SÓCIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_PONTO_SÓCIO' AND CHAVE || '' = :OLD.SÓCIO_MAT || :OLD.ATIV_COD || :OLD.PONTO_COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_PONTO_SÓCIO', :OLD.SÓCIO_MAT || :OLD.ATIV_COD || :OLD.PONTO_COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_PONTO_SÓCIO' AND CHAVE || ''= :OLD.SÓCIO_MAT || :OLD.ATIV_COD || :OLD.PONTO_COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_EMCD_TIPO_PONTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.EMCD_TIPO_PONTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'EMCD_TIPO_PONTO' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('EMCD_TIPO_PONTO', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'EMCD_TIPO_PONTO' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ESTADO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ESTADO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ESTADO' AND CHAVE || '' = :OLD.SIGLA || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ESTADO', :OLD.SIGLA, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ESTADO' AND CHAVE || ''= :OLD.SIGLA || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_FERIADO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.FERIADO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'FERIADO' AND CHAVE || '' = :OLD.DIA || :OLD.MES || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('FERIADO', :OLD.DIA || :OLD.MES, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'FERIADO' AND CHAVE || ''= :OLD.DIA || :OLD.MES || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_ADICIONAL_OBJ BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_ADICIONAL_OBJ FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_ADICIONAL_OBJ' AND CHAVE || '' = :OLD.SISTEMA || :OLD.TIPO || :OLD.OBJETO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_ADICIONAL_OBJ', :OLD.SISTEMA || :OLD.TIPO || :OLD.OBJETO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_ADICIONAL_OBJ' AND CHAVE || ''= :OLD.SISTEMA || :OLD.TIPO || :OLD.OBJETO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_CAMPO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_CAMPO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_CAMPO' AND CHAVE || '' = :OLD.SISTEMA || :OLD.TABELA || :OLD.CAMPO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_CAMPO', :OLD.SISTEMA || :OLD.TABELA || :OLD.CAMPO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_CAMPO' AND CHAVE || ''= :OLD.SISTEMA || :OLD.TABELA || :OLD.CAMPO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_CLASSE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_CLASSE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_CLASSE' AND CHAVE || '' = :OLD.SISTEMA || :OLD.CLASSE || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_CLASSE', :OLD.SISTEMA || :OLD.CLASSE, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_CLASSE' AND CHAVE || ''= :OLD.SISTEMA || :OLD.CLASSE || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_DIREITO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_DIREITO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_DIREITO' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_DIREITO', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_DIREITO' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_GRUPO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_GRUPO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_GRUPO' AND CHAVE || '' = :OLD.SISTEMA || :OLD.GRUPO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_GRUPO', :OLD.SISTEMA || :OLD.GRUPO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_GRUPO' AND CHAVE || ''= :OLD.SISTEMA || :OLD.GRUPO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_INDICE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_INDICE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_INDICE' AND CHAVE || '' = :OLD.SISTEMA || :OLD.TABELA || :OLD.NOME || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_INDICE', :OLD.SISTEMA || :OLD.TABELA || :OLD.NOME, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_INDICE' AND CHAVE || ''= :OLD.SISTEMA || :OLD.TABELA || :OLD.NOME || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_RELACIONAMENTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_RELACIONAMENTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_RELACIONAMENTO' AND CHAVE || '' = :OLD.SISTEMA || :OLD.NOME || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_RELACIONAMENTO', :OLD.SISTEMA || :OLD.NOME, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_RELACIONAMENTO' AND CHAVE || ''= :OLD.SISTEMA || :OLD.NOME || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_SISTEMA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_SISTEMA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_SISTEMA' AND CHAVE || '' = :OLD.NOME || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_SISTEMA', :OLD.NOME, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_SISTEMA' AND CHAVE || ''= :OLD.NOME || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_TABELA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_TABELA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_TABELA' AND CHAVE || '' = :OLD.SISTEMA || :OLD.TABELA || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_TABELA', :OLD.SISTEMA || :OLD.TABELA, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_TABELA' AND CHAVE || ''= :OLD.SISTEMA || :OLD.TABELA || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_TIPO_OBJ BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_TIPO_OBJ FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_TIPO_OBJ' AND CHAVE || '' = :OLD.TIPO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_TIPO_OBJ', :OLD.TIPO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_TIPO_OBJ' AND CHAVE || ''= :OLD.TIPO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_USUARIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_USUARIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_USUARIO' AND CHAVE || '' = :OLD.SISTEMA || :OLD.USUARIO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_USUARIO', :OLD.SISTEMA || :OLD.USUARIO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_USUARIO' AND CHAVE || ''= :OLD.SISTEMA || :OLD.USUARIO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_GER_VISAO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.GER_VISAO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'GER_VISAO' AND CHAVE || '' = :OLD.SISTEMA || :OLD.VISAO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('GER_VISAO', :OLD.SISTEMA || :OLD.VISAO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'GER_VISAO' AND CHAVE || ''= :OLD.SISTEMA || :OLD.VISAO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_HISTORICO_LICENCIADO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.HISTORICO_LICENCIADO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'HISTORICO_LICENCIADO' AND CHAVE || '' = :OLD.SOCIO_MAT || :OLD.DATA_INICIO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('HISTORICO_LICENCIADO', :OLD.SOCIO_MAT || :OLD.DATA_INICIO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'HISTORICO_LICENCIADO' AND CHAVE || ''= :OLD.SOCIO_MAT || :OLD.DATA_INICIO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_HISTORICO_PENALIZADO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.HISTORICO_PENALIZADO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'HISTORICO_PENALIZADO' AND CHAVE || '' = :OLD.SOCIO_MAT || :OLD.DATA_INICIO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('HISTORICO_PENALIZADO', :OLD.SOCIO_MAT || :OLD.DATA_INICIO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'HISTORICO_PENALIZADO' AND CHAVE || ''= :OLD.SOCIO_MAT || :OLD.DATA_INICIO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_HISTORICO_SOCIO_ELETRONICO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.HISTORICO_SOCIO_ELETRONICO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'HISTORICO_SOCIO_ELETRONICO' AND CHAVE || '' = :OLD.PROTOCOLO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('HISTORICO_SOCIO_ELETRONICO', :OLD.PROTOCOLO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'HISTORICO_SOCIO_ELETRONICO' AND CHAVE || ''= :OLD.PROTOCOLO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_HISTORICO_SOCIO_PUBL_END BEFORE UPDATE OR INSERT OR DELETE ON SBDB.HISTORICO_SOCIO_PUBL_END FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'HISTORICO_SOCIO_PUBL_END' AND CHAVE || '' = :OLD.SEQ || :OLD.SOCIO_MAT || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('HISTORICO_SOCIO_PUBL_END', :OLD.SEQ || :OLD.SOCIO_MAT, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'HISTORICO_SOCIO_PUBL_END' AND CHAVE || ''= :OLD.SEQ || :OLD.SOCIO_MAT || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_NEGOCIAÇÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.NEGOCIAÇÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'NEGOCIAÇÃO' AND CHAVE || '' = :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('NEGOCIAÇÃO', :OLD.SÓCIO_MAT || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'NEGOCIAÇÃO' AND CHAVE || ''= :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_OBRIGAÇÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.OBRIGAÇÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'OBRIGAÇÃO' AND CHAVE || '' = :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('OBRIGAÇÃO', :OLD.SÓCIO_MAT || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'OBRIGAÇÃO' AND CHAVE || ''= :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_OBRIGAÇÃO_STATUS BEFORE UPDATE OR INSERT OR DELETE ON SBDB.OBRIGAÇÃO_STATUS FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'OBRIGAÇÃO_STATUS' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('OBRIGAÇÃO_STATUS', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'OBRIGAÇÃO_STATUS' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_OBRIGAÇÃO_TIPO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.OBRIGAÇÃO_TIPO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'OBRIGAÇÃO_TIPO' AND CHAVE || '' = :OLD.TIPO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('OBRIGAÇÃO_TIPO', :OLD.TIPO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'OBRIGAÇÃO_TIPO' AND CHAVE || ''= :OLD.TIPO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ÓRGÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ÓRGÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ÓRGÃO' AND CHAVE || '' = :OLD.NOME || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ÓRGÃO', :OLD.NOME, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ÓRGÃO' AND CHAVE || ''= :OLD.NOME || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ÓRGÃO_GESTÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ÓRGÃO_GESTÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ÓRGÃO_GESTÃO' AND CHAVE || '' = :OLD.ÓRGÃO_NOME || :OLD.GESTÃO_INI || :OLD.ÓRGÃO_CARGO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ÓRGÃO_GESTÃO', :OLD.ÓRGÃO_NOME || :OLD.GESTÃO_INI || :OLD.ÓRGÃO_CARGO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ÓRGÃO_GESTÃO' AND CHAVE || ''= :OLD.ÓRGÃO_NOME || :OLD.GESTÃO_INI || :OLD.ÓRGÃO_CARGO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ÓRGÃO_MEMBRO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ÓRGÃO_MEMBRO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ÓRGÃO_MEMBRO' AND CHAVE || '' = :OLD.ÓRGÃO_NOME || :OLD.ÓRGÃO_CARGO || :OLD.ÓRGÃO_GESTÃO_INI || :OLD.SÓCIO_MAT || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ÓRGÃO_MEMBRO', :OLD.ÓRGÃO_NOME || :OLD.ÓRGÃO_CARGO || :OLD.ÓRGÃO_GESTÃO_INI || :OLD.SÓCIO_MAT, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ÓRGÃO_MEMBRO' AND CHAVE || ''= :OLD.ÓRGÃO_NOME || :OLD.ÓRGÃO_CARGO || :OLD.ÓRGÃO_GESTÃO_INI || :OLD.SÓCIO_MAT || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_ÓRGÃO_TIPO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.ÓRGÃO_TIPO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'ÓRGÃO_TIPO' AND CHAVE || '' = :OLD.TIPO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('ÓRGÃO_TIPO', :OLD.TIPO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'ÓRGÃO_TIPO' AND CHAVE || ''= :OLD.TIPO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_PAGAMENTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.PAGAMENTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'PAGAMENTO' AND CHAVE || '' = :OLD.SÓCIO_MAT || :OLD.OBRIG_SEQ || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('PAGAMENTO', :OLD.SÓCIO_MAT || :OLD.OBRIG_SEQ || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'PAGAMENTO' AND CHAVE || ''= :OLD.SÓCIO_MAT || :OLD.OBRIG_SEQ || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_PARAMETRO_FINANCEIRO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.PARAMETRO_FINANCEIRO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'PARAMETRO_FINANCEIRO' AND CHAVE || '' = :OLD.ANUIDADE || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('PARAMETRO_FINANCEIRO', :OLD.ANUIDADE, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'PARAMETRO_FINANCEIRO' AND CHAVE || ''= :OLD.ANUIDADE || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_PARCELAMENTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.PARCELAMENTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'PARCELAMENTO' AND CHAVE || '' = :OLD.NEG_SEQ || :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('PARCELAMENTO', :OLD.NEG_SEQ || :OLD.SÓCIO_MAT || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'PARCELAMENTO' AND CHAVE || ''= :OLD.NEG_SEQ || :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_PROD_FINA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.PROD_FINA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'PROD_FINA' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('PROD_FINA', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'PROD_FINA' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_PROD_USUARIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.PROD_USUARIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'PROD_USUARIO' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('PROD_USUARIO', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'PROD_USUARIO' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_PRODUTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.PRODUTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'PRODUTO' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('PRODUTO', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'PRODUTO' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_PROPOSTA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.PROPOSTA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'PROPOSTA' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('PROPOSTA', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'PROPOSTA' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_REGIÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.REGIÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'REGIÃO' AND CHAVE || '' = :OLD.NOME || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('REGIÃO', :OLD.NOME, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'REGIÃO' AND CHAVE || ''= :OLD.NOME || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_REGIONAL BEFORE UPDATE OR INSERT OR DELETE ON SBDB.REGIONAL FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'REGIONAL' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('REGIONAL', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'REGIONAL' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_REUNIAO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.REUNIAO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'REUNIAO' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('REUNIAO', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'REUNIAO' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_REUNIAO_SOCIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.REUNIAO_SOCIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'REUNIAO_SOCIO' AND CHAVE || '' = :OLD.REUNIAO_SEQ || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('REUNIAO_SOCIO', :OLD.REUNIAO_SEQ || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'REUNIAO_SOCIO' AND CHAVE || ''= :OLD.REUNIAO_SEQ || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SERV_CRED_CORPO_ADJ BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SERV_CRED_CORPO_ADJ FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SERV_CRED_CORPO_ADJ' AND CHAVE || '' = :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SERV_CRED_CORPO_ADJ', :OLD.SERV_CRED_COD || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SERV_CRED_CORPO_ADJ' AND CHAVE || ''= :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SERV_CRED_CORPO_CLINICO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SERV_CRED_CORPO_CLINICO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SERV_CRED_CORPO_CLINICO' AND CHAVE || '' = :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SERV_CRED_CORPO_CLINICO', :OLD.SERV_CRED_COD || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SERV_CRED_CORPO_CLINICO' AND CHAVE || ''= :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SERV_CRED_FOTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SERV_CRED_FOTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SERV_CRED_FOTO' AND CHAVE || '' = :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SERV_CRED_FOTO', :OLD.SERV_CRED_COD || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SERV_CRED_FOTO' AND CHAVE || ''= :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SERV_CRED_RENOVAÇÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SERV_CRED_RENOVAÇÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SERV_CRED_RENOVAÇÃO' AND CHAVE || '' = :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SERV_CRED_RENOVAÇÃO', :OLD.SERV_CRED_COD || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SERV_CRED_RENOVAÇÃO' AND CHAVE || ''= :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SERV_CRED_RESIDENTE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SERV_CRED_RESIDENTE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SERV_CRED_RESIDENTE' AND CHAVE || '' = :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SERV_CRED_RESIDENTE', :OLD.SERV_CRED_COD || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SERV_CRED_RESIDENTE' AND CHAVE || ''= :OLD.SERV_CRED_COD || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SERV_CRED_USUARIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SERV_CRED_USUARIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SERV_CRED_USUARIO' AND CHAVE || '' = :OLD.SERV_CRED_COD || :OLD.USUARIO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SERV_CRED_USUARIO', :OLD.SERV_CRED_COD || :OLD.USUARIO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SERV_CRED_USUARIO' AND CHAVE || ''= :OLD.SERV_CRED_COD || :OLD.USUARIO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SERVIÇO_CREDENCIADO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SERVIÇO_CREDENCIADO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SERVIÇO_CREDENCIADO' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SERVIÇO_CREDENCIADO', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SERVIÇO_CREDENCIADO' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_BANNER BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_BANNER FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_BANNER' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_BANNER', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_BANNER' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_CALENDARIO_DATA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_CALENDARIO_DATA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_CALENDARIO_DATA' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_CALENDARIO_DATA', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_CALENDARIO_DATA' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_CALENDARIO_TIPO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_CALENDARIO_TIPO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_CALENDARIO_TIPO' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_CALENDARIO_TIPO', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_CALENDARIO_TIPO' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_EMAIL_LISTA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_EMAIL_LISTA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_EMAIL_LISTA' AND CHAVE || '' = :OLD.COD_EMAIL || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_EMAIL_LISTA', :OLD.COD_EMAIL, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_EMAIL_LISTA' AND CHAVE || ''= :OLD.COD_EMAIL || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_EVENTO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_EVENTO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_EVENTO' AND CHAVE || '' = :OLD.ID_EVENTO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_EVENTO', :OLD.ID_EVENTO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_EVENTO' AND CHAVE || ''= :OLD.ID_EVENTO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_EVENTO_INSCRICAO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_EVENTO_INSCRICAO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_EVENTO_INSCRICAO' AND CHAVE || '' = :OLD.ID_EVENTO || :OLD.CPF || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_EVENTO_INSCRICAO', :OLD.ID_EVENTO || :OLD.CPF, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_EVENTO_INSCRICAO' AND CHAVE || ''= :OLD.ID_EVENTO || :OLD.CPF || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_JORNAL BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_JORNAL FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_JORNAL' AND CHAVE || '' = :OLD.ANO || :OLD.NUM_EDICAO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_JORNAL', :OLD.ANO || :OLD.NUM_EDICAO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_JORNAL' AND CHAVE || ''= :OLD.ANO || :OLD.NUM_EDICAO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_NOTICIA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_NOTICIA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_NOTICIA' AND CHAVE || '' = :OLD.ID || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_NOTICIA', :OLD.ID, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_NOTICIA' AND CHAVE || ''= :OLD.ID || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_QUEST BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_QUEST FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_QUEST' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_QUEST', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_QUEST' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_QUEST_MODELO_RESP BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_QUEST_MODELO_RESP FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_QUEST_MODELO_RESP' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_QUEST_MODELO_RESP', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_QUEST_MODELO_RESP' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_QUEST_QUESTAO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_QUEST_QUESTAO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_QUEST_QUESTAO' AND CHAVE || '' = :OLD.QUEST_SEQ || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_QUEST_QUESTAO', :OLD.QUEST_SEQ || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_QUEST_QUESTAO' AND CHAVE || ''= :OLD.QUEST_SEQ || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_QUEST_RESP BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_QUEST_RESP FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_QUEST_RESP' AND CHAVE || '' = :OLD.QUEST_SEQ || :OLD.QUESTAO_SEQ || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_QUEST_RESP', :OLD.QUEST_SEQ || :OLD.QUESTAO_SEQ || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_QUEST_RESP' AND CHAVE || ''= :OLD.QUEST_SEQ || :OLD.QUESTAO_SEQ || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_QUEST_RESP_ID BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_QUEST_RESP_ID FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_QUEST_RESP_ID' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_QUEST_RESP_ID', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_QUEST_RESP_ID' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_QUEST_TIPO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_QUEST_TIPO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_QUEST_TIPO' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_QUEST_TIPO', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_QUEST_TIPO' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_REVISTA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_REVISTA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_REVISTA' AND CHAVE || '' = :OLD.TITULO_EXTENSO_REVISTA || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_REVISTA', :OLD.TITULO_EXTENSO_REVISTA, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_REVISTA' AND CHAVE || ''= :OLD.TITULO_EXTENSO_REVISTA || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_REVISTA_POSICAO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SITE_REVISTA_POSICAO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SITE_REVISTA_POSICAO' AND CHAVE || '' = :OLD.COD_POS_REVISTA || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SITE_REVISTA_POSICAO', :OLD.COD_POS_REVISTA, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SITE_REVISTA_POSICAO' AND CHAVE || ''= :OLD.COD_POS_REVISTA || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SÓCIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SÓCIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SÓCIO' AND CHAVE || '' = :OLD.MAT || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SÓCIO', :OLD.MAT, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SÓCIO' AND CHAVE || ''= :OLD.MAT || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SÓCIO_CATEGORIA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SÓCIO_CATEGORIA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SÓCIO_CATEGORIA' AND CHAVE || '' = :OLD.SÓCIO_MAT || :OLD.CATEGORIA_COD || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SÓCIO_CATEGORIA', :OLD.SÓCIO_MAT || :OLD.CATEGORIA_COD || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SÓCIO_CATEGORIA' AND CHAVE || ''= :OLD.SÓCIO_MAT || :OLD.CATEGORIA_COD || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SÓCIO_CONVÊNIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SÓCIO_CONVÊNIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SÓCIO_CONVÊNIO' AND CHAVE || '' = :OLD.CONVÊNIO_COD || :OLD.SÓCIO_MAT || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SÓCIO_CONVÊNIO', :OLD.CONVÊNIO_COD || :OLD.SÓCIO_MAT, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SÓCIO_CONVÊNIO' AND CHAVE || ''= :OLD.CONVÊNIO_COD || :OLD.SÓCIO_MAT || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SÓCIO_ISENÇÃO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SÓCIO_ISENÇÃO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SÓCIO_ISENÇÃO' AND CHAVE || '' = :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SÓCIO_ISENÇÃO', :OLD.SÓCIO_MAT || :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SÓCIO_ISENÇÃO' AND CHAVE || ''= :OLD.SÓCIO_MAT || :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SÓCIO_SUB_ESPECIALIDADE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SÓCIO_SUB_ESPECIALIDADE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SÓCIO_SUB_ESPECIALIDADE' AND CHAVE || '' = :OLD.SUB_ESPECIAL_COD || :OLD.SÓCIO_MAT || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SÓCIO_SUB_ESPECIALIDADE', :OLD.SUB_ESPECIAL_COD || :OLD.SÓCIO_MAT, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SÓCIO_SUB_ESPECIALIDADE' AND CHAVE || ''= :OLD.SUB_ESPECIAL_COD || :OLD.SÓCIO_MAT || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SUB_ESPECIALIDADE BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SUB_ESPECIALIDADE FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SUB_ESPECIALIDADE' AND CHAVE || '' = :OLD.COD || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SUB_ESPECIALIDADE', :OLD.COD, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SUB_ESPECIALIDADE' AND CHAVE || ''= :OLD.COD || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SYS_CONFIG_GLOBAL BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SYS_CONFIG_GLOBAL FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SYS_CONFIG_GLOBAL' AND CHAVE || '' = :OLD.PARAM || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SYS_CONFIG_GLOBAL', :OLD.PARAM, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SYS_CONFIG_GLOBAL' AND CHAVE || ''= :OLD.PARAM || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SYS_CONFIG_USUARIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SYS_CONFIG_USUARIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SYS_CONFIG_USUARIO' AND CHAVE || '' = :OLD.USUARIO || :OLD.PARAM || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SYS_CONFIG_USUARIO', :OLD.USUARIO || :OLD.PARAM, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SYS_CONFIG_USUARIO' AND CHAVE || ''= :OLD.USUARIO || :OLD.PARAM || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SYS_LOCALID BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SYS_LOCALID FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SYS_LOCALID' AND CHAVE || '' = :OLD.NOME || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SYS_LOCALID', :OLD.NOME, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SYS_LOCALID' AND CHAVE || ''= :OLD.NOME || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_SYS_OCORRENCIA BEFORE UPDATE OR INSERT OR DELETE ON SBDB.SYS_OCORRENCIA FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'SYS_OCORRENCIA' AND CHAVE || '' = :OLD.SEQ || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('SYS_OCORRENCIA', :OLD.SEQ, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'SYS_OCORRENCIA' AND CHAVE || ''= :OLD.SEQ || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

CREATE OR REPLACE TRIGGER SBDB.BEF_USUARIO BEFORE UPDATE OR INSERT OR DELETE ON SBDB.USUARIO FOR EACH ROW
DECLARE
   TOT_DEL INTEGER;
   -- variáveis que preencherão o retorno das consultas
   CONN_USER VARCHAR2(100);
   CONN_IP VARCHAR2(100);
   CONN_MACHINE VARCHAR2(100);
BEGIN
   IF LPAD(USER,5) <> 'REPL_' THEN
      -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via internet
      select module, client_info, action into conn_machine, conn_ip, conn_user from v$session where audsid = userenv('sessionid') and rownum = 1;
      -- No caso da variável CONN_IP ser nula, significará que o acesso está sendo feito localmente
      If (conn_ip Is null) Then
         -- Consulta que retornará o HOST, IP, USUÁRIO que acessou via CIAD
         select sys_context('userenv','host'), sys_context('userenv','ip_address'), sys_context('userenv','session_user') into conn_user, conn_ip, conn_machine from dual where rownum = 1;
      end if;
      IF DELETING Then
         SELECT COUNT(*) INTO TOT_DEL FROM SBDB.SYS_DELETE WHERE TABELA = 'USUARIO' AND CHAVE || '' = :OLD.USUÁRIO || '';
         IF TOT_DEL = 0 THEN
            INSERT INTO SBDB.SYS_DELETE (TABELA,CHAVE,MOMENTO,USUARIO,LOCAL) VALUES ('USUARIO', :OLD.USUÁRIO, SYSDATE, USER, 'SBDB');
         ELSE
            UPDATE SBDB.SYS_DELETE SET MOMENTO = SYSDATE, USUARIO = USER, LOCAL = 'SBDB' WHERE TABELA = 'USUARIO' AND CHAVE || ''= :OLD.USUÁRIO || '';
         END IF;
      ELSE
         IF :NEW.SYS_STATUS = '+' THEN
            :NEW.SYS_STATUS := 'I';
         ELSIF :NEW.SYS_STATUS = '/' THEN
            :NEW.SYS_STATUS := 'A';
         ELSIF :NEW.SYS_STATUS = 'X' THEN
            :NEW.SYS_STATUS := '';
         ELSE
            IF INSERTING THEN
               :NEW.SYS_MOMENTO_CRIA := SYSDATE;
               :NEW.SYS_USUARIO_CRIA := CONN_USER;
               :NEW.SYS_LOCAL_CRIA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_MOMENTO_ATUALIZA := NULL;
               :NEW.SYS_USUARIO_ATUALIZA := NULL;
               :NEW.SYS_LOCAL_ATUALIZA := NULL;
               :NEW.SYS_STATUS := 'I';
            END IF;
            IF UPDATING THEN
               :NEW.SYS_MOMENTO_ATUALIZA := SYSDATE;
               :NEW.SYS_USUARIO_ATUALIZA := CONN_USER;
               :NEW.SYS_LOCAL_ATUALIZA := CONN_MACHINE || ' [' || CONN_IP || ']';
               :NEW.SYS_STATUS := 'A';
            END IF;
         END IF;
      END IF;
   END IF;
END;
/

/* **********************************************************************************
   CRIAÇÃO DE TRIGGERS PARA ALTERAÇÃO EM CASCATA
*/

CREATE OR REPLACE TRIGGER SBDB.AFT_ARQ_PAGAMENTO_CCD
AFTER UPDATE ON SBDB.ARQ_PAGAMENTO FOR EACH ROW
BEGIN

   --PAGAMENTO
   IF (:OLD.ARQ_SEQ <> :NEW.ARQ_SEQ) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.PAGAMENTO SET ARQ_SEQ = :NEW.ARQ_SEQ, ARQ_PAG = :NEW.SEQ WHERE ARQ_SEQ = :OLD.ARQ_SEQ AND ARQ_PAG = :OLD.SEQ AND NOT ARQ_SEQ IS NULL AND NOT ARQ_PAG IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_ARQ_RETORNO_CCD
AFTER UPDATE ON SBDB.ARQ_RETORNO FOR EACH ROW
BEGIN

   --ARQ_PAGAMENTO
   IF (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.ARQ_PAGAMENTO SET ARQ_SEQ = :NEW.SEQ WHERE ARQ_SEQ = :OLD.SEQ;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_BIBLIO_PEDIDO_CCD
AFTER UPDATE ON SBDB.BIBLIO_PEDIDO FOR EACH ROW
BEGIN

   --BIBLIO_LANCAMENTO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.BIBLIO_LANCAMENTO SET COD_PEDIDO = :NEW.COD WHERE COD_PEDIDO = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_BIBLIO_REQUIS_CCD
AFTER UPDATE ON SBDB.BIBLIO_REQUISITANTE FOR EACH ROW
BEGIN

   --BIBLIO_PEDIDO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.BIBLIO_PEDIDO SET COD_REQUISITANTE = :NEW.COD WHERE COD_REQUISITANTE = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_BIBLIO_SERVIC_CCD
AFTER UPDATE ON SBDB.BIBLIO_SERVICO FOR EACH ROW
BEGIN

   --BIBLIO_PEDIDO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.BIBLIO_PEDIDO SET COD_SERVICO = :NEW.COD WHERE COD_SERVICO = :OLD.COD;
   END IF;

   --BIBLIO_SERVICO_PRECO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.BIBLIO_SERVICO_PRECO SET COD_SERVICO = :NEW.COD WHERE COD_SERVICO = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_CARGO_CCD
AFTER UPDATE ON SBDB.CARGO FOR EACH ROW
BEGIN

   --ÓRGÃO_GESTÃO
   IF (:OLD.CARGO <> :NEW.CARGO) THEN
      UPDATE SBDB.ÓRGÃO_GESTÃO SET ÓRGÃO_CARGO = :NEW.CARGO WHERE ÓRGÃO_CARGO = :OLD.CARGO;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_CATEGORIA_CCD
AFTER UPDATE ON SBDB.CATEGORIA FOR EACH ROW
BEGIN

   --ANUIDADE_CATEGORIA
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.ANUIDADE_CATEGORIA SET CATEGORIA_COD = :NEW.COD WHERE CATEGORIA_COD = :OLD.COD;
   END IF;

   --SÓCIO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SÓCIO SET CATEGORIA_COD = :NEW.COD WHERE CATEGORIA_COD = :OLD.COD;
   END IF;

   --SÓCIO_CATEGORIA
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SÓCIO_CATEGORIA SET CATEGORIA_COD = :NEW.COD WHERE CATEGORIA_COD = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_CONVÊNIO_CCD
AFTER UPDATE ON SBDB.CONVÊNIO FOR EACH ROW
BEGIN

   --SÓCIO_CONVÊNIO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SÓCIO_CONVÊNIO SET CONVÊNIO_COD = :NEW.COD WHERE CONVÊNIO_COD = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_EDITORIAL_CCD
AFTER UPDATE ON SBDB.EDITORIAL FOR EACH ROW
BEGIN

   --EDITORIAL_TIPO_ASSINATURA
   IF (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.EDITORIAL_TIPO_ASSINATURA SET EDITORIAL_SEQ = :NEW.SEQ WHERE EDITORIAL_SEQ = :OLD.SEQ;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_EDITORIAL_TIP_CCD
AFTER UPDATE ON SBDB.EDITORIAL_TIPO_ASSINATURA FOR EACH ROW
BEGIN

   --EDITORIAL_TIPO_ASS_ENVIO
   IF (:OLD.EDITORIAL_SEQ <> :NEW.EDITORIAL_SEQ) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.EDITORIAL_TIPO_ASS_ENVIO SET EDITORIAL_SEQ = :NEW.EDITORIAL_SEQ, TIPO_ASS_SEQ = :NEW.SEQ WHERE EDITORIAL_SEQ = :OLD.EDITORIAL_SEQ AND TIPO_ASS_SEQ = :OLD.SEQ AND NOT EDITORIAL_SEQ IS NULL AND NOT TIPO_ASS_SEQ IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_EMCD_ATIV_PON_CCD
AFTER UPDATE ON SBDB.EMCD_ATIV_PONTO FOR EACH ROW
BEGIN

   --EMCD_PONTO_SÓCIO
   IF (:OLD.ATIV_COD <> :NEW.ATIV_COD) OR (:OLD.PONTO_COD <> :NEW.PONTO_COD) THEN
      UPDATE SBDB.EMCD_PONTO_SÓCIO SET ATIV_COD = :NEW.ATIV_COD, PONTO_COD = :NEW.PONTO_COD WHERE ATIV_COD = :OLD.ATIV_COD AND PONTO_COD = :OLD.PONTO_COD AND NOT ATIV_COD IS NULL AND NOT PONTO_COD IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_EMCD_ATIVIDAD_CCD
AFTER UPDATE ON SBDB.EMCD_ATIVIDADE FOR EACH ROW
BEGIN

   --EMCD_ATIV_PONTO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.EMCD_ATIV_PONTO SET ATIV_COD = :NEW.COD WHERE ATIV_COD = :OLD.COD;
   END IF;

   --EMCD_ATIVIDADE
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.EMCD_ATIVIDADE SET SUPERIOR = :NEW.COD WHERE SUPERIOR = :OLD.COD;
   END IF;

   --EMCD_PONTO_SÓCIO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.EMCD_PONTO_SÓCIO SET ATIV_COD = :NEW.COD WHERE ATIV_COD = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_EMCD_FASE_CCD
AFTER UPDATE ON SBDB.EMCD_FASE FOR EACH ROW
BEGIN

   --EMCD_APURAÇÃO
   IF (:OLD.FASE <> :NEW.FASE) THEN
      UPDATE SBDB.EMCD_APURAÇÃO SET APURACAO = :NEW.FASE WHERE APURACAO = :OLD.FASE;
   END IF;

   --EMCD_PONTO_FASE
   IF (:OLD.FASE <> :NEW.FASE) THEN
      UPDATE SBDB.EMCD_PONTO_FASE SET APURACAO = :NEW.FASE WHERE APURACAO = :OLD.FASE;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_EMCD_PONTO_SÓ_CCD
AFTER UPDATE ON SBDB.EMCD_PONTO_SÓCIO FOR EACH ROW
BEGIN

   --EMCD_PONTO_FASE
   IF (:OLD.SÓCIO_MAT <> :NEW.SÓCIO_MAT) OR (:OLD.ATIV_COD <> :NEW.ATIV_COD) OR (:OLD.PONTO_COD <> :NEW.PONTO_COD) THEN
      UPDATE SBDB.EMCD_PONTO_FASE SET SOCIO_MAT = :NEW.SÓCIO_MAT, ATIV_COD = :NEW.ATIV_COD, PONTO_COD = :NEW.PONTO_COD WHERE SOCIO_MAT = :OLD.SÓCIO_MAT AND ATIV_COD = :OLD.ATIV_COD AND PONTO_COD = :OLD.PONTO_COD AND NOT SOCIO_MAT IS NULL AND NOT ATIV_COD IS NULL AND NOT PONTO_COD IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_EMCD_TIPO_PON_CCD
AFTER UPDATE ON SBDB.EMCD_TIPO_PONTO FOR EACH ROW
BEGIN

   --EMCD_ATIV_PONTO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.EMCD_ATIV_PONTO SET PONTO_COD = :NEW.COD WHERE PONTO_COD = :OLD.COD;
   END IF;

   --EMCD_PONTO_SÓCIO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.EMCD_PONTO_SÓCIO SET PONTO_COD = :NEW.COD WHERE PONTO_COD = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_ESTADO_CCD
AFTER UPDATE ON SBDB.ESTADO FOR EACH ROW
BEGIN

   --REGIONAL
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.REGIONAL SET ESTADO = :NEW.SIGLA WHERE ESTADO = :OLD.SIGLA;
   END IF;

   --SÓCIO
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.SÓCIO SET CRM_ESTADO = :NEW.SIGLA WHERE CRM_ESTADO = :OLD.SIGLA;
   END IF;

   --SÓCIO
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.SÓCIO SET NATURALIDADE = :NEW.SIGLA WHERE NATURALIDADE = :OLD.SIGLA;
   END IF;

   --SÓCIO
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.SÓCIO SET ESTADO_RESIDENCIAL = :NEW.SIGLA WHERE ESTADO_RESIDENCIAL = :OLD.SIGLA;
   END IF;

   --SÓCIO
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.SÓCIO SET ESTADO_COMERCIAL_1 = :NEW.SIGLA WHERE ESTADO_COMERCIAL_1 = :OLD.SIGLA;
   END IF;

   --SÓCIO
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.SÓCIO SET ESTADO_COMERCIAL_2 = :NEW.SIGLA WHERE ESTADO_COMERCIAL_2 = :OLD.SIGLA;
   END IF;

   --SITE_EVENTO
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.SITE_EVENTO SET ESTADO = :NEW.SIGLA WHERE ESTADO = :OLD.SIGLA;
   END IF;

   --SERVIÇO_CREDENCIADO
   IF (:OLD.SIGLA <> :NEW.SIGLA) THEN
      UPDATE SBDB.SERVIÇO_CREDENCIADO SET ESTADO = :NEW.SIGLA WHERE ESTADO = :OLD.SIGLA;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_GER_CLASSE_CCD
AFTER UPDATE ON SBDB.GER_CLASSE FOR EACH ROW
BEGIN

   --GER_ADICIONAL_OBJ
   IF (:OLD.SISTEMA <> :NEW.SISTEMA) OR (:OLD.CLASSE <> :NEW.CLASSE) THEN
      UPDATE SBDB.GER_ADICIONAL_OBJ SET SISTEMA = :NEW.SISTEMA, CLASSE = :NEW.CLASSE WHERE SISTEMA = :OLD.SISTEMA AND CLASSE = :OLD.CLASSE AND NOT SISTEMA IS NULL AND NOT CLASSE IS NULL;
   END IF;

   --GER_TABELA
   IF (:OLD.SISTEMA <> :NEW.SISTEMA) OR (:OLD.CLASSE <> :NEW.CLASSE) THEN
      UPDATE SBDB.GER_TABELA SET SISTEMA = :NEW.SISTEMA, CLASSE = :NEW.CLASSE WHERE SISTEMA = :OLD.SISTEMA AND CLASSE = :OLD.CLASSE AND NOT SISTEMA IS NULL AND NOT CLASSE IS NULL;
   END IF;

   --GER_VISAO
   IF (:OLD.SISTEMA <> :NEW.SISTEMA) OR (:OLD.CLASSE <> :NEW.CLASSE) THEN
      UPDATE SBDB.GER_VISAO SET SISTEMA = :NEW.SISTEMA, CLASSE = :NEW.CLASSE WHERE SISTEMA = :OLD.SISTEMA AND CLASSE = :OLD.CLASSE AND NOT SISTEMA IS NULL AND NOT CLASSE IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_GER_SISTEMA_CCD
AFTER UPDATE ON SBDB.GER_SISTEMA FOR EACH ROW
BEGIN

   --GER_ADICIONAL_OBJ
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.GER_ADICIONAL_OBJ SET SISTEMA = :NEW.NOME WHERE SISTEMA = :OLD.NOME;
   END IF;

   --GER_CLASSE
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.GER_CLASSE SET SISTEMA = :NEW.NOME WHERE SISTEMA = :OLD.NOME;
   END IF;

   --GER_DIREITO
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.GER_DIREITO SET SISTEMA = :NEW.NOME WHERE SISTEMA = :OLD.NOME;
   END IF;

   --GER_GRUPO
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.GER_GRUPO SET SISTEMA = :NEW.NOME WHERE SISTEMA = :OLD.NOME;
   END IF;

   --GER_TABELA
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.GER_TABELA SET SISTEMA = :NEW.NOME WHERE SISTEMA = :OLD.NOME;
   END IF;

   --GER_VISAO
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.GER_VISAO SET SISTEMA = :NEW.NOME WHERE SISTEMA = :OLD.NOME;
   END IF;

   --GER_USUARIO
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.GER_USUARIO SET SISTEMA = :NEW.NOME WHERE SISTEMA = :OLD.NOME;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_GER_TABELA_CCD
AFTER UPDATE ON SBDB.GER_TABELA FOR EACH ROW
BEGIN

   --GER_CAMPO
   IF (:OLD.SISTEMA <> :NEW.SISTEMA) OR (:OLD.TABELA <> :NEW.TABELA) THEN
      UPDATE SBDB.GER_CAMPO SET SISTEMA = :NEW.SISTEMA, TABELA = :NEW.TABELA WHERE SISTEMA = :OLD.SISTEMA AND TABELA = :OLD.TABELA AND NOT SISTEMA IS NULL AND NOT TABELA IS NULL;
   END IF;

   --GER_INDICE
   IF (:OLD.SISTEMA <> :NEW.SISTEMA) OR (:OLD.TABELA <> :NEW.TABELA) THEN
      UPDATE SBDB.GER_INDICE SET SISTEMA = :NEW.SISTEMA, TABELA = :NEW.TABELA WHERE SISTEMA = :OLD.SISTEMA AND TABELA = :OLD.TABELA AND NOT SISTEMA IS NULL AND NOT TABELA IS NULL;
   END IF;

   --GER_RELACIONAMENTO
   IF (:OLD.SISTEMA <> :NEW.SISTEMA) OR (:OLD.TABELA <> :NEW.TABELA) THEN
      UPDATE SBDB.GER_RELACIONAMENTO SET SISTEMA = :NEW.SISTEMA, TABELA_N = :NEW.TABELA WHERE SISTEMA = :OLD.SISTEMA AND TABELA_N = :OLD.TABELA AND NOT SISTEMA IS NULL AND NOT TABELA_N IS NULL;
   END IF;

   --GER_RELACIONAMENTO
   IF (:OLD.SISTEMA <> :NEW.SISTEMA) OR (:OLD.TABELA <> :NEW.TABELA) THEN
      UPDATE SBDB.GER_RELACIONAMENTO SET SISTEMA = :NEW.SISTEMA, TABELA_1 = :NEW.TABELA WHERE SISTEMA = :OLD.SISTEMA AND TABELA_1 = :OLD.TABELA AND NOT SISTEMA IS NULL AND NOT TABELA_1 IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_GER_TIPO_OBJ_CCD
AFTER UPDATE ON SBDB.GER_TIPO_OBJ FOR EACH ROW
BEGIN

   --GER_ADICIONAL_OBJ
   IF (:OLD.TIPO <> :NEW.TIPO) THEN
      UPDATE SBDB.GER_ADICIONAL_OBJ SET TIPO = :NEW.TIPO WHERE TIPO = :OLD.TIPO;
   END IF;

   --GER_DIREITO
   IF (:OLD.TIPO <> :NEW.TIPO) THEN
      UPDATE SBDB.GER_DIREITO SET OBJETO_TIPO = :NEW.TIPO WHERE OBJETO_TIPO = :OLD.TIPO;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_NEGOCIAÇÃO_CCD
AFTER UPDATE ON SBDB.NEGOCIAÇÃO FOR EACH ROW
BEGIN

   --PARCELAMENTO
   IF (:OLD.SÓCIO_MAT <> :NEW.SÓCIO_MAT) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.PARCELAMENTO SET SÓCIO_MAT = :NEW.SÓCIO_MAT, NEG_SEQ = :NEW.SEQ WHERE SÓCIO_MAT = :OLD.SÓCIO_MAT AND NEG_SEQ = :OLD.SEQ AND NOT SÓCIO_MAT IS NULL AND NOT NEG_SEQ IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_OBRIGAÇÃO_CCD
AFTER UPDATE ON SBDB.OBRIGAÇÃO FOR EACH ROW
BEGIN

   --PAGAMENTO
   IF (:OLD.SÓCIO_MAT <> :NEW.SÓCIO_MAT) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.PAGAMENTO SET SÓCIO_MAT = :NEW.SÓCIO_MAT, OBRIG_SEQ = :NEW.SEQ WHERE SÓCIO_MAT = :OLD.SÓCIO_MAT AND OBRIG_SEQ = :OLD.SEQ AND NOT SÓCIO_MAT IS NULL AND NOT OBRIG_SEQ IS NULL;
   END IF;

   --PARCELAMENTO
   IF (:OLD.SÓCIO_MAT <> :NEW.SÓCIO_MAT) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.PARCELAMENTO SET SÓCIO_MAT = :NEW.SÓCIO_MAT, OBRIG_ANTERIOR = :NEW.SEQ WHERE SÓCIO_MAT = :OLD.SÓCIO_MAT AND OBRIG_ANTERIOR = :OLD.SEQ AND NOT SÓCIO_MAT IS NULL AND NOT OBRIG_ANTERIOR IS NULL;
   END IF;

   --PARCELAMENTO
   IF (:OLD.SÓCIO_MAT <> :NEW.SÓCIO_MAT) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.PARCELAMENTO SET SÓCIO_MAT = :NEW.SÓCIO_MAT, OBRIG_NOVA = :NEW.SEQ WHERE SÓCIO_MAT = :OLD.SÓCIO_MAT AND OBRIG_NOVA = :OLD.SEQ AND NOT SÓCIO_MAT IS NULL AND NOT OBRIG_NOVA IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_OBRIGAÇÃO_STA_CCD
AFTER UPDATE ON SBDB.OBRIGAÇÃO_STATUS FOR EACH ROW
BEGIN

   --OBRIGAÇÃO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.OBRIGAÇÃO SET OBRIG_STATUS_COD = :NEW.COD WHERE OBRIG_STATUS_COD = :OLD.COD;
   END IF;

   --SÓCIO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SÓCIO SET OBRIG_STATUS_COD = :NEW.COD WHERE OBRIG_STATUS_COD = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_OBRIGAÇÃO_TIP_CCD
AFTER UPDATE ON SBDB.OBRIGAÇÃO_TIPO FOR EACH ROW
BEGIN

   --OBRIGAÇÃO
   IF (:OLD.TIPO <> :NEW.TIPO) THEN
      UPDATE SBDB.OBRIGAÇÃO SET OBRIG_TIPO = :NEW.TIPO WHERE OBRIG_TIPO = :OLD.TIPO;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_ÓRGÃO_CCD
AFTER UPDATE ON SBDB.ÓRGÃO FOR EACH ROW
BEGIN

   --ÓRGÃO_GESTÃO
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.ÓRGÃO_GESTÃO SET ÓRGÃO_NOME = :NEW.NOME WHERE ÓRGÃO_NOME = :OLD.NOME;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_ÓRGÃO_GESTÃO_CCD
AFTER UPDATE ON SBDB.ÓRGÃO_GESTÃO FOR EACH ROW
BEGIN

   --ÓRGÃO_MEMBRO
   IF (:OLD.ÓRGÃO_NOME <> :NEW.ÓRGÃO_NOME) OR (:OLD.GESTÃO_INI <> :NEW.GESTÃO_INI) OR (:OLD.ÓRGÃO_CARGO <> :NEW.ÓRGÃO_CARGO) THEN
      UPDATE SBDB.ÓRGÃO_MEMBRO SET ÓRGÃO_NOME = :NEW.ÓRGÃO_NOME, ÓRGÃO_GESTÃO_INI = :NEW.GESTÃO_INI, ÓRGÃO_CARGO = :NEW.ÓRGÃO_CARGO WHERE ÓRGÃO_NOME = :OLD.ÓRGÃO_NOME AND ÓRGÃO_GESTÃO_INI = :OLD.GESTÃO_INI AND ÓRGÃO_CARGO = :OLD.ÓRGÃO_CARGO AND NOT ÓRGÃO_NOME IS NULL AND NOT ÓRGÃO_GESTÃO_INI IS NULL AND NOT ÓRGÃO_CARGO IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_ÓRGÃO_TIPO_CCD
AFTER UPDATE ON SBDB.ÓRGÃO_TIPO FOR EACH ROW
BEGIN

   --ÓRGÃO
   IF (:OLD.TIPO <> :NEW.TIPO) THEN
      UPDATE SBDB.ÓRGÃO SET ÓRGÃO_TIPO = :NEW.TIPO WHERE ÓRGÃO_TIPO = :OLD.TIPO;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_PROD_FINA_CCD
AFTER UPDATE ON SBDB.PROD_FINA FOR EACH ROW
BEGIN

   --BOLETO
   IF (:OLD.TITULO <> :NEW.TITULO) THEN
      UPDATE SBDB.BOLETO SET PRODUTO_NOME = :NEW.TITULO WHERE PRODUTO_NOME = :OLD.TITULO;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_PRODUTO_CCD
AFTER UPDATE ON SBDB.PRODUTO FOR EACH ROW
BEGIN

   --BOLETO
   IF (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.BOLETO SET PRODUTO_SEQ = :NEW.SEQ WHERE PRODUTO_SEQ = :OLD.SEQ;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_REGIÃO_CCD
AFTER UPDATE ON SBDB.REGIÃO FOR EACH ROW
BEGIN

   --ESTADO
   IF (:OLD.NOME <> :NEW.NOME) THEN
      UPDATE SBDB.ESTADO SET REGIAO = :NEW.NOME WHERE REGIAO = :OLD.NOME;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_REGIONAL_CCD
AFTER UPDATE ON SBDB.REGIONAL FOR EACH ROW
BEGIN

   --EMCD_ATIVIDADE
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.EMCD_ATIVIDADE SET REGIONAL_COD = :NEW.COD WHERE REGIONAL_COD = :OLD.COD;
   END IF;

   --ÓRGÃO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.ÓRGÃO SET REGIONAL_COD = :NEW.COD WHERE REGIONAL_COD = :OLD.COD;
   END IF;

   --SÓCIO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SÓCIO SET REGIONAL_COD = :NEW.COD WHERE REGIONAL_COD = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_REUNIAO_CCD
AFTER UPDATE ON SBDB.REUNIAO FOR EACH ROW
BEGIN

   --REUNIAO_SOCIO
   IF (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.REUNIAO_SOCIO SET REUNIAO_SEQ = :NEW.SEQ WHERE REUNIAO_SEQ = :OLD.SEQ;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SERVIÇO_CREDE_CCD
AFTER UPDATE ON SBDB.SERVIÇO_CREDENCIADO FOR EACH ROW
BEGIN

   --ADM_HIST_TED
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.ADM_HIST_TED SET SERV_CRED_COD = :NEW.COD WHERE SERV_CRED_COD = :OLD.COD;
   END IF;

   --SERV_CRED_CORPO_CLINICO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SERV_CRED_CORPO_CLINICO SET SERV_CRED_COD = :NEW.COD WHERE SERV_CRED_COD = :OLD.COD;
   END IF;

   --SERV_CRED_FOTO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SERV_CRED_FOTO SET SERV_CRED_COD = :NEW.COD WHERE SERV_CRED_COD = :OLD.COD;
   END IF;

   --SERV_CRED_RENOVAÇÃO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SERV_CRED_RENOVAÇÃO SET SERV_CRED_COD = :NEW.COD WHERE SERV_CRED_COD = :OLD.COD;
   END IF;

   --SERV_CRED_CORPO_ADJ
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SERV_CRED_CORPO_ADJ SET SERV_CRED_COD = :NEW.COD WHERE SERV_CRED_COD = :OLD.COD;
   END IF;

   --SERV_CRED_RESIDENTE
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SERV_CRED_RESIDENTE SET SERV_CRED_COD = :NEW.COD WHERE SERV_CRED_COD = :OLD.COD;
   END IF;

   --SERV_CRED_USUARIO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SERV_CRED_USUARIO SET SERV_CRED_COD = :NEW.COD WHERE SERV_CRED_COD = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SITE_CALENDAT_CCD
AFTER UPDATE ON SBDB.SITE_CALENDARIO_TIPO FOR EACH ROW
BEGIN

   --SITE_CALENDARIO_DATA
   IF (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.SITE_CALENDARIO_DATA SET TIPO = :NEW.SEQ WHERE TIPO = :OLD.SEQ;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SITE_QUEST_CCD
AFTER UPDATE ON SBDB.SITE_QUEST FOR EACH ROW
BEGIN

   --SITE_QUEST_QUESTAO
   IF (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.SITE_QUEST_QUESTAO SET QUEST_SEQ = :NEW.SEQ WHERE QUEST_SEQ = :OLD.SEQ;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SITE_QUEST_MO_CCD
AFTER UPDATE ON SBDB.SITE_QUEST_MODELO_RESP FOR EACH ROW
BEGIN

   --SITE_QUEST_QUESTAO
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SITE_QUEST_QUESTAO SET MODELO = :NEW.COD WHERE MODELO = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SITE_QUEST_QU_CCD
AFTER UPDATE ON SBDB.SITE_QUEST_QUESTAO FOR EACH ROW
BEGIN

   --SITE_QUEST_QUESTAO
   IF (:OLD.QUEST_SEQ <> :NEW.QUEST_SEQ) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.SITE_QUEST_QUESTAO SET QUEST_SEQ = :NEW.QUEST_SEQ, QUESTAO_SUP_SEQ = :NEW.SEQ WHERE QUEST_SEQ = :OLD.QUEST_SEQ AND QUESTAO_SUP_SEQ = :OLD.SEQ AND NOT QUEST_SEQ IS NULL AND NOT QUESTAO_SUP_SEQ IS NULL;
   END IF;

   --SITE_QUEST_RESP
   IF (:OLD.QUEST_SEQ <> :NEW.QUEST_SEQ) OR (:OLD.SEQ <> :NEW.SEQ) THEN
      UPDATE SBDB.SITE_QUEST_RESP SET QUEST_SEQ = :NEW.QUEST_SEQ, QUESTAO_SEQ = :NEW.SEQ WHERE QUEST_SEQ = :OLD.QUEST_SEQ AND QUESTAO_SEQ = :OLD.SEQ AND NOT QUEST_SEQ IS NULL AND NOT QUESTAO_SEQ IS NULL;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SITE_QUEST_TI_CCD
AFTER UPDATE ON SBDB.SITE_QUEST_TIPO FOR EACH ROW
BEGIN

   --SITE_QUEST
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SITE_QUEST SET TIPO = :NEW.COD WHERE TIPO = :OLD.COD;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SITE_REVISTA__CCD
AFTER UPDATE ON SBDB.SITE_REVISTA_POSICAO FOR EACH ROW
BEGIN

   --SITE_REVISTA
   IF (:OLD.COD_POS_REVISTA <> :NEW.COD_POS_REVISTA) THEN
      UPDATE SBDB.SITE_REVISTA SET COD_POS_REVISTA = :NEW.COD_POS_REVISTA WHERE COD_POS_REVISTA = :OLD.COD_POS_REVISTA;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SÓCIO_CCD
AFTER UPDATE ON SBDB.SÓCIO FOR EACH ROW
BEGIN

   --BOLETO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.BOLETO SET SACADO_SOCIO_MAT = :NEW.MAT WHERE SACADO_SOCIO_MAT = :OLD.MAT;
   END IF;

   --ADM_HIST_TED
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.ADM_HIST_TED SET SOCIO_MAT = :NEW.MAT WHERE SOCIO_MAT = :OLD.MAT;
   END IF;

   --BIBLIO_PEDIDO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.BIBLIO_PEDIDO SET MAT_ASSOCIADO = :NEW.MAT WHERE MAT_ASSOCIADO = :OLD.MAT;
   END IF;

   --EMCD_APURAÇÃO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.EMCD_APURAÇÃO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --EMCD_PONTO_SÓCIO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.EMCD_PONTO_SÓCIO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --HISTORICO_LICENCIADO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.HISTORICO_LICENCIADO SET SOCIO_MAT = :NEW.MAT WHERE SOCIO_MAT = :OLD.MAT;
   END IF;

   --HISTORICO_PENALIZADO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.HISTORICO_PENALIZADO SET SOCIO_MAT = :NEW.MAT WHERE SOCIO_MAT = :OLD.MAT;
   END IF;

   --HISTORICO_SOCIO_ELETRONICO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.HISTORICO_SOCIO_ELETRONICO SET SOCIO_MAT = :NEW.MAT WHERE SOCIO_MAT = :OLD.MAT;
   END IF;

   --HISTORICO_SOCIO_PUBL_END
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.HISTORICO_SOCIO_PUBL_END SET SOCIO_MAT = :NEW.MAT WHERE SOCIO_MAT = :OLD.MAT;
   END IF;

   --NEGOCIAÇÃO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.NEGOCIAÇÃO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --OBRIGAÇÃO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.OBRIGAÇÃO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --ÓRGÃO_MEMBRO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.ÓRGÃO_MEMBRO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --PARCELAMENTO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.PARCELAMENTO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --REUNIAO_SOCIO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.REUNIAO_SOCIO SET SOCIO_MAT = :NEW.MAT WHERE SOCIO_MAT = :OLD.MAT;
   END IF;

   --SERVIÇO_CREDENCIADO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.SERVIÇO_CREDENCIADO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --SÓCIO_CATEGORIA
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.SÓCIO_CATEGORIA SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --SÓCIO_CONVÊNIO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.SÓCIO_CONVÊNIO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --SÓCIO_ISENÇÃO
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.SÓCIO_ISENÇÃO SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

   --SÓCIO_SUB_ESPECIALIDADE
   IF (:OLD.MAT <> :NEW.MAT) THEN
      UPDATE SBDB.SÓCIO_SUB_ESPECIALIDADE SET SÓCIO_MAT = :NEW.MAT WHERE SÓCIO_MAT = :OLD.MAT;
   END IF;

END;
/

CREATE OR REPLACE TRIGGER SBDB.AFT_SUB_ESPECIALI_CCD
AFTER UPDATE ON SBDB.SUB_ESPECIALIDADE FOR EACH ROW
BEGIN

   --SÓCIO_SUB_ESPECIALIDADE
   IF (:OLD.COD <> :NEW.COD) THEN
      UPDATE SBDB.SÓCIO_SUB_ESPECIALIDADE SET SUB_ESPECIAL_COD = :NEW.COD WHERE SUB_ESPECIAL_COD = :OLD.COD;
   END IF;

END;
/

/* **********************************************************************************
   OUTROS CÓDIGOS E VISÕES EM GERAL
*/

-- OBJETO 10 | PACKAGE | DBMS_ICRAFT
REM --------------------------------------------------------------------------------
REM
REM INTERCRAFT SOLUTIONS INFORMÁTICA LTDA
REM 08 DE AGOSTO DE 2007 - BASE COMUM PARA SOLUÇÕES PLSQL ICRAFT
REM BIBLIOTECA PADRÃO PARA SITE ASPNET E APL VB - IMPLEMENTAÇÃO ORACLE
REM
REM
REM OBSERVAÇÕES:::
REM   - xxobservaçãoxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
REM
REM ALTERAÇÕES:::
REM   - dd/mmm/yyyy xtécnico xxmotivotodocomletrasminúsculasxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
REM   - 08/ago/2011 lucianol implementação de rotina para carga de arquivos a partir dos diretórios de repositório
REM
REM IDÉIAS/NECESSIDADES:::
REM   - xtecnico xxcomentárioxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
REM
REM --------------------------------------------------------------------------------
REM


DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'DICT_OBJ';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE DICT_OBJ FORCE';
    DBMS_OUTPUT.PUT_LINE('TYPE DICT_OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE DICT_OBJ  AS  OBJECT  ( CHAVE  VARCHAR2 (70), CONTEUDO VARCHAR2 (4000) )
/


DECLARE
  QTD NUMBER;
BEGIN
SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'DICT_TBL';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE DICT_TBL FORCE';
    DBMS_OUTPUT.PUT_LINE('OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE DICT_TBL AS  TABLE OF DICT_OBJ;
/


DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'MANUT_OBJ';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE MANUT_OBJ FORCE';
    DBMS_OUTPUT.PUT_LINE('OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE MANUT_OBJ AS OBJECT (
      SEQ NUMBER,
      TABELA VARCHAR2(100),
      MANUT_MOMENTO_STR VARCHAR2(50),
      CRIA_MOMENTO DATE,
      ATUALIZA_MOMENTO DATE,
      MANUT_MOMENTO DATE,
      MANUT_USUARIO VARCHAR2(100),
      MANUT_LOCAL VARCHAR2(100),
      MAP MEMBER FUNCTION GET_IDNO RETURN NUMBER
)
/

CREATE OR REPLACE TYPE BODY MANUT_OBJ AS
  MAP MEMBER FUNCTION GET_IDNO RETURN NUMBER IS
  BEGIN
    RETURN SEQ;
  END;
END;
/

DECLARE
  QTD NUMBER;
BEGIN
SELECT COUNT(*) INTO QTD FROM ALL_OBJECTS WHERE OBJECT_NAME = 'MANUT_TBL';
  IF QTD>0 THEN
    EXECUTE IMMEDIATE 'DROP TYPE MANUT_TBL FORCE';
    DBMS_OUTPUT.PUT_LINE('OBJ EXCLUÍDO');
  END IF;
END;
/

CREATE OR REPLACE TYPE MANUT_TBL AS TABLE OF MANUT_OBJ;
/

-- DICT, MANTIDA POR COMPATIBILIDADE. UTILIZAR DICT QUE ESTÁ EM DBMS_ICRAFT.
CREATE OR REPLACE FUNCTION DICT
  (
    LISTA VARCHAR2,
    DELIM VARCHAR2 := ';',
    ATRIB VARCHAR2 := ':' )
  RETURN DICT_TBL PIPELINED
                  IS
  POS PLS_INTEGER := 1;
  PROX PLS_INTEGER;
  TERMO VARCHAR2(4000);
  PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
  WHILE POS<=LENGTH(LISTA)
  LOOP
    PROX    := INSTR(LISTA, DELIM, POS);
    IF PROX <> 0 THEN
      TERMO := SUBSTR(LISTA, POS, PROX-POS);
      POS   := PROX                   +1;
    ELSE
      TERMO := SUBSTR(LISTA, POS);
      POS   := LENGTH(LISTA)+1;
    END IF;
    PROX        := INSTR(TERMO, ATRIB);
    IF PROX     <>0 THEN
      PAR.CHAVE := SUBSTR(TERMO, 1, PROX-1);
    ELSE
      PAR.CHAVE := '';
    END IF;
    PAR.CONTEUDO := SUBSTR(TERMO, PROX+1);
    PIPE ROW(PAR);
  END LOOP;
END DICT;
/




create or replace PACKAGE DBMS_ICRAFT IS
FUNCTION MANUT_ULTIMO_MOMENTO(ESQUEMA_PRINC VARCHAR2) RETURN DATE;
FUNCTION MANUT_ULTIMAS(ESQUEMA_PRINC IN VARCHAR2, QTD IN INTEGER) RETURN MANUT_TBL PIPELINED;
FUNCTION DICT (LISTA VARCHAR2, DELIM VARCHAR2 := ';',  ATRIB VARCHAR2 := ':' ) RETURN DICT_TBL PIPELINED;
FUNCTION DATEDIFF(FORMATO VARCHAR2,INICIO DATE, FINAL DATE, CASASDECIMAIS INTEGER DEFAULT 0) RETURN FLOAT;
FUNCTION OBTEM_CONFIG_USUARIO_PADRAO(ESQUEMA VARCHAR2 ,PARAM VARCHAR2 ,USUARIO VARCHAR2 ,USUARIO_PADRAO VARCHAR2 ) RETURN DICT_TBL PIPELINED;
FUNCTION OBJ_ID_MAX RETURN INTEGER;
FUNCTION SERVIDOR_IP RETURN VARCHAR2;
FUNCTION SERVIDOR_NOME RETURN VARCHAR2;
PROCEDURE DEL_OBJ_APARTIR_ID(ID NUMBER);
FUNCTION CARREGA_ARQUIVO(CAMINHO VARCHAR2) RETURN BLOB;
PROCEDURE INDEX_REBUILD(ESQUEMA VARCHAR2);
FUNCTION QTDOBJ(TIPO VARCHAR2 DEFAULT '', ESQUEMA VARCHAR2 DEFAULT '', OBJ VARCHAR2 DEFAULT '') RETURN NUMBER;
PROCEDURE ALL_OBJ_COMPILE(ESQUEMA VARCHAR2);
PROCEDURE EXEC_SQL(SQL_CAMPO_COMA VARCHAR2);
END;
/

create or replace PACKAGE BODY DBMS_ICRAFT AS
FUNCTION MANUT_ULTIMO_MOMENTO (ESQUEMA_PRINC VARCHAR2) RETURN DATE
  -- EXEMPLO PARA TESTES
  -- SELECT TO_CHAR(DBMS_ICRAFT.MANUT_ULTIMO_MOMENTO('SBDB'),'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
AS
  DT DATE;
  DT_ACUM DATE := NULL;
  COMANDO VARCHAR2(4000);
BEGIN
  FOR CUR IN
  (SELECT OWNER,
    TABLE_NAME
     FROM ALL_TABLES
    WHERE OWNER IN
    (SELECT USERNAME
       FROM ALL_USERS
      WHERE USER_ID >=
      (SELECT USER_ID FROM ALL_USERS WHERE USERNAME=ESQUEMA_PRINC
      )
    )
  )
  LOOP
    BEGIN
      IF INSTR(';SYS_CONFIG_GLOBAL;SYS_CONFIG_USUARIO;SYS_LOCALID;SYS_OCORRENCIA;',';' || CUR.TABLE_NAME || ';')=0 THEN
        IF CUR.TABLE_NAME                                                                                       = 
'SYS_DELETE' THEN
          COMANDO                                                                                              := 
'SELECT MAX(MOMENTO) FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME ;
        ELSE
          COMANDO := 'SELECT GREATEST(NVL(MAXC,MAXA),NVL(MAXA,MAXC)) FROM (SELECT MAX(SYS_MOMENTO_CRIA) AS MAXC, MAX
(SYS_MOMENTO_ATUALIZA) AS MAXA FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ')';
        END IF;
        EXECUTE IMMEDIATE COMANDO INTO DT;
         SELECT GREATEST(NVL(DT,DT_ACUM), NVL(DT_ACUM,DT)) INTO DT_ACUM FROM DUAL;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      NULL;
    END;
  END LOOP;
  RETURN DT_ACUM;
END;
FUNCTION DICT
  (
    LISTA VARCHAR2,
    DELIM VARCHAR2 := ';',
    ATRIB VARCHAR2 := ':' )
  RETURN DICT_TBL PIPELINED
                  IS
  POS PLS_INTEGER := 1;
  PROX PLS_INTEGER;
  TERMO VARCHAR2(4000);
  PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
  WHILE POS<=LENGTH(LISTA)
  LOOP
    PROX    := INSTR(LISTA, DELIM, POS);
    IF PROX <> 0 THEN
      TERMO := SUBSTR(LISTA, POS, PROX-POS);
      POS   := PROX                   +1;
    ELSE
      TERMO := SUBSTR(LISTA, POS);
      POS   := LENGTH(LISTA)+1;
    END IF;
    PROX        := INSTR(TERMO, ATRIB);
    IF PROX     <>0 THEN
      PAR.CHAVE := SUBSTR(TERMO, 1, PROX-1);
    ELSE
      PAR.CHAVE := '';
    END IF;
    PAR.CONTEUDO := SUBSTR(TERMO, PROX+1);
    PIPE ROW(PAR);
  END LOOP;
END DICT;
FUNCTION MANUT_ULTIMAS(ESQUEMA_PRINC IN VARCHAR2, QTD IN INTEGER) RETURN MANUT_TBL PIPELINED AS  
M_REG MANUT_OBJ := MANUT_OBJ(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
  -- EXEMPLO PARA TESTES
  -- SELECT * FROM TABLE(DBMS_ICRAFT.MANUT_ULTIMAS('SBDB','10'))
  --
  -- ESTRUTURA PARA GUARDAR MANUTENÇÕES
  -- MANUT_MOMENTO_STR É A CHAVE E PERMITIRÁ ORGANIZAR A TAB POR MOMENTO DE MANUTENÇÃO
  --
  TYPE MANUT_TBL_ORD is table of MANUT_OBJ index by VARCHAR2(200);
  MANUT MANUT_TBL := NEW MANUT_TBL();
  --
  -- MANUT2 SERVE PARA JUNTAR AS CONSULTAS. DEPOIS DE JUNTAR VOU PEGAR SOMENTE OS N ÚLTIMOS
  --
  MANUT2 MANUT_TBL;
  --
  -- MANUTS SERVE PARA ORDENAR A JUNÇÃO DE PESQUISAS
  --
  MANUTS MANUT_TBL_ORD;
  --
  --
  --
  COMANDO VARCHAR2(4000);
  CONST1_INICIO VARCHAR2(1000);
  CONST1_FIM VARCHAR2(1000);
  ORD INTEGER;
  CHAVE VARCHAR2(50);
  --
  --
  TYPE C_T IS REF CURSOR;
  C C_T;
  REG_SEQ INTEGER;
  REG_BUSCA VARCHAR2(50);
  --
BEGIN
  --
  -- LOOPING NAS TABELAS OBTIDAS A PARTIR DO ESQUEMA PRINCIPAL
  --
  FOR CUR    IN
  (SELECT OWNER,
    TABLE_NAME
     FROM ALL_TABLES
    WHERE OWNER IN
    (SELECT USERNAME
       FROM ALL_USERS
      WHERE USER_ID >=
      (SELECT USER_ID FROM ALL_USERS WHERE USERNAME=ESQUEMA_PRINC
      )
    )
  )
  LOOP
    IF INSTR(';SYS_DELETE;SYS_CONFIG_GLOBAL;SYS_CONFIG_USUARIO;SYS_LOCALID;SYS_OCORRENCIA;',';' || CUR.TABLE_NAME || 
';')=0 THEN
    --
    --
    --
    -- OBTENDO REGISTROS MAIS ATUAIS
    --
    COMANDO := 'SELECT SEQ, ''' || CUR.TABLE_NAME || ''' TABELA, TO_CHAR(MANUT_MOMENTO_STR,''YYYY-MM-DD HH24:MI:SS'') 
MANUT_MOMENTO_STR, CRIA_MOMENTO, ATUALIZA_MOMENTO, MANUT_MOMENTO, MANUT_USUARIO, MANUT_LOCAL
    FROM
    (SELECT ROWNUM SEQ,
    SYS_MOMENTO_CRIA CRIA_MOMENTO,
    SYS_MOMENTO_ATUALIZA ATUALIZA_MOMENTO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END AS MANUT_MOMENTO_STR,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END AS MANUT_MOMENTO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_USUARIO_ATUALIZA
      ELSE SYS_USUARIO_CRIA
    END AS MANUT_USUARIO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_LOCAL_ATUALIZA
      ELSE SYS_LOCAL_CRIA
    END AS MANUT_LOCAL FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ' ORDER BY
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END DESC
    )
    WHERE SEQ <= ' || QTD;
    --
    --
    --
    --
    -- JOGA PARA MANUT.... E JUNTA COM MANUT2
    --
    BEGIN
      --
      MANUT.DELETE;
      OPEN C FOR COMANDO;
      --
      LOOP
        --
        --
        BEGIN
          FETCH c INTO M_REG.SEQ, M_REG.TABELA, M_REG.MANUT_MOMENTO_STR, M_REG.CRIA_MOMENTO, M_REG.ATUALIZA_MOMENTO, 
M_REG.MANUT_MOMENTO, M_REG.MANUT_USUARIO, M_REG.MANUT_LOCAL;
          EXIT WHEN C%NOTFOUND;
        EXCEPTION
          WHEN OTHERS THEN
                 -- DBMS_OUTPUT.PUT_LINE('FETCH ' || CUR.TABLE_NAME || '>>' || SQLERRM);
           NULL;
        END;
        MANUT.EXTEND;
        MANUT(MANUT.COUNT) := M_REG;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
   -- DBMS_OUTPUT.PUT_LINE('OPEN ' || CUR.TABLE_NAME || '>>' || SQLERRM);
           NULL;
    END;
    --
    --
    --
    IF MANUT2 IS NULL THEN
      MANUT2 := MANUT;
    ELSE
      MANUT2 := MANUT MULTISET UNION MANUT2;
    END IF;
    --
    --
    -- ORDENA ITENS PEGANDO SÓ A QUANTIDADE MÁXIMA SOLICITADA
    --
    IF MANUT2.COUNT > 0 THEN
	MANUTS.DELETE;
        -- DBMS_OUTPUT.PUT_LINE('TABELA ' || CUR.TABLE_NAME || ' ... ANTES');
        FOR Z IN MANUT2.FIRST .. MANUT2.LAST LOOP
          IF NOT MANUT2(Z).MANUT_MOMENTO_STR IS NULL THEN
            -- DBMS_OUTPUT.PUT_LINE(MANUT2(Z).MANUT_MOMENTO_STR);
            REG_SEQ := 1;
	    LOOP
              REG_BUSCA := MANUT2(Z).MANUT_MOMENTO_STR || '-' || TO_CHAR(REG_SEQ,'0000');
              EXIT WHEN NOT MANUTS.EXISTS(REG_BUSCA);
              REG_SEQ := REG_SEQ + 1;
            END LOOP;
            MANUTS(REG_BUSCA) := MANUT2(Z);
          END IF;
        END LOOP;
	MANUT2.DELETE;
        ORD := 1;
        CHAVE := MANUTS.LAST;
        -- DBMS_OUTPUT.PUT_LINE('TABELA ' || CUR.TABLE_NAME || ' ... DEPOIS');
        LOOP
          EXIT WHEN ORD > QTD OR CHAVE IS NULL;
          -- DBMS_OUTPUT.PUT_LINE(CHAVE);
          MANUT2.EXTEND;
          MANUT2(ORD) := MANUTS(CHAVE);
          ORD := ORD + 1;
          CHAVE := MANUTS.PRIOR(CHAVE);
        END LOOP;
        -- DBMS_OUTPUT.PUT_LINE('..........');
    END IF;
    --
    --
    --
    END IF;
  END LOOP;
  --
  --
  --
  -- DANDO SAÍDA NO RESULTADO
  --
  CHAVE := MANUT2.FIRST;
  LOOP
    EXIT WHEN CHAVE IS NULL;
    PIPE ROW (MANUT2(CHAVE));
    CHAVE := MANUT2.NEXT(CHAVE);
  END LOOP;
  --
  --
  --
  RETURN;
END MANUT_ULTIMAS;
FUNCTION DATEDIFF(FORMATO VARCHAR2,INICIO DATE, FINAL DATE, CASASDECIMAIS INTEGER DEFAULT 0) RETURN FLOAT AS
  RET FLOAT;
BEGIN
  IF FORMATO = 'ANO' THEN
    RET := MONTHS_BETWEEN(FINAL, INICIO)/12;
  ELSIF FORMATO = 'MES' THEN
    RET := MONTHS_BETWEEN(FINAL, INICIO);
  ELSIF FORMATO = 'DIA' THEN
    RET := FINAL - INICIO;
  ELSIF FORMATO = 'HORA' THEN
    RET := (FINAL - INICIO)*24;
  ELSIF FORMATO = 'MIN' THEN
    RET := (FINAL - INICIO)*24*60;
  ELSIF FORMATO = 'SEG' THEN
    RET := (FINAL - INICIO)*24*60*60;
  END IF;
  RET := TRUNC(RET,CASASDECIMAIS);
  RETURN RET;
END;
FUNCTION OBTEM_CONFIG_USUARIO_PADRAO(ESQUEMA VARCHAR2 ,PARAM VARCHAR2 ,USUARIO VARCHAR2 ,USUARIO_PADRAO VARCHAR2 ) 
RETURN DICT_TBL PIPELINED IS
PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
            BEGIN
                        SELECT CONFIG INTO PAR.CONTEUDO FROM SYS_CONFIG_USUARIO S WHERE S.USUARIO=USUARIO AND 
S.PARAM=PARAM;
                        PAR.CHAVE := USUARIO;
            EXCEPTION WHEN OTHERS THEN
                        BEGIN                         
                                   SELECT CONFIG INTO PAR.CONTEUDO FROM SYS_CONFIG_USUARIO S WHERE 
S.USUARIO=USUARIO_PADRAO AND S.PARAM=PARAM;
                                   PAR.CHAVE := USUARIO_PADRAO; 
                        EXCEPTION WHEN OTHERS THEN
                                   PAR.CHAVE := USUARIO;
                                   PAR.CONTEUDO := '';
                        END;
            END;
            PIPE ROW(PAR);        
END;

FUNCTION OBJ_ID_MAX RETURN INTEGER AS
  M  NUMBER;
BEGIN
  SELECT MAX(OBJECT_ID) INTO M FROM ALL_OBJECTS;
  RETURN M;
END;


FUNCTION SERVIDOR_IP RETURN VARCHAR2 AS
  IP VARCHAR2(30);
BEGIN
  SELECT UTL_INADDR.GET_HOST_ADDRESS INTO IP FROM DUAL;
  RETURN IP;
END;


FUNCTION SERVIDOR_NOME RETURN VARCHAR2 AS
  NOME VARCHAR2(30);
BEGIN
  SELECT UTL_INADDR.GET_HOST_NAME INTO NOME FROM DUAL;
  RETURN NOME;
END;


PROCEDURE DEL_OBJ_APARTIR_ID(ID NUMBER) AS
BEGIN
  EXEC_SQL('SELECT ''DROP '' || OBJECT_TYPE || '' '' || OWNER || ''.'' || OBJECT_NAME AS COMA FROM (SELECT OWNER, OBJECT_NAME, OBJECT_TYPE FROM ALL_OBJECTS WHERE OBJECT_ID >' || ID ||')');
END;


FUNCTION CARREGA_ARQUIVO(CAMINHO VARCHAR2) RETURN BLOB IS
f_lob BFILE;
b_lob BLOB;
caminho2 varchar2(1000);
BEGIN
dbms_lob.createtemporary(b_lob,true);
caminho2 := replace(caminho, '\', '/');
caminho2 := replace(caminho2,'~/', '');
f_lob := BFILENAME('REPOSITORIO_RAIZ', caminho2);
dbms_lob.fileopen(f_lob,dbms_lob.file_readonly);
dbms_lob.loadfromfile(b_lob,f_lob,dbms_lob.getlength(f_lob) );
dbms_lob.fileclose(f_lob);
RETURN b_lob;
END;


PROCEDURE INDEX_REBUILD(ESQUEMA VARCHAR2) AS
BEGIN
EXEC_SQL('SELECT ''ALTER INDEX '' || OWNER || ''.'' || INDEX_NAME || '' REBUILD;'' FROM ALL_INDEXES WHERE OWNER ='''  || ESQUEMA ||''' ');
END;


FUNCTION QTDOBJ(TIPO VARCHAR2 DEFAULT '', ESQUEMA VARCHAR2 DEFAULT '', OBJ VARCHAR2 DEFAULT '') RETURN NUMBER AS
QTD NUMBER;
BEGIN
    SELECT COUNT(OBJECT_NAME) INTO QTD FROM ALL_OBJECTS WHERE DECODE(TIPO,'',OBJECT_TYPE,TIPO)=OBJECT_TYPE AND DECODE
(ESQUEMA,'',OWNER,ESQUEMA)=OWNER AND DECODE(OBJ,'',OBJECT_NAME,OBJ)=OBJECT_NAME;
    RETURN QTD;
END;


PROCEDURE ALL_OBJ_COMPILE(ESQUEMA VARCHAR2) AS
BEGIN
EXEC_SQL('SELECT ''ALTER '' || OBJECT_TYPE || '' '' || OWNER || ''.'' || OBJECT_NAME || '' COMPILE;'' FROM ALL_OBJECTS WHERE OWNER =''' || ESQUEMA || ''' AND OBJECT_TYPE IN (''TRIGGER'', ''TYPE'', ''FUNCTION'', ''PROCEDURE'', ''PACKAGE'')');
FOR CUR IN (select * from ALL_OBJECTS where  STATUS = 'INVALID') LOOP
    DBMS_OUTPUT.PUT_LINE(CUR.OBJECT_TYPE || ' ' || CUR.OWNER || '.' || CUR.OBJECT_NAME);
END LOOP;
END;


PROCEDURE EXEC_SQL(SQL_CAMPO_COMA VARCHAR2) IS
   CUR INTEGER;
   COR INTEGER;
   COMA VARCHAR2(4000);
BEGIN
   CUR := DBMS_SQL.OPEN_CURSOR;
   DBMS_SQL.PARSE(CUR,SQL_CAMPO_COMA, DBMS_SQL.NATIVE);
   DBMS_SQL.DEFINE_COLUMN(CUR,1,COMA,4000);
   COR := DBMS_SQL.EXECUTE(CUR);
   LOOP
   EXIT WHEN DBMS_SQL.FETCH_ROWS (CUR) = 0;
      DBMS_SQL.COLUMN_VALUE (CUR, 1, COMA);
      DBMS_OUTPUT.PUT_LINE(CHR(13) || CHR(10));
      DBMS_OUTPUT.PUT_LINE(COMA);
      BEGIN
         EXECUTE IMMEDIATE COMA;
         DBMS_OUTPUT.PUT_LINE('=> OK');
      EXCEPTION
       WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE('=> ERR:' || SQLERRM);
      END;
   END LOOP;
      DBMS_SQL.CLOSE_CURSOR(CUR);
END;


END DBMS_ICRAFT;
/

-- OBJETO 20 | FUNCTION | LSQLTOHTML
create or replace FUNCTION      LSQLTOHTML
    (
      SQLTEXT IN VARCHAR2,
      QTDCOLS NUMBER,
      NENHUM VARCHAR2 DEFAULT 'NENHUMA LINHA')
    RETURN VARCHAR2
  AS
    TEXTO CLOB;
  TYPE CONSULTA_REF
IS
  REF
  CURSOR;
    CONSULTA CONSULTA_REF;
    C01 VARCHAR2(400);
    C02 VARCHAR2(400);
    C03 VARCHAR2(400);
    C04 VARCHAR2(400);
    C05 VARCHAR2(400);
    C06 VARCHAR2(400);
    C07 VARCHAR2(400);
    C08 VARCHAR2(400);
    C09 VARCHAR2(400);
    C10 VARCHAR2(400);
    QTDLIN NUMBER;
  BEGIN
    IF QTDCOLS > 10 THEN
       RAISE_APPLICATION_ERROR(-20000, 'Num max de colunas permitido: 10');
    END IF;
    TEXTO := '';
    QTDLIN := 1;
    OPEN CONSULTA FOR SQLTEXT;
    LOOP
      CASE QTDCOLS
      WHEN 1 THEN
        FETCH CONSULTA INTO C01;
    WHEN 2 THEN
      FETCH CONSULTA INTO C01, C02;
    WHEN 3 THEN
      FETCH CONSULTA INTO C01, C02, C03;
    WHEN 4 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04;
    WHEN 5 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05;
    WHEN 6 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06;
    WHEN 7 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07;
    WHEN 8 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08;
    WHEN 9 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09;
    WHEN 10 THEN
      FETCH CONSULTA INTO C01, C02, C03, C04, C05, C06, C07, C08, C09, C10;
    END CASE;
      EXIT WHEN CONSULTA%NOTFOUND;
    TEXTO := TEXTO || '<tr style=';
    IF MOD(QTDLIN,2)=1 THEN
       TEXTO := TEXTO || 'background-color:#f8f8f8';
    ELSE
       TEXTO := TEXTO || 'background-color:#e8e8e8';
    END IF;
    TEXTO   := TEXTO || '>';
    FOR IND IN 1..qtdcols
    LOOP
      TEXTO := TEXTO || '<td style=padding:4px>';
      CASE IND
      WHEN 1 THEN
        TEXTO := TEXTO || C01;
      WHEN 2 THEN
        TEXTO := TEXTO || C02;
      WHEN 3 THEN
        TEXTO := TEXTO || C03;
      WHEN 4 THEN
        TEXTO := TEXTO || C04;
      WHEN 5 THEN
        TEXTO := TEXTO || C05;
      WHEN 6 THEN
        TEXTO := TEXTO || C06;
      WHEN 7 THEN
        TEXTO := TEXTO || C07;
      WHEN 8 THEN
        TEXTO := TEXTO || C08;
      WHEN 9 THEN
        TEXTO := TEXTO || C09;
      WHEN 10 THEN
        TEXTO := TEXTO || C10;
      END CASE;
      TEXTO := TEXTO || '</td>';
    END LOOP;
    TEXTO := TEXTO || '</tr>';
    QTDLIN := QTDLIN + 1;
  END LOOP;
  IF LENGTH(TEXTO)<>0 THEN
 TEXTO := '<table>' || TEXTO || '</table>';
  ELSE
 TEXTO := '<table><tr><td>' || NENHUM || '</td></tr></table>';
  END IF;
  RETURN TEXTO;
END LSQLTOHTML;
/

-- OBJETO 30 | PROCEDURE | SENDMAIL
create or replace
PROCEDURE "SENDMAIL" (De in varchar, Para in varchar, Assunto in varchar,Texto in varchar) is
  smtp utl_smtp.connection;
  Servidor varchar(15);
  DominioOrigem varchar(15);
  ServNome varchar2(100);
begin
  begin
    Select CONFIG, CONFIG into Servidor, DominioOrigem from SBDB.SYS_CONFIG_GLOBAL where PARAM = 'SERVIDOR DE E-MAIL';
  exception
      when no_data_found then
            Servidor := 'SMTPI';
            DominioOrigem := 'SMTPI';
  end;

  smtp := utl_smtp.open_connection(servidor,25);
  UTL_SMTP.EHLO(smtp, DominioOrigem);
  UTL_SMTP.MAIL(smtp,'<'||De ||'>');
  UTL_SMTP.RCPT(smtp, '<'||Para||'>');
  UTL_SMTP.OPEN_DATA(smtp);
  UTL_SMTP.WRITE_DATA(smtp, 'From: ' || De || UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp, 'To: ' || Para || UTL_TCP.CRLF);

  select machine into ServNome from v$session where program like 'ORACLE.EXE%' and type='BACKGROUND' and ROWNUM=1;

  utl_smtp.write_raw_data(smtp,utl_raw.cast_to_raw('Subject:' || Assunto));
  UTL_SMTP.WRITE_DATA(smtp,UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'MIME-Version: 1.0' || UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Type: multipart/mixed;'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,CHR(9)||'boundary="MENSAGEM"'||UTL_TCP.CRLF);

  UTL_SMTP.WRITE_DATA(smtp,'X-Priority: 1 (Highest)'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'X-MSMail-Priority: High'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'X-Mailer: Microsoft Office Outlook, Build 11.0.5510'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1807'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Importance: High'||UTL_TCP.CRLF);

  UTL_SMTP.WRITE_DATA(smtp,'--MENSAGEM'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Type: multipart/related;'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,CHR(9)||'boundary="CONTEUDOHTML"'||UTL_TCP.CRLF||UTL_TCP.CRLF);

  UTL_SMTP.WRITE_DATA(smtp,'--CONTEUDOHTML'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Type: text/html;'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,CHR(9)||'charset="iso-8859-1"'||UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(smtp,'Content-Transfer-Encoding: quoted-printable'||UTL_TCP.CRLF||UTL_TCP.CRLF);

  utl_smtp.write_raw_data(smtp,utl_raw.cast_to_raw(Texto));

  UTL_SMTP.CLOSE_DATA(smtp);

  UTL_SMTP.QUIT(smtp);
EXCEPTION
  WHEN utl_smtp.transient_error OR utl_smtp.permanent_error THEN
  BEGIN
    UTL_SMTP.QUIT(smtp);
  EXCEPTION
    WHEN UTL_SMTP.TRANSIENT_ERROR OR UTL_SMTP.PERMANENT_ERROR THEN
      NULL; -- When the SMTP server is down or unavailable, we don't have
  END;

END;
/
/

-- OBJETO 32 | VISÃO | VW_SOCIO_ELETRONICO
CREATE OR REPLACE VIEW SBDB.VW_SOCIO_ELETRONICO AS SELECT
    D.MAT AS SOCIO_MAT,
    C.ANUIDADE AS VIGENCIA,
    D.PROTOCOLO,
    D.OPCAO,
    DECODE(D.OPCAO,'ADESÃO',1,0) AS STATUS,
    D.DATA
  FROM
    (SELECT ANUIDADE FROM SBDB.PARAMETRO_FINANCEIRO
    ) C,
    (SELECT
        A.*,
        B.*
      FROM
        (SELECT MAT FROM SBDB.SÓCIO
        ) A,
        (SELECT PROTOCOLO, SOCIO_MAT, OPCAO, DATA, ANO_VIGENCIA FROM SBDB.HISTORICO_SOCIO_ELETRONICO WHERE SOCIO_MAT||' '||ANO_VIGENCIA||' '||DATA IN
            (SELECT SOCIO_MAT||' '||ANO_VIGENCIA||' '||MAX(DATA) FROM SBDB.HISTORICO_SOCIO_ELETRONICO GROUP BY SOCIO_MAT, ANO_VIGENCIA
            )
        ) B
      WHERE
        A.MAT = B.SOCIO_MAT (+)
    ) D
  WHERE
    C.ANUIDADE (+) = D.ANO_VIGENCIA
  ORDER BY
    D.MAT,
    C.ANUIDADE
/

-- OBJETO 100 | PROCEDURE | SITE_QUESTAO_ORD
create or replace PROCEDURE      SITE_QUESTAO_ORD (QQ_SEQ NUMBER) AS
BEGIN
    DECLARE
      SS  NUMBER;
      SSS NUMBER;
    BEGIN
      SS      := 1;
      FOR cur IN
      (SELECT quest_seq,
        seq
         FROM sbdb.site_quest_questao
        WHERE quest_seq = QQ_SEQ
     ORDER BY NVL(questao_sup_seq,0),
        NVL(ordem,0)                ,
        seq
      )
      LOOP
         UPDATE sbdb.site_quest_questao
        SET ordem         = SS
          WHERE quest_seq = cur.quest_seq
        AND seq           = cur.seq;
        SSS      := 1;
        FOR CUR2 IN
        (SELECT SEQ
           FROM SBDB.SITE_QUEST_RESP
          WHERE QUEST_SEQ = CUR.QUEST_SEQ
        AND QUESTAO_SEQ   = CUR.SEQ
       ORDER BY NVL(ORDEM,0),
          SEQ
        )
        LOOP
           UPDATE SBDB.SITE_QUEST_RESP
          SET ORDEM         = SSS
            WHERE QUEST_SEQ = CUR.QUEST_SEQ
          AND QUESTAO_SEQ   = CUR.SEQ
          AND SEQ           =CUR2.SEQ;
          SSS := SSS + 1;
        END LOOP;
        SS := SS + 1;
      END LOOP;
    END;
END;
/

-- OBJETO 100 | TRIGGER | AFT_EDITORIAL_ENVIA_SENHA
create or replace 
TRIGGER SBDB.AFT_EDITORIAL_ENVIA_SENHA AFTER UPDATE OF SENHA ON EDITORIAL FOR EACH ROW 
DECLARE 
  TEXTO VARCHAR2(4000); 
BEGIN 
	TEXTO := '<html><body> 
           <table width =  552  border =  2  cellspacing=  0  cellpadding =   0   align =  center  style=background-color:#FFFFFF> 
	         <tr> <td>			 
			     <table width= 550 border= 2 cellspacing= 0 cellpadding= 0  style=background-color:#DDDDDD > 
				 	 <tr>	<td width= 100% align= center font-size: 12pt  style= font-family:  Verdana, arial, sans-serif; ><strong><B><u></br>SOLICITAÇÃO DE SENHA</u></B></strong></td> 
				   </tr></table>      
			     <table width= 550 border= 2  cellpadding= 0 cellspacing= 0 style=background-color:#DDDDDD  > 
				   <tr > <td >'||chr(38)||'nbsp;</td> 
					 </tr> <tr> 
					 <tr > <td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt; font-family:  Verdana, arial, sans-serif > <strong>Prezado Assinante,'||chr(38)||'nbsp; </strong></td> 
					 </tr> <tr> 
           <td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt >'||chr(38)||'nbsp;</td> 
					 </tr> <tr> 
					 <td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt; font-size: 12pt;font-family:  Verdana, arial, sans-serif >Abaixo informamos o seu Login e Senha para acesso ao conteúdo completo do site.</td> 
					 </tr> <tr> 
					 <td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt >'||chr(38)||'nbsp;</td> 
					 </tr> <tr> 
					 <td style= padding: 2px 10px 2px 5px; font-size: 12pt; font-size: 12pt; font-family:  Verdana, arial, sans-serif><strong>Login:'||chr(38)||'nbsp;</strong>' || :NEW.EMAIL || '</td> 
					 </tr> <tr> 
					 <td style= padding: 2px 10px 2px 5px; font-size: 12pt; font-size: 12pt; font-family:  Verdana, arial, sans-serif><strong>Senha:'||chr(38)||'nbsp;</strong>' || :NEW.SENHA || '</td> 
					 <tr>	<td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt >'||chr(38)||'nbsp;</td> 
					 </tr> <tr> 
					 <td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt >'||chr(38)||'nbsp;</td> 
					 </tr> <tr> 
					 <td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt; font-size: 12pt; font-family:  Verdana, arial, sans-serif>Atenciosamente,</td> 
					 </tr> <tr> 
					 <td colspan=2 style= padding: 2px 5px 2px 5px; font-size: 12pt; font-size: 12pt; font-family:  Verdana, arial, sans-serif>Revista da SBD</td> 
					 </tr> 
           </table></td></tr></table></body></html>'; 
 		SENDMAIL ('revista@sbd.org.br', :NEW.EMAIL, 'SBD - DermatOnline - Cadastro de Assinantes', TEXTO) ; 
 		SENDMAIL ('revista@sbd.org.br', 'revista@sbd.org.br', 'SBD - DermatOnline - Cadastro de Assinantes', TEXTO) ; 
 		SENDMAIL ('revista@sbd.org.br', 'ERISTIDES@sbd.org.br', 'SBD - DermatOnline - Cadastro de Assinantes', TEXTO) ; 
 		SENDMAIL ('revista@sbd.org.br', 'drielle@sbd.org.br', 'SBD - DermatOnline - Cadastro de Assinantes', TEXTO) ; 
     
END;
/

-- OBJETO 101 | TRIGGER | AFT_SOCIO_ELETRONICO
create or replace
TRIGGER AFT_SOCIO_ELETRONICO AFTER UPDATE OF SOCIO_ELETRONICO ON "SÓCIO" FOR EACH ROW
DECLARE
  vOpcao VARCHAR2(10);
  vSeqProt INTEGER;
  vProt VARCHAR2(1000);
  vEmail VARCHAR2(60);
  vEmailSoc VARCHAR2(100);
  vMens VARCHAR2(4000);
BEGIN
  Select config into vEmail from sbdb.sys_config_global where param = 'SOCIO_ELETRONICO_EMAIL';

  vEmailSoc := CASE :OLD.MALA_DIRETA
                   WHEN 'R' THEN :OLD.EMAIL_RESIDENCIAL
                   WHEN '1' THEN :OLD.EMAIL_COMERCIAL_1
                   WHEN '2' THEN :OLD.EMAIL_COMERCIAL_2
               END;

  IF :OLD.SOCIO_ELETRONICO <> :NEW.SOCIO_ELETRONICO THEN

     IF :NEW.SOCIO_ELETRONICO = 0 THEN
       vOpcao := 'CANCELADO';
       Select config into vMens from sbdb.sys_config_global where param = 'SOCIO_ELETRONICO_MENS_CANCELA';
     ELSE
       vOpcao := 'ADESÃO';
       Select config into vMens from sbdb.sys_config_global where param = 'SOCIO_ELETRONICO_MENS_ADESAO';
     END IF;

     SELECT MAX(NVL(PROTOCOLO,0)) + 1 INTO vSeqProt FROM SBDB.HISTORICO_SOCIO_ELETRONICO;
     INSERT INTO SBDB.HISTORICO_SOCIO_ELETRONICO (PROTOCOLO, SOCIO_MAT, OPCAO, DATA, ANO_VIGENCIA) VALUES (vSeqProt,:OLD.MAT,vOpcao,SYSDATE,extract(YEAR from sysdate)+1);
     vProt := 'Protocolo Nº : '||LPAD(vSeqProt,10,'0');
    --SENDMAIL('WEB@SBD.ORG.BR', vEmailSoc ,'Protocolo de adesão para mídia eletrônica',  '<html><body>'||vProt||'<br /> <br /> Matrícula: '||:OLD.MAT||'<br /> <br /> Nome: '||:NEW.NOME||'<br /> <br /> '||replace(vMens,chr(13),' <br /> ')||' </body> </html> ') ;
    SENDMAIL('WEB@SBD.ORG.BR', vEmail ,'Protocolo de adesão para mídia eletrônica',  '<html><body>'||vProt||'<br /> <br /> Matrícula: '||:OLD.MAT||'<br /> <br /> Nome: '||:NEW.NOME || '<br /> <br />  E-mail Associado: '|| vEmailSoc || '<br /> <br /> '||replace(vMens,chr(13),' <br /> ') || ' <br /> </body> </html>') ;
    SENDMAIL('WEB@SBD.ORG.BR','lucianol@icraft.com.br' ,'Protocolo de adesão para mídia eletrônica',  '<html><body>'||vProt||'<br /> <br /> <b> Enviado direto para meu e-mail </b> <br /> <br /> Matrícula: '||:OLD.MAT||'<br /> <br /> Nome: '||:NEW.NOME || '<br /> <br />  E-mail Associado: '|| vEmailSoc || '<br /> <br /> '||replace(vMens,chr(13),' <br /> ') || ' <br /> </body> </html>') ;
  END IF;

END;
/

-- OBJETO 103 | TRIGGER | BEF_IMP_ETIQ_CODIGO_BARRA
create or replace TRIGGER SBDB.bef_imp_etiq_codigo_barra BEFORE UPDATE OF EMCD_DATA_IMP_ETIQ, SYS_STATUS ON sbdb.SÓCIO FOR EACH ROW
BEGIN
        :NEW.SYS_STATUS := 'X';
END;
/

-- OBJETO 104 | TRIGGER | BEF_OBRIGAÇÃO_RESTR_DATA
create or replace TRIGGER SBDB.BEF_OBRIGAÇÃO_RESTR_DATA BEFORE INSERT OR UPDATE ON sbdb.OBRIGAÇÃO
FOR EACH ROW
BEGIN
  IF (TO_CHAR(:NEW.DATA_LANÇAMENTO,'yyyy') <= '1700') or (TO_CHAR(:NEW.DATA_LANÇAMENTO,'yyyy') >= '2100') OR
     (TO_CHAR(:NEW.COMPETÊNCIA,'yyyy') <= '1700') or (TO_CHAR(:NEW.COMPETÊNCIA,'yyyy') >= '2100') OR
     (TO_CHAR(:NEW.DATA_VENCIMENTO,'yyyy') <= '1700') or (TO_CHAR(:NEW.DATA_VENCIMENTO,'yyyy') >= '2100') THEN
     RAISE_APPLICATION_ERROR(-20000, 'Tratamento de Erro');
  END IF;
END;
/

-- OBJETO 108 | TRIGGER | BEF_SOCIO_CHK
create or replace TRIGGER SBDB.BEF_SOCIO_CHK BEFORE INSERT OR UPDATE ON SÓCIO FOR EACH ROW 
DECLARE 
  EMAIL VARCHAR2(1000);
  CRIT NUMBER(1,0);
  USUARIO VARCHAR2(2);
BEGIN
  -- VALIDAÇÃO EMAIL_RESIDENCIAL
  IF :NEW.EMAIL_RESIDENCIAL IS NOT NULL THEN
    :NEW.EMAIL_RESIDENCIAL  := LOWER(REPLACE(REPLACE(:NEW.EMAIL_RESIDENCIAL,' ',''),'..','.'));
    EMAIL                   := REGEXP_SUBSTR(:NEW.EMAIL_RESIDENCIAL, '^([a-z0-9._-]+)@([a-z0-9_-]+(\.[a-z0-9_-]+)+)$');
    IF (EMAIL               IS NULL) THEN
      RAISE_APPLICATION_ERROR(-20005,'Email Residencial Inválido');
    END IF;
  END IF;
  -- VALIDAÇÃO EMAIL_COMERCIAL_1
   IF :NEW.EMAIL_COMERCIAL_1 IS NOT NULL THEN
     :NEW.EMAIL_COMERCIAL_1  := LOWER(REPLACE(REPLACE(:NEW.EMAIL_COMERCIAL_1,' ',''),'..','.'));
     EMAIL                   := REGEXP_SUBSTR(:NEW.EMAIL_COMERCIAL_1, '^([a-z0-9._-]+)@([a-z0-9_-]+(\.[a-z0-9_-]+)+)$');
     IF (EMAIL               IS NULL) THEN
       RAISE_APPLICATION_ERROR(-20005,'Email Comercial 1 Inválido');
     END IF;
   END IF;
   -- VALIDAÇÃO EMAIL_COMERCIAL_2
   IF :NEW.EMAIL_COMERCIAL_2 IS NOT NULL THEN
     :NEW.EMAIL_COMERCIAL_2  := LOWER(REPLACE(REPLACE(:NEW.EMAIL_COMERCIAL_2,' ',''),'..','.'));
     EMAIL                   := REGEXP_SUBSTR(:NEW.EMAIL_COMERCIAL_2, '^([a-z0-9._-]+)@([a-z0-9_-]+(\.[a-z0-9_-]+)+)$');
     IF (EMAIL               IS NULL) THEN
       RAISE_APPLICATION_ERROR(-20005,'Email Comercial 2 Inválido');
     END IF;
   END IF;
   
  -- RETIRA OS ESPAÇOS DO INICIO OU DO FINAL DO CAMPO  
  :NEW.CRM := TRIM(:NEW.CRM);   

  
END;
/

-- OBJETO 109 | TRIGGER | BEF_SOCIO_ENVIA_SENHA
CREATE OR REPLACE TRIGGER BEF_SOCIO_ENVIA_SENHA BEFORE INSERT ON PAGAMENTO FOR EACH ROW
DECLARE
  TEXTO VARCHAR2(2000);
  vEMAIL VARCHAR2(200);
  vPAGTO NUMBER(10,0);
  vCRM_UF VARCHAR2(2);
  vCRM VARCHAR2(50);
  vSENHA VARCHAR2(50);
  vSOCIO NUMBER(6,0);
BEGIN
  vSOCIO := :NEW.SÓCIO_MAT;
  SELECT EMAIL_MALAD INTO vEMAIL FROM SBDB.SOCIO_ENDERECO WHERE MAT = :NEW.SÓCIO_MAT AND TIPO_END = 'MALA';
  SELECT S.CRM_ESTADO, S.CRM, S.SENHA, COUNT(P.SÓCIO_MAT) INTO vCRM_UF, vCRM, vSENHA, vPAGTO FROM SBDB.SÓCIO S, SBDB.PAGAMENTO P WHERE S.MAT = P.SÓCIO_MAT (+) AND S.MAT = vSOCIO GROUP BY S.MAT, P.SÓCIO_MAT, S.CRM_ESTADO, S.CRM, S.SENHA;
  IF vPAGTO = 0 THEN
    TEXTO := '<html><body>
              <p>Prezado Associado,</p>
              <p>Seja bem-vindo(a) à SBD online!</p>
              <p>Você acaba de ser cadastrado(a) no site da SBD (<a href=http://www.sbd.org.br/>www.sbd.org.br</a>),<br />
                 onde terá acesso à informaçãoes de seu âmbito profissional além dos links abaixo:</p>
              <UL>
              <LI> Seu Cadastro On-Line
              <LI> Os Anais Brasileiros de Dermatologia
              <LI> O Portal de Periódicos SBD/EBSCO
              <LI> O Manual de Conduta
              <LI> As Palestras e etc.
              </UL>
              <p>Abaixo estão o seu Login e Senha para acesso.</p>
              <p><Table>
              <tr><td>Login: </td><td>'|| vCRM_UF || '  ' || vCRM || '</td></tr>
              <tr><td>Senha: </td><td>'|| vSENHA ||'</td></tr>
              </table></p></body></html>';
    SENDMAIL('WEB@SBD.ORG.BR',vEMAIL,'SBD - DermatOnline - Envio de Senha',TEXTO);
  END IF;
END;
/

-- OBJETO 111 | TRIGGER | BEF_STATUS_OBRIGACAO
create or replace TRIGGER SBDB.BEF_STATUS_OBRIGACAO BEFORE INSERT OR DELETE OR UPDATE OF DATA_VENCIMENTO, OBRIG_STATUS_COD ON sbdb.OBRIGAÇÃO FOR EACH ROW
begin

     if inserting then

		if :NEW.OBRIG_STATUS_COD <> 'CANCELADA' or :NEW.OBRIG_STATUS_COD is null  then
			if TRUNC(:NEW.DATA_VENCIMENTO - SYSDATE) >= 0 then
				:NEW.OBRIG_STATUS_COD := 'EM ABERTO';
			elsif TRUNC(:NEW.DATA_VENCIMENTO - SYSDATE) < 0 then
				:NEW.OBRIG_STATUS_COD := 'VENCIDA';
			end if;
		end if;
	elsif Updating then
              if :NEW.OBRIG_STATUS_COD = :OLD.OBRIG_STATUS_COD AND :NEW.OBRIG_STATUS_COD not in ('BAIXADA','CANCELADA','SUBSTITUIDA') then

			if TRUNC(:NEW.DATA_VENCIMENTO - SYSDATE) >= 0 or (:NEW.DATA_VENCIMENTO = :OLD.DATA_VENCIMENTO AND :OLD.OBRIG_STATUS_COD = 'EM ABERTO')then
				:NEW.OBRIG_STATUS_COD := 'EM ABERTO';
                        elsif  TRUNC(:NEW.DATA_VENCIMENTO - SYSDATE) < 0 then
				:NEW.OBRIG_STATUS_COD := 'VENCIDA';
			end if;
		end if;
	end if;

end;
/

-- OBJETO 112 | TRIGGER | BEF_STATUS_PAGAMENTO
create or replace TRIGGER SBDB.BEF_STATUS_PAGAMENTO Before Update or Insert or Delete on sbdb.pagamento For Each Row
Declare
flPagVal float;
flObrigVal float;
dtObrigDtVenc date;
dtDataDesc date;
flValDesc float;
flDesc float;
vObrigTipo OBRIGAÇÃO.OBRIG_TIPO%type;
vObrigStatus OBRIGAÇÃO.OBRIG_STATUS_COD%type;
bDesconto boolean;
dtCompetencia date;
nDataSistema date;
nMat NUMBER;
begin
	if updating or inserting then
		SELECT OBRIG_TIPO,ROUND(VALOR,2),DATA_VENCIMENTO,COMPETÊNCIA INTO vObrigTipo,flObrigVal,dtObrigDtVenc,dtCompetencia FROM OBRIGAÇÃO WHERE SÓCIO_MAT = :NEW.SÓCIO_MAT AND SEQ = :NEW.OBRIG_SEQ;
		flDesc := 0;
		vObrigStatus := 0;
		flPagVal := ROUND(NVL(:NEW.VALOR,0),2);
		flDesc := NVL(:NEW.DESCONTO,0);
		bDesconto := false;
		nMat:=0;
		if flpagVal+flDesc>=flObrigVal then
				vObrigStatus := 'BAIXADA';
		elsif flpagval>0 then
			vObrigStatus := 'EM ABERTO';
		end if;
		if NOT vObrigStatus IS NULL then
			UPDATE OBRIGAÇÃO SET OBRIG_STATUS_COD = vObrigStatus WHERE SÓCIO_MAT = :NEW.SÓCIO_MAT AND SEQ = :NEW.OBRIG_SEQ;
    end if;
    if inserting and vObrigTipo = 'ANUIDADE - COTA ÚNICA' then
			nMat:=:NEW.SÓCIO_MAT;
	    
      FOR CUR IN (SELECT SÓCIO_MAT||';'||SEQ AS SOCIOMAT_SEQ FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND OBRIG_TIPO LIKE 'ANUIDADE-PARCELA%' AND EXTRACT(YEAR FROM COMPETÊNCIA) = EXTRACT(YEAR FROM dtCompetencia)) LOOP
        DELETE FROM BOLETO WHERE PRODUTO_REF = CUR.SOCIOMAT_SEQ;
      END LOOP;
    	DELETE FROM OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND OBRIG_TIPO LIKE 'ANUIDADE-PARCELA%' AND TO_CHAR(COMPETÊNCIA,'YYYY') = TO_CHAR(dtCompetencia,'YYYY');
		elsif inserting and instr(vObrigTipo,'ANUIDADE-PARCELA')<>0  then
			nMat:=:NEW.SÓCIO_MAT;
      DELETE FROM BOLETO WHERE PRODUTO_REF IN (SELECT SÓCIO_MAT||';'||SEQ FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND SEQ = :NEW.OBRIG_SEQ AND  EXTRACT(YEAR FROM COMPETÊNCIA) = EXTRACT(YEAR FROM dtCompetencia) AND OBRIG_TIPO = 'ANUIDADE - COTA ÚNICA');
      
			DELETE FROM OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND OBRIG_TIPO = 'ANUIDADE - COTA ÚNICA' AND TO_CHAR(COMPETÊNCIA,'YYYY') = TO_CHAR(dtCompetencia,'YYYY');
		end if;
	else
   	nDataSistema:= SYSDATE;
		SELECT OBRIG_TIPO,VALOR,DATA_VENCIMENTO INTO vObrigTipo,flObrigVal,dtObrigDtVenc FROM OBRIGAÇÃO WHERE SÓCIO_MAT = :OLD.SÓCIO_MAT AND SEQ = :OLD.OBRIG_SEQ;
		if  TRUNC(dtObrigDtVenc - nDataSistema) >= 0 then
			vObrigStatus := 'EM ABERTO';
		else
			vObrigStatus := 'VENCIDA';
		end if;
		UPDATE OBRIGAÇÃO SET OBRIG_STATUS_COD = vObrigStatus WHERE SÓCIO_MAT = :OLD.SÓCIO_MAT AND SEQ = :OLD.OBRIG_SEQ;
	end if;
end;
/

-- OBJETO 113 | TRIGGER | BEF_PAGAMENTO_CHK
create or replace TRIGGER SBDB.BEF_PAGAMENTO_CHK BEFORE UPDATE OR INSERT ON SBDB.PAGAMENTO FOR EACH ROW
DECLARE
BEGIN
  IF :NEW.DATA < TO_DATE('01/01/1900','DD/MM/YYYY') THEN
    RAISE_APPLICATION_ERROR(-20000,'Data de pagamento inválida por ser inferior a 01/01/1900.');
  END IF;
END;
/

-- OBJETO 113 | TRIGGER | BEF_SITE_QUEST_QUESTAO_CHK
CREATE OR REPLACE TRIGGER SBDB.BEF_SITE_QUEST_QUESTAO_CHK BEFORE UPDATE OR INSERT ON SBDB.SITE_QUEST_QUESTAO FOR EACH ROW DECLARE
BEGIN
  IF :NEW.SEQ = :NEW.QUESTAO_SUP_SEQ THEN
    RAISE_APPLICATION_ERROR(-20000,'Tentativa de gravar sequencial de questão superior igual a sequencial.');
  END IF;
END;
/

-- OBJETO 114 | TRIGGER | BEF_SITE_QUEST_RESP_ID_CHK
create or replace
TRIGGER SBDB.BEF_SITE_QUEST_RESP_ID_CHK BEFORE UPDATE OR INSERT ON SBDB.SITE_QUEST_RESP_ID FOR EACH ROW 
DECLARE
  DAT_LIM DATE;
  DAT_INI DATE;
  TIPO_SITE VARCHAR2(20);
BEGIN
  SELECT DATA_INICIO, DATA_LIMITE INTO DAT_INI, DAT_LIM FROM SBDB.SITE_QUEST WHERE SEQ = :NEW.QUEST_SEQ;
  
  -- Checa se a data já permite que o questionário seja respondido
  IF SYSDATE < DAT_INI THEN
    RAISE_APPLICATION_ERROR(-20000,'Ainda não foi iniciado a permissão para responder esta questão.');
  END IF;
  
  -- Verifica se os campos EMAIL, MATRICULA E RESPOSTA FORAM PREENCHIDOS
  SELECT TIPO INTO TIPO_SITE FROM SITE_QUEST WHERE SEQ = :NEW.QUEST_SEQ;
  IF TIPO_SITE = 'QUESTIONÁRIO SÓCIO' THEN
    IF :NEW.EMAIL IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'O e-mail deve ser informado.');
    END IF;
    IF :NEW.SOCIO_MAT IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'A Matrícula deve ser informado.');
    END IF;
    IF :NEW.RESPOSTA IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'A Resposta deve ser informada.');
    END IF;
  END IF;
  
END;

/

-- OBJETO 115 | TRIGGER | BEF_EDITORIAL_ASS_ENVIO_AUTO
create or replace TRIGGER SBDB.BEF_EDITORIAL_ASS_ENVIO_AUTO
BEFORE INSERT ON SBDB.EDITORIAL_TIPO_ASS_ENVIO FOR EACH ROW
DECLARE
   PROXSEQ NUMBER(6,0);
BEGIN
   SELECT NVL(MAX(SEQ),0) + 1 INTO PROXSEQ FROM EDITORIAL_TIPO_ASS_ENVIO;
   IF :NEW.SEQ IS NULL THEN
         :NEW.SEQ := PROXSEQ;
   END IF;   
END;
/

-- OBJETO 116 | TRIGGER | AFT_EDITORIAL_ASS_ENVIO_AUTO
create or replace TRIGGER SBDB.AFT_EDITORIAL_ASS_ENVIO_AUTO
AFTER INSERT ON SBDB.EDITORIAL_TIPO_ASS_ENVIO FOR EACH ROW
DECLARE
   TOT_MAX NUMBER(3,0);
BEGIN
   SELECT TOT_MAX_VOL_ASS INTO TOT_MAX FROM SBDB.EDITORIAL_TIPO_ASSINATURA WHERE EDITORIAL_SEQ = :NEW.EDITORIAL_SEQ AND SEQ = :NEW.TIPO_ASS_SEQ;
   IF TOT_MAX = :NEW.QUANTIDADE_ENVIADA THEN
      UPDATE SBDB.EDITORIAL_TIPO_ASSINATURA SET DATA_FINAL = SYSDATE WHERE EDITORIAL_SEQ = :NEW.EDITORIAL_SEQ AND SEQ = :NEW.TIPO_ASS_SEQ;
   END IF;
END;
/

-- OBJETO 200 | PROCEDURE | DBMS_LOG
create or replace
PROCEDURE DBMS_LOG AS
  TEXTO CLOB;
  TEXTO1 CLOB;
  TEXTO2 CLOB;
  TestePKT VARCHAR2(4000);
  HOST_INFO VARCHAR2(4000);
  CurTrg INTEGER;
  CurJob INTEGER;
  CurTab INTEGER;
  CurOSC INTEGER;
  CurCat INTEGER;
  CurReg INTEGER;
  CurAtu INTEGER;
  CurVaz INTEGER;
  CurDel INTEGER;
  CurCon INTEGER;
  CurCMP INTEGER;
  CurTBL INTEGER;
  CurUSR INTEGER;
  Cursor LTRIGGER IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">TRIGGER PARADA</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || TRIGGER_NAME || '</TD></TR>' AS TRIGGER_NAME FROM "SYS"."ALL_TRIGGERS" WHERE STATUS = 'DISABLED' AND OWNER = 'SBDB';
  Cursor LJOB IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">JOB PARADO</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || JOB || ' - ' || TO_CHAR(LAST_DATE,'DD/MM/YYYY') || ' - ' || WHAT || '</TD></TR>' as JOB_DADOS FROM "SYS"."USER_JOBS" WHERE BROKEN = 'S' ORDER BY JOB;
  Cursor LTAB IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">TABELA COM MAIS DE 500.000 REGISTROS</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || TABLE_NAME || ' [' || TO_CHAR(NUM_ROWS) || ']</TD></TR>' AS TABLE_NAME FROM "SYS"."ALL_ALL_TABLES" WHERE OWNER = 'SBDB' AND NUM_ROWS > 500000 ORDER BY TABLE_NAME;
  --Cursor LSOC IS SELECT MAT, OBRIG_STATUS_COD, CATEGORIA_COD, CPF, CRM, CRM_ESTADO, DATA_CADASTRO, REGIONAL_COD FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 ORDER BY MAT;
  Cursor LOSC IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">ASSOCIADO '||OBRIG_STATUS_COD||'</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || COUNT(OBRIG_STATUS_COD) || '</TD></TR>' AS OBRIG_NOME FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 GROUP BY OBRIG_STATUS_COD,EXCLUÍDO ORDER BY OBRIG_STATUS_COD;
  Cursor LCAT IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">ASSOCIADO '||CATEGORIA_COD||'</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || COUNT(CATEGORIA_COD) || '</TD></TR>' AS CATEG_NOME FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 GROUP BY CATEGORIA_COD, EXCLUÍDO ORDER BY CATEGORIA_COD;
  Cursor LREG IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">ASSOCIADO '||REGIONAL_COD||'</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || COUNT(REGIONAL_COD) || '</TD></TR>'  AS REGIONAL_NOME FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 GROUP BY REGIONAL_COD, EXCLUÍDO ORDER BY REGIONAL_COD;
  Cursor LATU IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">'||MAT || ' - ' || NOME || ' - ' || CATEGORIA_COD || ' - ' || OBRIG_STATUS_COD || ' - ' || REGIONAL_COD||'</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || SYS_LOCAL_ATUALIZA || '</TD></TR>'  AS ATUALIZA FROM SBDB.SÓCIO WHERE TO_CHAR(SYS_MOMENTO_ATUALIZA,'DD/MM/YYYY') = TO_CHAR(SYSDATE - 1,'DD/MM/YYYY') ORDER BY MAT;
  Cursor LVAZ IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">CATEGORIA</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || A.CATEGORIA || '</TD></TR>' AS CATEGORIA,
                        ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">CPF</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || B.CPF || '</TD></TR>' AS CPF,
                        ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">CRM</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || C.CRM || '</TD></TR>' AS CRM,
                        ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">DATA CADASTRO</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || D.DATA_CADASTRO || '</TD></TR>' AS DATA_CADASTRO,
                        ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">REGIONAL</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || E.REGIONAL_COD || '</TD></TR>' AS REGIONAL_COD,
                        ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">SEXO</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || F.SEXO || '</TD></TR>' AS SEXO,
                        ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">DATA DE NASCIMENTO</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;">' || G.DATA_NASCIMENTO || '</TD></TR>' AS DATA_NASCIMENTO
                        FROM (SELECT COUNT(NVL(CATEGORIA_COD,0)) AS CATEGORIA FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND CATEGORIA_COD IS NULL OR CATEGORIA_COD = '') A,
                             (SELECT COUNT(NVL(CPF,0)) AS CPF FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND CPF IS NULL OR CPF = '') B,
                             (SELECT COUNT(NVL(CRM,0)) AS CRM FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND CRM IS NULL OR CRM = '') C,
                             (SELECT COUNT(DATA_CADASTRO) AS DATA_CADASTRO FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND DATA_CADASTRO IS NULL) D,
                             (SELECT COUNT(NVL(REGIONAL_COD,0)) AS REGIONAL_COD FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND REGIONAL_COD IS NULL OR REGIONAL_COD = '') E,
                             (SELECT COUNT(NVL(SEXO,0)) AS SEXO FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND SEXO IS NULL OR SEXO = '') F,
                             (SELECT COUNT(DATA_NASCIMENTO) AS DATA_NASCIMENTO FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND DATA_NASCIMENTO IS NULL) G;
  Cursor LDEL IS SELECT ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;">'||REGIONAL_COD||'</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;"> TOT_QI [' || LPAD(COUNT(MAT),5,'0') || '] | TOT_QI/50 [' || TO_CHAR(COUNT(MAT)/50,'9999.99') || '] | PERMITIDO [' || LPAD(trunc(COUNT(MAT)/50),5,'0') || ']</TD></TR>' AS DELEGADO FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0 AND (OBRIG_STATUS_COD LIKE 'QUITE%' OR OBRIG_STATUS_COD LIKE 'ISENTO%') group by regional_cod;
  Cursor LCON IS SELECT TO_CHAR(LOGON_TIME,'DD/MM/YYYY HH:MI:SS') AS DATA, USERNAME, STATUS, PROGRAM from v$Session where program = 'SBD_CIAD.exe' ORDER BY USERNAME,LOGON_TIME;
  Cursor LCOMPCMPORAGER IS SELECT '<TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || ORIGEM || '</TD> <TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;">' || SISTEMA || '</TD><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || TABELA || '</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;">' || CAMPO || '</TD> <TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || TIPO || '</TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;">' || ETIQUETA || '</TD> <TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || DESCRICAO || '</TD> </TR> ' AS COMPARA_CAMPO
                           FROM ((select 'ORACLE' AS ORIGEM, TRIM(DT.OWNER) AS SISTEMA, TRIM(DT.TABLE_NAME) AS TABELA, TRIM(DT.COLUMN_NAME) AS CAMPO, TRIM(DT.DATA_TYPE || ' ' || CASE when DT.DATA_TYPE = 'NUMBER' then '(' || NVL(DT.DATA_PRECISION,5) ||',' || NVL(DT.DATA_SCALE,0) ||')' WHEN DT.DATA_TYPE = 'VARCHAR2' THEN '(' || DT.DATA_LENGTH ||')' when DT.DATA_TYPE = 'CLOB' THEN '' ELSE '' end) AS TIPO, TRIM(LB.LITEM(C.COMMENTS ,2,'|')) AS ETIQUETA, TRIM(LB.LITEM(C.COMMENTS,1,'|')) AS DESCRICAO
                           FROM SYS.ALL_COL_COMMENTS C, SYS.ALL_TAB_COMMENTS T, SYS.ALL_TAB_COLUMNS DT WHERE C.OWNER    = T.OWNER AND T.OWNER      = DT.OWNER and C.TABLE_NAME = T.TABLE_NAME and T.TABLE_NAME = DT.TABLE_NAME and C.COLUMN_NAME = DT.COLUMN_NAME AND SUBSTR(C.TABLE_NAME, 1, 4) != 'BIN$' AND SUBSTR(C.TABLE_NAME, 1, 3) != 'DR$' AND T.TABLE_TYPE                = 'TABLE' and C.OWNER                    in ('SBDB') AND C.COLUMN_NAME NOT LIKE 'SYS%' AND DT.TABLE_NAME NOT LIKE 'GER_%' MINUS select 'ORACLE' AS ORIGEM, TRIM(SISTEMA) AS SISTEMA, TRIM(TABELA) AS TABELA, TRIM(CAMPO) AS CAMPO,
                           TRIM(CASE WHEN TIPO_ORACLE IS NOT NULL THEN TIPO_ORACLE
                                WHEN TIPO_ACCESS LIKE 'LONG%' THEN 'NUMBER (11,0)' WHEN TIPO_ACCESS LIKE 'BOOLEAN%' THEN 'NUMBER (1,0)'  WHEN TIPO_ACCESS LIKE 'CURRENCY%' THEN 'NUMBER (16,2)'  WHEN TIPO_ACCESS LIKE 'DOUBLE%' THEN 'NUMBER (16,2)'  WHEN TIPO_ACCESS LIKE 'DATE%' THEN 'DATE'  WHEN TIPO_ACCESS LIKE 'DECIMAL%' THEN 'NUMBER (12,2)'
                                WHEN TIPO_ACCESS LIKE 'SINGLE%' THEN 'NUMBER (8,6)' WHEN TIPO_ACCESS LIKE 'INTEGER%' THEN 'NUMBER (6,0)' WHEN TIPO_ACCESS LIKE 'MEMO%' THEN 'VARCHAR2 (4000)'  WHEN TIPO_ACCESS LIKE 'TEXT%' THEN 'VARCHAR2' || SUBSTR(TIPO_ACCESS,8,10)  WHEN TIPO_ACCESS LIKE 'OBJETOOLE%' THEN 'BLOB'
                                WHEN TIPO_MYSQL LIKE 'DECIMAL%' THEN 'NUMBER ' || SUBSTR(TIPO_MYSQL,8,10) WHEN TIPO_MYSQL LIKE 'FLOAT%' THEN 'FLOAT'  WHEN TIPO_MYSQL LIKE 'DECIMAL (16,2)' THEN 'NUMBER (16,2)'  WHEN TIPO_MYSQL LIKE 'DATETIME%' THEN 'DATE' WHEN TIPO_MYSQL LIKE 'CLOB%' THEN 'CLOB' || SUBSTR(TIPO_MYSQL,6,10) WHEN TIPO_MYSQL LIKE 'BLOB' THEN 'BLOB' WHEN TIPO_MYSQL LIKE 'INT (12)' THEN 'NUMBER (12,2)'
                                WHEN TIPO_MYSQL LIKE 'VARCHAR%' THEN 'VARCHAR2' || SUBSTR(TIPO_MYSQL,8,10) WHEN TIPO_MYSQL LIKE 'DOUBLE%' THEN 'NUMBER (16,2)' WHEN TIPO_MYSQL LIKE 'SINGLE%' THEN 'NUMBER (8,6)' WHEN TIPO_MYSQL LIKE 'INTEGER%' THEN 'NUMBER (6,0)'  WHEN TIPO_MYSQL LIKE 'MEMO%' THEN 'VARCHAR2 (4000)'  WHEN TIPO_MYSQL LIKE 'TEXT%' THEN 'VARCHAR2' || SUBSTR(TIPO_MYSQL,8,10)  WHEN TIPO_MYSQL LIKE 'BLOB%' THEN 'BLOB'  WHEN TIPO_MYSQL LIKE 'CHAR%' THEN 'VARCHAR2 (1)'
                           END) AS TIPO, TRIM(ETIQ) AS ETIQUETA, TRIM(dbms_lob.substr(DESCR, 4000, 1)) AS DESCRICAO
                           from GER_CAMPO WHERE SISTEMA='SBDB' AND TABELA NOT LIKE 'GER_%') UNION
                           (select 'GERADOR' AS ORIGEM, TRIM(SISTEMA) AS SISTEMA, TRIM(TABELA) AS TABELA, TRIM(CAMPO) AS CAMPO,
                           TRIM(CASE WHEN TIPO_ORACLE IS NOT NULL THEN TIPO_ORACLE  WHEN TIPO_ACCESS LIKE 'LONG%' THEN 'NUMBER (11,0)'  WHEN TIPO_ACCESS LIKE 'BOOLEAN%' THEN 'NUMBER (1,0)'  WHEN TIPO_ACCESS LIKE 'CURRENCY%' THEN 'NUMBER (16,2)'  WHEN TIPO_ACCESS LIKE 'DOUBLE%' THEN 'NUMBER (16,2)'  WHEN TIPO_ACCESS LIKE 'DATE%' THEN 'DATE'  WHEN TIPO_ACCESS LIKE 'DECIMAL%' THEN 'NUMBER (12,2)'  WHEN TIPO_ACCESS LIKE 'SINGLE%' THEN 'NUMBER (8,6)'  WHEN TIPO_ACCESS LIKE 'INTEGER%' THEN 'NUMBER (6,0)'
                                WHEN TIPO_ACCESS LIKE 'MEMO%' THEN 'VARCHAR2 (4000)'  WHEN TIPO_ACCESS LIKE 'TEXT%' THEN 'VARCHAR2' || SUBSTR(TIPO_ACCESS,8,10)  WHEN TIPO_ACCESS LIKE 'OBJETOOLE%' THEN 'BLOB'  WHEN TIPO_MYSQL LIKE 'DECIMAL%' THEN 'NUMBER ' || SUBSTR(TIPO_MYSQL,8,10)  WHEN TIPO_MYSQL LIKE 'FLOAT%' THEN 'FLOAT' WHEN TIPO_MYSQL LIKE 'DECIMAL (16,2)' THEN 'NUMBER (16,2)' WHEN TIPO_MYSQL LIKE 'DATETIME%' THEN 'DATE' WHEN TIPO_MYSQL LIKE 'CLOB%' THEN 'CLOB' || SUBSTR(TIPO_MYSQL,6,10)
                                WHEN TIPO_MYSQL LIKE 'BLOB' THEN 'BLOB'  WHEN TIPO_MYSQL LIKE 'INT (12)' THEN 'NUMBER (12,2)' WHEN TIPO_MYSQL LIKE 'VARCHAR%' THEN 'VARCHAR2' || SUBSTR(TIPO_MYSQL,8,10) WHEN TIPO_MYSQL LIKE 'DOUBLE%' THEN 'NUMBER (16,2)'  WHEN TIPO_MYSQL LIKE 'SINGLE%' THEN 'NUMBER (8,6)'  WHEN TIPO_MYSQL LIKE 'INTEGER%' THEN 'NUMBER (6,0)' WHEN TIPO_MYSQL LIKE 'MEMO%' THEN 'VARCHAR2 (4000)' WHEN TIPO_MYSQL LIKE 'TEXT%' THEN 'VARCHAR2' || SUBSTR(TIPO_MYSQL,8,10) WHEN TIPO_MYSQL LIKE 'BLOB%' THEN 'BLOB'
                                WHEN TIPO_MYSQL LIKE 'CHAR%' THEN 'VARCHAR2 (1)'
                           END) AS TIPO, TRIM(ETIQ) AS ETIQUETA, TRIM(dbms_lob.substr(DESCR, 4000, 1)) AS DESCRICAO
                           from GER_CAMPO WHERE SISTEMA='SBDB' AND TABELA NOT LIKE 'GER_%' MINUS
                           select 'GERADOR' AS ORIGEM, TRIM(DT.OWNER) AS SISTEMA, TRIM(DT.TABLE_NAME) AS TABELA, TRIM(DT.COLUMN_NAME) AS CAMPO, TRIM(DT.DATA_TYPE || ' ' || CASE when DT.DATA_TYPE = 'NUMBER' then '(' || NVL(DT.DATA_PRECISION,5) ||',' || NVL(DT.DATA_SCALE,0) ||')' WHEN DT.DATA_TYPE = 'VARCHAR2' THEN '(' || DT.DATA_LENGTH ||')' when DT.DATA_TYPE = 'CLOB' THEN '' ELSE '' end) AS TIPO, TRIM(LB.LITEM(C.COMMENTS ,2,'|')) AS ETIQUETA, TRIM(LB.LITEM(C.COMMENTS,1,'|')) AS DESCRICAO
                           FROM SYS.ALL_COL_COMMENTS C,  SYS.ALL_TAB_COMMENTS T,  SYS.ALL_TAB_COLUMNS DT WHERE C.OWNER    = T.OWNER AND T.OWNER      = DT.OWNER and C.TABLE_NAME = T.TABLE_NAME and T.TABLE_NAME = DT.TABLE_NAME and C.COLUMN_NAME = DT.COLUMN_NAME
                           AND SUBSTR(C.TABLE_NAME, 1, 4) != 'BIN$' AND SUBSTR(C.TABLE_NAME, 1, 3) != 'DR$' AND T.TABLE_TYPE = 'TABLE' and C.OWNER in ('SBDB') AND C.COLUMN_NAME NOT LIKE 'SYS%' AND DT.TABLE_NAME NOT LIKE 'GER_%' ) ORDER BY 3,4,1);
  Cursor LCOMPTBLORAGER IS SELECT '<TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || ORIGEM || '</TD> <TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;">' || SISTEMA || '</TD><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || TABELA || '</TD> </TR> ' AS COMPARA_TABELA
                           FROM (((select 'ORACLE' AS ORIGEM, TRIM(AT.OWNER) AS SISTEMA, TRIM(AT.TABLE_NAME) AS TABELA FROM ALL_TABLES AT WHERE AT.OWNER = 'SBDB')  MINUS
                                (select 'ORACLE' AS ORIGEM, TRIM(SISTEMA) AS SISTEMA, TRIM(TABELA) AS TABELA FROM GER_TABELA WHERE SISTEMA='SBDB')) UNION
                                ((select 'GERADOR' AS ORIGEM, TRIM(SISTEMA) AS SISTEMA, TRIM(TABELA) AS TABELA FROM GER_TABELA WHERE SISTEMA='SBDB') MINUS
                                 (select 'GERADOR' AS ORIGEM, TRIM(AT.OWNER) AS SISTEMA, TRIM(AT.TABLE_NAME) AS TABELA FROM ALL_TABLES AT WHERE AT.OWNER = 'SBDB'))) ORDER BY TABELA, ORIGEM;
  Cursor LCOMPUSUORAGER IS SELECT '<TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || ORIGEM || '</TD> <TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;">' || USUARIO ||
                                  '</TD> <TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;">' || SISTEMA || '</TD> <TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;">' || OBJETO_NOME ||
                                  '</TD><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;">' || PERMISSAO || '</TD> </TR> ' AS COMPARA_USUARIO  FROM (
                                  (SELECT  DISTINCT GRANTEE AS USUARIO, OWNER AS SISTEMA, TABLE_NAME AS OBJETO_NOME, decode(SELECT_PRIV, 'N', '','SEL;') || decode(INSERT_PRIV, 'N', '','INS;') || decode(UPDATE_PRIV, 'N', '','UPD;') || decode(DELETE_PRIV, 'N','','DEL;') AS PERMISSAO, 'BANCO' AS ORIGEM from table_privileges WHERE OWNER = 'SBDB' MINUS
                                   SELECT  USUARIO, SISTEMA, OBJETO_NOME, PERMISSAO, 'BANCO' AS ORIGEM  FROM GER_DIREITO WHERE SISTEMA='SBDB' AND OBJETO_TIPO='TABELA') UNION
                                  (SELECT USUARIO, SISTEMA, OBJETO_NOME, PERMISSAO, 'GERADOR' AS ORIGEM  FROM GER_DIREITO WHERE SISTEMA='SBDB' AND OBJETO_TIPO='TABELA' MINUS
                                   SELECT  DISTINCT GRANTEE AS USUARIO, OWNER AS SISTEMA, TABLE_NAME AS OBJETO_NOME, decode(SELECT_PRIV, 'N', '','SEL;') || decode(INSERT_PRIV, 'N', '','INS;') || decode(UPDATE_PRIV, 'N', '','UPD;') || decode(DELETE_PRIV, 'N','','DEL;') AS PERMISSAO, 'GERADOR' AS ORIGEM from table_privileges WHERE OWNER = 'SBDB')) WHERE ROWNUM < 50 AND USUARIO NOT IN ('PUBLIC') AND OBJETO_NOME NOT IN ('LB','LSBD','RSBD','DBMS_ICRAFT','SITE','EMCD')
                                  GROUP BY USUARIO, SISTEMA, OBJETO_NOME, PERMISSAO, ORIGEM  ORDER BY USUARIO, OBJETO_NOME;
  
  Controle INTEGER;

BEGIN
  ------------------------------- TEXTO SBD - Oracle SBDB - Log SBD da Base de dados do HOST
  TEXTO := TEXTO || ' <Table>';
  TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;"><b>INFORMAÇÃO SOBRE OBJETOS</b></TD><TD style="padding:4px;background-color:#e8e8e8;width:500px;font-family:tahoma;"><b>TOTALIZAÇÃO</b></TD></TR>';
  -- Rotina para checar se exites TRIGGERs paradas
  for CurTrg in LTRIGGER loop
    TEXTO := TEXTO || CurTrg.TRIGGER_NAME;
  end LOOP;
  -- Rotina para checar se exites JOBs parados
  for CurJob in LJOB loop
    TEXTO := TEXTO || CurJob.JOB_DADOS;
  end LOOP;
  -- Rotina para checar se existe tabela com mais de 500.000 registros
  for CurTab in LTAB loop
    TEXTO := TEXTO || CurTab.TABLE_NAME;
  end LOOP;
  begin
    TestePKT := EMCD.VALIDAFASE(1,'0005');
  exception
    when others then
      TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;">PACOTE EMCD PARADO</TD><TD style="padding:4px;background-color:#e8e8e8;width:500px;font-family:tahoma;">'|| SQLERRM ||'</TD></TR>';
  end;
  TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;"><b>ASSOCIADO POR SITUAÇAO</b></TD><TD style="padding:4px;background-color:#e8e8e8;width:500px;font-family:tahoma;"><b>TOTALIZAÇÃO</b></TD></TR>';
  -- Rotina totalizar associados por situação
  for CurOSC in LOSC loop
    TEXTO := TEXTO || CurOSC.OBRIG_NOME;
  end LOOP;
  TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;"><b>ASSOCIADO POR CATEGORIAL</b></TD><TD style="padding:4px;background-color:#e8e8e8;width:500px;font-family:tahoma;"><b>TOTALIZAÇÃO</b></TD></TR>';
  -- Rotina totalizar associados por categoria
  for CurCat in LCAT loop
    TEXTO := TEXTO || CurCat.CATEG_NOME;
  end LOOP;
  TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;"><b>ASSOCIADO POR REGIONAL</b></TD><TD style="padding:4px;background-color:#e8e8e8;width:500px;font-family:tahoma;"><b>TOTALIZAÇÃO</b></TD></TR>';
  -- Rotina totalizar associados por regional
  for CurReg in LREG loop
    TEXTO := TEXTO || CurReg.REGIONAL_NOME;
  end LOOP;
  TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;"><b>ASSOCIADO ATUALIZADOS EM '||TO_CHAR(SYSDATE-1,'DD/MM/YYYY')||'</b></TD><TD style="padding:4px;background-color:#e8e8e8;width:500px;font-family:tahoma;"><b>USUARIO</b></TD></TR>';
  -- Rotina para visualizar os associados atualizados
  for CurAtu in LATU loop
    TEXTO := TEXTO || CurAtu.ATUALIZA;
  end LOOP;
  TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;"><b>CAMPOS QUE NÃO PODERIAM ESTAR ZERADOS</b></TD><TD style="padding:4px;background-color:#e8e8e8;width:800px;font-family:tahoma;"><b>TOTALIZAÇÃO</b></TD></TR>';
  -- Rotina para visualizar campos que não poderiam está vazios
  for CurVaz in LVAZ loop
    TEXTO := TEXTO || CurVaz.CATEGORIA;
    TEXTO := TEXTO || CurVaz.CPF;
    TEXTO := TEXTO || CurVaz.CRM;
    TEXTO := TEXTO || CurVaz.REGIONAL_COD;
    TEXTO := TEXTO || CurVaz.SEXO;
    TEXTO := TEXTO || CurVaz.DATA_CADASTRO;
    TEXTO := TEXTO || CurVaz.DATA_NASCIMENTO;
  end LOOP;
  TEXTO := TEXTO || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;width:300px;font-family:tahoma;"><b>DELEGADOS PERMITIDO POR REGIONAL</b></TD><TD style="padding:4px;background-color:#e8e8e8;width:800px;font-family:tahoma;"><b>TOTALIZAÇÃO</b></TD></TR>';
  -- Rotina para visualizar campos que não poderiam está vazios
  for CurDel in LDEL loop
    TEXTO := TEXTO || CurDel.DELEGADO;
  end LOOP;
  TEXTO := TEXTO || ' </Table>' || ' <br /> FIM' ;

  ------------------------- TEXTO1 Log SBD Comparação da Estrutura GERADOR\ORACLE do HOST
  TEXTO1 := TEXTO1 || ' <Table>';
  TEXTO1 := TEXTO1 || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;"><b>ORIGEM</b></TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;"><b>SISTEMA</b></TD>
                        <TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;"><b>TABELA</b></TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;"><b>CAMPO</b></TD>
                        <TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;"><b>TIPO</b></TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;"><b>ETIQUETA</b></TD>
                        <TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;"><b>DESCRIÇÃO</b></TD></TR>';

  -- Rotina para comparar os campos existentes no oracle com os existentes no gerador
  TEXTO1 := TEXTO1 || ' <TR colspan="7" bgcolor="#FFFF00"><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;;" ><b>COMPARANDO CAMPOS</b></TD></TR>';
  Controle := 0;
  for CurCMP in LCOMPCMPORAGER loop
       TEXTO1 := TEXTO1 || CurCMP.COMPARA_CAMPO;
  end LOOP;

  -- Rotina para comparar os tabelas existentes no oracle com os existentes no gerador
  TEXTO1 := TEXTO1 || ' <TR colspan="7" bgcolor="#FFFF00"><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;" ><b>COMPARANDO TABELAS</b></TD></TR>';
  Controle := 0;
  for CurCMP in LCOMPTBLORAGER loop
       TEXTO1 := TEXTO1 || CurCMP.COMPARA_TABELA;
  end LOOP;
  TEXTO1 := TEXTO1 || ' </Table>' || ' <br /> FIM' ;

  ------------------------- TEXTO2 Log SBD Comparação da Estrutura dos usuários e permissões do HOST

  TEXTO2 := TEXTO2 || ' <Table>' ;
  TEXTO2 := TEXTO2 || ' <TR ><TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;"><b>ORIGEM</b></TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;"><b>USUARIO</b></TD>
                        <TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;"><b>SISTEMA_USUARIO</b></TD><TD style="padding:4px;background-color:#e8e8e8;font-family:tahoma;fonte-size:8px;"><b>TABELA</b></TD>
                        <TD style="padding:4px;background-color:#f8f8f8;font-family:tahoma;fonte-size:8px;"><b>PERMISSAO</b></TD></TR>';

  -- Rotina para comparar os tabelas existentes no oracle com os existentes no gerador
  Controle := 0;

  for CurUSR in LCOMPUSUORAGER loop
      TEXTO2 := TEXTO2 || CurUSR.COMPARA_USUARIO;
  end LOOP;
  TEXTO2 := TEXTO2 || ' </Table>' || ' <br /> FIM' ;

  select UTL_INADDR.GET_HOST_NAME || ' - [' || UTL_INADDR.GET_HOST_ADDRESS || ']' INTO HOST_INFO from DUAL;
  SENDMAIL('SBD@sbd.org.br','lucianol@icraft.com.br','SBD - Oracle SBDB - Log SBD Comparação da Estrutura GERADOR\ORACLE do HOST: '|| HOST_INFO, TEXTO1);
  SENDMAIL('SBD@sbd.org.br','lucianol@icraft.com.br','SBD - Oracle SBDB - Log SBD Comparação da Estrutura GERADOR\ORACLE de Usuários e Permissões do HOST: '|| HOST_INFO, TEXTO2);

EXCEPTION
    when OTHERS then
      raise_application_error(-20000, 'Erro em DBMS_LOG - ' || SQLERRM);
END DBMS_LOG;
/

-- OBJETO 201 | PACKAGE | LB
create or replace
PACKAGE "LB" is
	function Litem(Texto in varchar2, Item in number, Sep in varchar2 default '') return varchar2;
	function Litem(Texto in varchar2, Item in varchar2, Sep in varchar2 default '') return number;
	function Lparam(Campo in varchar2, tipo in varchar2) return varchar2;
	function Lustr(Texto in varchar2) return varchar2;
	function Lextenso(VV in number, Ling in varchar2) return varchar2;
	function Lmontacento(Strv0 in varchar2, StrCem in varchar2, Sep in varchar2, StrDez in varchar2, StrPrimaDez in varchar2, StrUnid in varchar2) return varchar2;
	function Lconcatcamp(Dominio in varchar2, Delimit in varchar2) return varchar2;
	function Lnumling(Num in number, Masc in varchar2, Ling in varchar2) return varchar2;
 	function LInsereEspaco(Str in varchar2, Tamanho in number) return varchar2;
  Function LExibeData(Momento in Date, Formato in Varchar2 default '') return Varchar2;
	Procedure LExecutaString(cmdSql in Varchar);
  Procedure LCria_Job (vNomeJob in varchar2,vProced in varchar2, vHoraExec in varchar2,vIntervaloHoras in varchar2 default '24');
  Procedure LCria_Job_N(vNomeJob in varchar2, vProced in varchar2, vHoraExec in varchar2, vIntervaloDias in number default '1', vIntervalo in number default '1', vMetodo in VARCHAR2 default 'd');
  Procedure LApaga_Job (vNomeJob in varchar2);
  Procedure LCompObjetos;
end lb;
/

create or replace PACKAGE BODY "LB" is
function LItem(Texto in varchar2, Item in number, Sep in varchar2 default '') return varchar2 is
	Pos number;
	Pos2 number;
	Busca number;
	Limit varchar2(500);
Begin
		if Sep is null then
			if instr(Texto, ';') <> 0 then
				Limit := ';';
			else
				Limit := '.';
			end if;
		else
			Limit := Sep;
		end if;

		Busca := 0;
		Pos := 1;
		while Pos <= length(Texto) loop
			Pos2 := instr(Texto, Limit, Pos);
			if Pos2 = 0 then
				Pos2 := length(Texto)+1;
			end if;
			Busca := Busca + 1;
			if Busca = Item then
				return substr(Texto, Pos, Pos2-Pos);
			else
				Pos := Pos2 + 1;
			end if;
		end loop;
		return '';
	exception
		when others then
		raise_application_error ( -20000, 'erro em litem: ' || SQLERRM);

	end litem;

Function LItem(Texto in varchar2, Item in varchar2, Sep in varchar2 default '') return number is
	Pos number;
	Pos2 number;
	Busca number;
	Limit varchar2(500);

	begin
		if Sep is null then
			if instr(Texto, ';') <> 0 then
				Limit := ';';
			else
				Limit := '.';
			end if;
		else
			Limit := Sep;
		end if;

		Busca := 0;
		Pos := 1;

		while Pos <= length(Texto) loop
			Pos2 := instr(Texto, Limit, Pos);
			if Pos2 = 0 then
				Pos2 := length(Texto)+1;
			end if;
			Busca := Busca + 1;

			if not Item is null then
				if substr(Texto, Pos, Pos2-Pos) = Item then
					return Busca;
				end if;
			end if;

			Pos := Pos2 + 1;
		end loop;

		return 0;
	exception
		when others then
		raise_application_error ( -20000, 'erro em litem: ' || SQLERRM);

	end litem;


Function LParam(Campo in varchar2, Tipo in varchar2) return varchar2 is
	Pos integer;
	Pos2 integer;
	Texto varchar2(4000);
	begin
		Pos := instr(chr(13) || chr(10) || Campo, chr(13) || chr(10) || Tipo || ':');
		if Pos <> 0 then
			Pos := Pos + length(Tipo) + 1;
			Pos2 := instr(Campo, chr(13) || chr(10), pos);
			if Pos2 = 0 then
				Texto := substr(Campo, Pos);
			else
				Texto := substr(Campo, Pos, Pos2-Pos);
			end if;
		else
			return '';
		end if;

		return replace(Texto, '|', chr(10));
	exception
		when others then
			raise_application_error ( -20000, 'erro em lparam: ' || SQLERRM);

	end lparam;


Function LUstr(Texto in varchar2) return varchar2 is
	begin
		return replace(Texto, chr(13) || chr(10), chr(10));

	exception
		when others then
			raise_application_error ( -20000, 'erro em lustr: ' || SQLERRM);

	end lustr;


	function lextenso(VV in number, Ling in varchar2) return varchar2 is

	StrUnid varchar2(500);
	StrDez varchar2(500);
	StrCem varchar2(500);
	StrMil varchar2(500);
	StrCent varchar2(500);
	Moeda varchar2(500);
	Sep varchar2(500);
	StrPrimaDez varchar2(500);
	StrVV varchar2(500);
	StrV0 varchar2(500);
	StrMoeda varchar2(500);
	StrM0 varchar2(500);
	Esp varchar2(500);
	SepDec varchar2(500);
	Z number;
	SepAndTres varchar2(500);
	SepMil varchar2(500);

	begin

		if Ling = 'R$' then
    			StrUnid := 'Um;Dois;Três;Quatro;Cinco;Seis;Sete;Oito;Nove';
	    		StrPrimaDez := 'Onze;Doze;Treze;Quatorze;Quinze;Dezesseis;Dezesete;Dezoito;Dezenove';
	    		StrDez := 'Dez;Vinte;Trinta;Quarenta;Cinquenta;Sessenta;Setenta;Oitenta;Noventa';
	    		StrCem := 'Cento;Duzentos;Trezentos;Quatrocentos;Quinhentos;Seiscentos;Setecentos;Oitocentos;Novecentos';
	    		StrMil := 'Mil.Mil;Milhão.Milhões;Bilhão.Bilhões;Trilhão.Trilhões';
	    		StrCent := 'Centavo.Centavos';
	    		Moeda := 'Real;Reais;de Reais';
	    		Sep := ' e ';
	    		SepDec := ' e ';
	    		SepMil := ', ';
	    		SepAndTres := ' e ';
	    		Esp := ' ';
		elsif Ling = 'USD' or Ling = 'US$' or Ling = 'USD.' or Ling = 'U.S.DLRS' then
	    		StrUnid := 'One;Two;Three;Four;Five;Six;Seven;Eight;Nine';
	    		StrPrimaDez := 'Eleven;Twelve;Thirteen;Fourteen;Fifteen;Sixteen;Seventeen;Eighteen;Nineteen';
	    		StrDez := 'Tem;Twenty;Thirty;Forty;Fifty;Sixty;Seventy;Eighty;Ninety';
	    		StrCem := 'One Hundred;Two Hundred;Three Hundred;Four Hundred;Five Hundred;Six Hundred;Seven Hundred;Eight Hundred;Nine Hundred';
	    		StrMil := 'Thousand.Thousand;Million.Millions;Billion.Billions;Trillion.Trillions';
	    		StrCent := 'Cent.Cents';
			MOEDA := 'U.S. Dollar;U.S. Dollars;U.S. Dollars';
	    		Sep := ' ';
	    		SepDec := ' and ';
	    		SepMil := ', ';
	    		Esp := ' ';
	    		SepAndTres := ' and ';
		elsif Ling = 'DM' then
	    		StrUnid := 'One;Two;Three;Four;Five;Six;Seven;Eight;Nine';
	    		StrPrimaDez := 'Eleven;Twelve;Thirteen;Fourteen;Fifteen;Sixteen;Seventeen;Eighteen;Nineteen';
	    		StrDez := 'Tem;Twenty;Thirty;Forty;Fifty;Sixty;Seventy;Eighty;Ninety';
	    		StrCem := 'One Hundred;Two Hundred;Three Hundred;Four Hundred;Five Hundred;Six Hundred;Seven Hundred;Eight Hundred;Nine Hundred';
	    		StrMil := 'Thousand.Thousand;Million.Millions;Billion.Billions;Trillion.Trillions';
	    		StrCent := 'Cent.Cents';
	    		MOEDA := 'Deutsche Mark;Deutsche Mark;Deutsche Mark';
	    		Sep := ' ';
	    		SepDec := ' and ';
	   		SepMil := ', ';
	    		Esp := ' ';
	    		SepAndTres := ' and ';
		elsif Ling = 'YEN' then
	    		StrUnid := 'One;Two;Three;Four;Five;Six;Seven;Eight;Nine';
	    		StrPrimaDez := 'Eleven;Twelve;Thirteen;Fourteen;Fifteen;Sixteen;Seventeen;Eighteen;Nineteen';
	    		StrDez := 'Tem;Twenty;Thirty;Forty;Fifty;Sixty;Seventy;Eighty;Ninety';
	    		StrCem := 'One Hundred;Two Hundred;Three Hundred;Four Hundred;Five Hundred;Six Hundred;Seven Hundred;Eight Hundred;Nine Hundred';
	    		StrMil := 'Thousand.Thousand;Million.Millions;Billion.Billions;Trillion.Trillions';
	    		StrCent := 'Cent.Cents';
	    		MOEDA := 'Yen;Yen;Yen';
	    		Sep := ' ';
	    		SepDec := ' and ';
	    		SepMil := ', ';
	    		Esp := ' ';
	    		SepAndTres := ' and ';
		else
			return '#Erro';
		end if;
		StrVV := to_char(VV, 'FM000000000000000.00');
		for Z in 1..6 loop
			StrM0 := '';
	    		if Z <> 6 then
		      		StrV0 := substr(StrVV, Z * 3 - 2, 3);
				StrM0 := lmontacento(Strv0, StrCem, Sep, StrDez, StrPrimaDez, StrUnid);
				if not StrM0 is null or Z = 5 then
					if Z < 5 then
						if to_number(StrV0) = 1 then
							StrM0 := StrM0 || Esp || litem(litem(StrMil, 5 - Z, ';'), 1, '.');
						else
	                				StrM0 := StrM0 || Esp || litem(litem(StrMil, 5 - Z, ';'), 2, '.');
						end if;
	            			else
						if to_number(substr(StrVV, 1, 15)) <> 0 then
							if substr(StrVV, 10, 6) = 'FM000000' then
								StrM0 := StrM0 || Esp || litem(Moeda, 3, ';');
							elsif to_number(substr(StrVV, 1, 15)) = 1 then
								StrM0 := StrM0 || Esp || lItem(Moeda, 1, ';');
							elsif to_number(substr(StrVV, 1, 15)) <> 1 then
								StrM0 := StrM0 || Esp || litem(Moeda, 2, ';');
							end if;
	                			end if;
	            			end if;
	        		end if;
	    		else
				StrV0 := 0 || substr(StrVV, 17, 2);
				StrM0 := lmontacento(Strv0, StrCem, Sep, StrDez, StrPrimaDez, StrUnid);
			        if NOT StrM0 is null then
					if to_number(StrV0) = 1 then
	       					StrM0 := StrM0 || ' ' || litem(StrCent, 1, '.');
					else
	       					StrM0 := StrM0 || ' ' || litem(StrCent, 2, '.');
					end if;
				end if;

			end if;
			if not StrM0 is null then
			        if Z = 6 Then
					if not StrMoeda is null then
		            			StrMoeda := StrMoeda ||  SepDec || StrM0;
					else
		            			StrMoeda := StrMoeda || '' || StrM0;
					end if;
	        		else
					if not StrMoeda is null and to_number(StrV0) <> 0 then
						if to_number(StrV0) < 101 Or mod(to_number(StrV0), 100) = 0 then
							StrMoeda := StrMoeda || SepAndTres || StrM0;
						else
							StrMoeda := StrMoeda || SepMil || StrM0;
						end if;
					else
		            			StrMoeda := StrMoeda || '' || StrM0;
					end if;
	        		end if;
	    		end if;
		end loop;
		return StrMoeda;

	exception
		when others then
			raise_application_error ( -20000, 'erro em lextenso: ' || SQLERRM);

	end lextenso;


Function LMontacento (Strv0 in varchar2, StrCem in varchar2, Sep in varchar2, StrDez in varchar2, StrPrimaDez in varchar2, StrUnid in varchar2) return varchar2 is
	Pos number;
	ZZ number;
	StrM0 varchar2(100);
	begin
		for ZZ in 1..3 loop
	   		Pos := to_number(substr(Strv0, ZZ, 1));
			if POS <> 0 then
				if ZZ = 1 then
					StrM0 := StrM0 || litem(StrCem, Pos, ';');
				elsif ZZ = 2 then
					if Pos <> 1 Or substr(StrV0, 3, 1) = 0 then
						if not StrM0 is null then
							StrM0 := StrM0 || Sep || litem(StrDez, Pos, ';');
						else
							StrM0 := StrM0 || '' || litem(StrDez, Pos, ';');
						end if;
					else
						Pos := to_number(substr(StrV0, 3, 1));
						if not StrM0 is null then
							StrM0 := StrM0 || Sep || litem(StrPrimaDez, Pos, ';');
						else
							StrM0 := StrM0 || '' || litem(StrPrimaDez, Pos, ';');
						end if;
						exit;
					end if;

				elsif ZZ = 3 then
					if not StrM0 is null then
						StrM0 := StrM0 || Sep || litem(StrUnid, Pos, ';');
					else
						StrM0 := StrM0 || '' || litem(StrUnid, Pos, ';');
					end if;
				end if;
			end if;
		end loop;
		if StrM0 = 'Cento' then
			StrM0 := 'Cem';
		end if;
		return StrM0;

	exception
		when others then
			raise_application_error ( -20000, 'erro em lmontacento: ' || SQLERRM);

	end lmontacento;


Function LConcatcamp(Dominio in varchar2, Delimit in varchar2) return varchar2 is
	X pls_integer;
	Ret varchar2(4000);
	TextCol dbms_sql.varchar2_table;
	SqlCursor pls_integer;
	NumRows pls_integer;
	begin
		SqlCursor := dbms_sql.open_cursor;
		dbms_sql.parse(SqlCursor, Dominio, dbms_sql.v7);
		dbms_sql.define_array(SqlCursor, 1, TextCol, 10, 1);
		NumRows := dbms_sql.execute(SqlCursor);
		loop
			NumRows := dbms_sql.fetch_rows(SqlCursor);
			dbms_sql.column_value(SqlCursor, 1, TextCol);
			exit when NumRows < 10;
		end loop;
		dbms_sql.close_cursor(SqlCursor);

		Ret := '';
		for X in 1..TextCol.count loop
			if not Ret is null then
				Ret := Ret || Delimit;
			end if;
			Ret := Ret || TextCol(X);
		end loop;
		return Ret;

	exception
		when others then
			raise_application_error ( -20000, 'erro em lconcatcamp: ' || SQLERRM);
	end lconcatcamp;

	function lnumling(Num in number, Masc in varchar2, Ling in varchar2) return varchar2 is
	Result varchar2(1000);
	begin
		Result := to_char(Num, Masc);
		if Ling = 'P' then
			Result := replace(Result, ',', '@');
			Result := replace(Result, '.', ',');
			Result := replace(Result, '@', '.');
		end if;
		return trim(Result);

	exception
		when others then
			raise_application_error ( -20000, 'erro em lnumling: ' || SQLERRM);
	end lnumling;




        function LInsereEspaco(Str in varchar2, Tamanho in number) return varchar2 is
       	Result varchar2(1000);
        i number;
	begin
	            Result := Str;
		    if  Tamanho > (length(Result)) then
                        for i in 1..(tamanho - length(Result))  Loop begin
                            Result := CHR(32) || Result;
                            end;
			end loop;
		    end If;

		return Result;

	exception
		when others then
			raise_application_error ( -20000, 'erro em LinsereEspaco: ' || SQLERRM);
	end LinsereEspaco;


Procedure LExecutaString(cmdSql in Varchar) is
nresult integer;
Ccmd integer;
cmdExec varchar(32767);
begin
	cmdExec:=cmdSql;
	Ccmd:=sys.DBMS_SQL.OPEN_CURSOR;
	sys.dbms_sql.parse(Ccmd,cmdExec,DBMS_SQL.NATIVE);
	nresult:=sys.dbms_sql.execute(Ccmd);
	sys.dbms_sql.close_cursor(Ccmd);
EXCEPTION
	WHEN OTHERS THEN
	cmdExec:='';
end LExecutaString;

Function LExibeData(Momento in Date, Formato in Varchar2 default '') return Varchar2 is
  vDia Integer;
  vMes Integer;
  vAno Integer;
  vHora Integer;
  vMinuto Integer;
  vSegundo Integer;
  vMesExtPt Varchar2(200);
  vMesExtEn Varchar2(200);
  vMesExtEs Varchar2(200);
  Vsuf Integer;
  vCondicao Varchar2(2);
Begin
  vDia := Extract(day from Momento);
  vMes := Extract(Month from Momento);
  vAno := Extract(Year from Momento);
  vHora := EXTRACT(HOUR FROM TO_TIMESTAMP(Momento));
  vMinuto := EXTRACT(MINUTE FROM TO_TIMESTAMP(Momento));
  vSegundo := EXTRACT(SECOND FROM TO_TIMESTAMP(Momento));
  vMesExtPt := 'Janeiro,Fevereiro,Março,Abril,Maio,Junho,Julho,Agosto,Setembro,Outubro,Novembro,Dezembro';
  vMesExtEn := 'January,February,March,April,May,June,July,August,September,October,November,December';
  vMesExtEs := 'Enero,Febrero,Marzo,Abril,Mayo,Junio,Julio,Agosto,Septiembre,Octubre,Noviembre,Diciembre';
  vSuf := vDia mod 10;
  if (vDia > 10) And (vDia < 14 ) then
    vCondicao := 'th';
  elsif vSuf = 1 then
    vCondicao := 'st';
  elsif vSuf = 2 then
    vCondicao := 'nd';
  elsif vSuf = 3 then
    vCondicao := 'rd';
  else
    vCondicao := 'th';
  end if;
  case
    when (Formato = 'sd') then Return to_char(Momento,'DD/MM/YYYY'); -- Simples Data DD/MM/YYYY
    when (Formato = 'sh') then Return to_char(Momento,'TS'); -- Simples Hora 24H:MI:SS
    when (Formato = 'p') or (Formato = 'dd de mmmm de yyyy') then Return vDia || ' de ' || lb.Litem(vMesExtPt,vMes,',') || ' de ' || vAno;
    when (Formato = 'c') or (Formato = 'dd de mmmm de yyyy c') then Return vDia || ' de ' || lb.Litem(vMesExtEs,vMes,',') || ' de ' || vAno;
    when (Formato = 'i') or (Formato = 'mmmm dth, yyyy') or (Formato = 'mmmm dth yyyy') then Return lb.Litem(vMesExtEn,vMes,',') || ' ' || vDia || vCondicao || ', ' || vAno;
    when (Formato = 'a') or (Formato = 'dd mmm yyyy') then Return substr(lb.Litem(vMesExtEn,vMes,','),1,3) || ' ' || vDia || vCondicao || ', ' || vAno;
    when (Formato = 'ai') or (Formato = 'dd mmm yyyy i') then Return lPad(vDia,2,'0') || ' ' || upper(lb.Litem(vMesExtEn,vMes,',')) || ', ' || lPad(vAno,4,'0');
    when (Formato = 'mmm dd, yyyy') or (Formato = 'mmm dd yyyy') then Return substr(upper(lb.Litem(vMesExtPt,vMes,',')),1,3) || ' ' || vDia ||  ', ' || lPad(vAno,4,'0');
    when (Formato = 'mmm dd, yyyy i') or (Formato = 'mmm dd yyyy i') then Return substr(upper(lb.Litem(vMesExtEn,vMes,',')),1,3) || ' ' || vDia ||  ', ' || lPad(vAno,4,'0');
    when (Formato = 'mmm dd, yyyy c') or (Formato = 'mmm dd yyyy c') then Return substr(upper(lb.Litem(vMesExtEs,vMes,',')),1,3) || ' ' || vDia ||  ', ' || lPad(vAno,4,'0');
    when (Formato = 'mmmm, yyyy') or (Formato = 'mmmm yyyy') then Return lb.Litem(vMesExtPt,vMes,',') || ', ' || lPad(vAno,4,'0');
    when (Formato = 'mmmm, yyyy i') or (Formato = 'mmmm yyyy i') then Return lb.Litem(vMesExtEn,vMes,',') || ', ' || vAno;
    when (Formato = 'mmmm, yyyy c') or (Formato = 'mmmm yyyy c') then Return lb.Litem(vMesExtEs,vMes,',') || ', ' || vAno;
    when (Formato = 'mmmm/yy') or (Formato = 'mmmm yy') then Return lb.Litem(vMesExtPt,vMes,',') || '/' || substr(vAno,3,2);
    when (Formato = 'mmm') then Return substr(upper(lb.Litem(vMesExtPt,vMes,',')),1,3);
    when (Formato = 'mmm i') then Return substr(upper(lb.Litem(vMesExtEn,vMes,',')),1,3);
    when (Formato = 'mmm c') then Return substr(upper(lb.Litem(vMesExtEs,vMes,',')),1,3);
    when (Formato = 'mmmm') then Return lb.Litem(vMesExtPt,vMes,',');
    when (Formato = 'mmmm i') then Return lb.Litem(vMesExtEn,vMes,',');
    when (Formato = 'mmmm c') then Return lb.Litem(vMesExtEs,vMes,',');
    when (Formato = 'yyyy') then Return lPad(vAno,4,'0');
  else
    Return vDia || '/' || vMes || '/' || vAno || ' ' || vHora  || ':' || vMinuto || ':' || vSegundo;
  end case;

end LExibeData;

--------------------------------------------------------------------------------------------------------------
-- Procedimento para criação de jobs(tarefas) a serem executadas periodicamente no Oracle
--------------------------------------------------------------------------------------------------------------
Procedure LCria_Job(vNomeJob in varchar2,vProced in varchar2, vHoraExec in varchar2,vIntervaloHoras in varchar2 default '24') as job binary_integer;
begin
   begin
     for cur in (select job from user_jobs where what like '% ' || vNomeJob || ' %') loop
        dbms_job.remove(cur.job);
     end loop;
   exception
     when others then
       null;
   end;
   dbms_job.submit(job, '/* ' || vNomeJob || ' */begin ' || vProced || ';end;',to_date('' || to_char(sysdate,'DD/MM/YYYY') || ' ' || VHoraExec ||'','DD/MM/YYYY HH24:MI:SS'), 'TRUNC(SYSDATE + 1) + ' || vIntervaloHoras || ' / 24');
end LCria_Job;

Procedure LCria_Job_N(vNomeJob in varchar2, vProced in varchar2, vHoraExec in varchar2, vIntervaloDias in number default '1', vIntervalo in number default '1', vMetodo in VARCHAR2 default 'd') as
  job binary_integer;
  vMet Varchar2(30);
begin
   begin
     for cur in (select job from user_jobs where what like '% ' || vNomeJob || ' %') loop
        dbms_job.remove(cur.job);
     end loop;
   exception
     when others then
       null;
   end;
   case
     when vMetodo = 's' then vMet := 'SYSDATE + ' || vIntervalo || '/86400'; -- Intervalo em Segundos
     when vMetodo = 'm' then vMet := 'SYSDATE + ' || vIntervalo || '/1440'; -- Intervalo em Minutos
     when vMetodo = 'h' then vMet := 'SYSDATE + ' || vIntervalo || '/24'; -- Intervalo em Horas
     when vMetodo = 'd' then vMet := 'TRUNC(SYSDATE + '|| vIntervaloDias || ') + ' || vIntervalo || '/24'; -- Intervalo em Horas
     when vMetodo = 'x' then vMet := 'TRUNC(LAST_DAY(SYSDATE) + 1) + ' || vIntervalo || '/24'; -- Todo 1 dia do Mês
     when vMetodo = '2' then vMet := 'NEXT_DAY(TRUNC(SYSDATE), ''Monday'') + ' || vIntervalo || '/24)'; -- Tda Segunda na Hora Especificada
     when vMetodo = '3' then vMet := 'NEXT_DAY(TRUNC(SYSDATE), ''Tuesday'') + ' || vIntervalo || '/24)'; -- Tda Segunda na Hora Especificada
     when vMetodo = '4' then vMet := 'NEXT_DAY(TRUNC(SYSDATE), ''Wednesday'') + ' || vIntervalo || '/24)'; -- Tda Segunda na Hora Especificada
     when vMetodo = '5' then vMet := 'NEXT_DAY(TRUNC(SYSDATE), ''Thursday'') + ' || vIntervalo || '/24)'; -- Tda Segunda na Hora Especificada
     when vMetodo = '6' then vMet := 'NEXT_DAY(TRUNC(SYSDATE), ''Friday'') + ' || vIntervalo || '/24)'; -- Tda Segunda na Hora Especificada
     when vMetodo = 'S' then vMet := 'NEXT_DAY(TRUNC(SYSDATE), ''Saturday'') + ' || vIntervalo || '/24)'; -- Tda Segunda na Hora Especificada
     when vMetodo = 'D' then vMet := 'NEXT_DAY(TRUNC(SYSDATE), ''Sunday'') + ' || vIntervalo || '/24)'; -- Tda Segunda na Hora Especificada
   end case;
   dbms_job.submit(job, '/* ' || vNomeJob || ' */begin ' || vProced || ';end;',to_date('' || to_char(sysdate,'DD/MM/YYYY') || ' ' || VHoraExec ||'','DD/MM/YYYY HH24:MI:SS'), vMet);
end LCria_Job_N;

--------------------------------------------------------------------------------------------------------------
-- Procedimento para exclusão de jobs(tarefas) no Oracle
--------------------------------------------------------------------------------------------------------------
procedure LApaga_Job(vNomeJob in varchar2) as job binary_integer;
begin
  begin
    for cur in (select job from user_jobs where what like '% ' || vNomeJob || ' %') loop
      dbms_job.remove(cur.job);
    end loop;
  end;
end LApaga_Job;

--------------------------------------------------------------------------------------------------------------
-- Procedimento para compilar objetos 
--------------------------------------------------------------------------------------------------------------
Procedure LCompObjetos is
begin
  for cur in (SELECT 'ALTER '|| object_type || ' ' ||  OWNER || '.' || object_name ||' COMPILE;' as COMP FROM all_objects WHERE  status = 'INVALID' and OWNER <> 'PUBLIC'  ORDER BY owner, object_type, object_name) loop
    execute immediate '' || cur.comp || '';  
  end loop;
end;

end lb;
/

-- OBJETO 202 | PACKAGE | RSBD
create or replace PACKAGE rsbd as
 Procedure AtualizaDelegados;
 Procedure TransfereMembros(Orgao in Varchar,Remanegado in varchar,NovoPosto in Varchar,Gestao in Date,qtRemanejado in number,Promover in boolean);
end;
/

create or replace PACKAGE BODY rsbd is
-----------------------------------------------------------------------------------------------------------------
--Gerencia a Transferancia de postos entre delegados e delegados suplenets
-----------------------------------------------------------------------------------------------------------------
Procedure AtualizaDelegados is
  nDivisor number;
  nSocio number;
  dGestao Date;
  nRemanejado number;
begin

  begin
    Select divisor into nDivisor from sbdb.cargo where cargo = 'DELEGADOS';
  exception
      when no_data_found then
            nDivisor := 1;
  end;

  FOR cQtSocios in (SELECT 'DIRETORIA ' || REGIONAL_COD as DIRETORIA, TRUNC (COUNT (MAT) / nDivisor) as Permitido  FROM SBDB.SÓCIO  WHERE EXCLUÍDO = 0 AND (OBRIG_STATUS_COD LIKE 'QUITE%' OR OBRIG_STATUS_COD LIKE 'ISENTO%') group by regional_cod order by REGIONAL_COD)  LOOP
    BEGIN

      begin
        select Nvl(COUNT (SÓCIO_MAT),0), max(ÓRGÃO_GESTÃO_INI) into nSocio, dGestao from sbdb.órgão_membro where órgão_nome = cQtSocios.DIRETORIA AND ÓRGÃO_CARGO = 'DELEGADOS' AND ÓRGÃO_GESTÃO_INI = (SELECT MAX (ÓRGÃO_GESTÃO_INI) from sbdb.órgão_membro where órgão_nome = cQtSocios.DIRETORIA ) GROUP BY ÓRGÃO_NOME, ÓRGÃO_GESTÃO_INI;
      exception
        when NO_DATA_FOUND then
          nSocio := 0;
          SELECT MAX (ÓRGÃO_GESTÃO_INI) into dGestao from sbdb.órgão_membro where órgão_nome = cQtSocios.DIRETORIA;
      end;

      nRemanejado := cQtSocios.Permitido - nSocio;

      --Se nRemanejado for:
        --Maior que zero então os Delegados Suplentes serão remanejados para Delegados
        --Menor que zero então os Delegados serão remanejados para Delegados  Suplentes
        --Igual a zero nada acontece

      if nRemanejado > 0 then
        TransfereMembros (cQtSocios.DIRETORIA, 'DELEGADOS SUPLENTES', 'DELEGADOS', dGestao, nRemanejado, TRUE) ;
      elsif nRemanejado < 0 then
        TransfereMembros (cQtSocios.DIRETORIA, 'DELEGADOS', 'DELEGADOS SUPLENTES', dGestao, ABS(nRemanejado), FALSE) ;
      end if;

    END;

  END LOOP;

end AtualizaDelegados;

----------------------------------------------------------------------------------------------------------------------
-- Faz a Transferencia de menbros entre os ponstos enformados
----------------------------------------------------------------------------------------------------------------------
Procedure TransfereMembros (Orgao in Varchar, Remanegado in varchar, NovoPosto in Varchar, Gestao in Date, qtRemanejado in number, Promover  in Boolean)  is
  EFalTaPosto EXCEPTION;
  PRAGMA EXCEPTION_INIT (EFalTaPosto, - 2291) ;
  cMembrosID integer;
  strsql     varchar (500) ;
  nOrdem órgão_membro.ordem%type;
  nMat órgão_membro.sócio_mat%type;
  nResult   integer;
  nLoop     integer;
  nLoopA     integer;
  nLoopB     integer;
  nLoopC     integer;
  NovaOrdem nUMBER (3) ;
  iPosto    varchar (50) ;
  nDif     integer;
begin

  select nvl(max (ORDEM),0) into NovaOrdem from sbdb.órgão_membro where órgão_nome = orgao AND ÓRGÃO_CARGO = NovoPosto AND ÓRGÃO_GESTÃO_INI = gestao;

  IF Promover THEN
    nLoopA := 1;
    for Cur_A in (select DISTINCT ORDEM, SÓCIO_MAT,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI from sbdb.órgão_membro where órgão_nome = Orgao AND ÓRGÃO_CARGO = Remanegado AND ÓRGÃO_GESTÃO_INI = Gestao GROUP BY ORDEM, SÓCIO_MAT,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI ORDER BY ORDEM) Loop
      NovaOrdem := NovaOrdem + 1;
      UPDATE SBDB.ÓRGÃO_MEMBRO SET ÓRGÃO_CARGO = NovoPosto, ORDEM = NovaOrdem, sys_status = 'X'  where sócio_mat = Cur_A.SÓCIO_MAT AND Órgão_Cargo = Cur_A.ÓRGÃO_CARGO AND ÓRGÃO_GESTÃO_INI = Cur_A.ÓRGÃO_GESTÃO_INI;
      if nLoopA >= qtRemanejado then
        exit;
      end if;
      nLoopA := nLoopA + 1;
    end loop;
  ELSE
    nLoopB := 1;

    for Cur_B in (select DISTINCT ORDEM, SÓCIO_MAT,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI from sbdb.órgão_membro where órgão_nome = Orgao AND ÓRGÃO_CARGO = NovoPosto AND ÓRGÃO_GESTÃO_INI = Gestao GROUP BY ORDEM, SÓCIO_MAT,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI ORDER BY ORDEM) Loop
      UPDATE SBDB.ÓRGÃO_MEMBRO SET ORDEM = ORDEM + qtRemanejado, sys_status = 'X'  where sócio_mat = Cur_B.SÓCIO_MAT AND ordem = nLoopB and Órgão_Cargo = Cur_B.ÓRGÃO_CARGO AND ÓRGÃO_GESTÃO_INI = Cur_B.ÓRGÃO_GESTÃO_INI;
      nLoopB := nLoopB + 1;
    end loop;

    COMMIT;

    nLoopC := 1;

    for Cur_C in (select DISTINCT ORDEM, SÓCIO_MAT, ÓRGÃO_CARGO, ÓRGÃO_GESTÃO_INI from sbdb.órgão_membro where órgão_nome = Orgao AND ÓRGÃO_CARGO = Remanegado AND ÓRGÃO_GESTÃO_INI = Gestao GROUP BY ORDEM, SÓCIO_MAT,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI ORDER BY ORDEM DESC) Loop
      UPDATE SBDB.ÓRGÃO_MEMBRO SET ÓRGÃO_CARGO = NovoPosto, ORDEM = nLoopC, sys_status = 'X'  where sócio_mat = Cur_C.SÓCIO_MAT AND Órgão_Cargo = Cur_C.ÓRGÃO_CARGO AND ÓRGÃO_GESTÃO_INI = Cur_C.ÓRGÃO_GESTÃO_INI;
      if nLoopC >= qtRemanejado then
        exit;
      end if;
      nLoopC := nLoopC + 1;
    end loop;

  END IF;

  COMMIT;

  if promover then
    iposto := Remanegado;
  else
    iposto := NovoPosto;
  end if;

  nloop   := 1;

  for Cur_D in (select DISTINCT ORDEM, SÓCIO_MAT,órgão_nome,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI from sbdb.órgão_membro where órgão_nome = Orgao AND ÓRGÃO_CARGO = iposto AND ÓRGÃO_GESTÃO_INI = Gestao GROUP BY ORDEM, SÓCIO_MAT,órgão_nome,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI ORDER BY ORDEM) Loop

    UPDATE SBDB.ÓRGÃO_MEMBRO SET ORDEM = nLoop, sys_status = 'X'  where sócio_mat = Cur_D.SÓCIO_MAT AND Órgão_Cargo = Cur_D.ÓRGÃO_CARGO AND ÓRGÃO_GESTÃO_INI = Cur_D.ÓRGÃO_GESTÃO_INI;

    nLoop := nLoop + 1;

  End Loop;

  COMMIT;

EXCEPTION
  when others then
    raise_application_error(-20000, 'Erro ao Transferir Delegado - ' || SQLERRM);
    SENDMAIL('WEB@SBD.ORG.BR','lucianol@icraft.com.br','Log SBD - Erro ao Transferir Delegado',SQLERRM);
    ROLLBACK;
end TransfereMembros;

end RSBD;
/

-- OBJETO 203 | PACKAGE | LSBD
create or replace PACKAGE "LSBD" is
  Function  LSocio_Isento (nMat in number) Return varchar2;
  Function  LPrimLetraMaius(TEXTO in Varchar2) Return varchar2;
  Function  LVal_CPF(CPF VARCHAR2) Return Varchar2;
  Function  LDif_Data (max_date STRING, min_date STRING) RETURN PLS_INTEGER;
  Function  DIA_UTIL(vData in date) RETURN string;
  Function  LMaiusculaSemAcento(CAMPO in Varchar2) Return varchar2;
  Procedure LSocio_Status (nMat in number, bTrigger in boolean default false);
  Procedure LObrigacao_Status (nMat in number,Atualiza in boolean default FALSE);
  Procedure LAltera_Categoria;
  Procedure LAtualiza_Obrig_Status (Atualiza in boolean default FALSE);
  Procedure LAtualiza_Socio_Status (Atualiza in boolean default FALSE);
  Procedure LExclui_Parcelas(nMat in number);
  Procedure LAtualiza_Licenciados;
  Procedure LAtualiza_Penalizado;
  PROCEDURE LBiblio_Despesas(vAnuidade in Varchar2);
  Function LValidaEmail(email varchar2) return varchar2;
  Procedure LAtualiza_Geral;
end;
/


 create or replace
PACKAGE BODY lsbd is
----------------------------------------------------------------------------------------------------
-- Procedimento para excluir as parcelas
----------------------------------------------------------------------------------------------------
Procedure LExclui_Parcelas(nMat in number)  is
  nComp Integer;
  vMat Number;
begin
  nComp := 0;
  vMat := nMat;
  SELECT COUNT(SEQ) INTO nComp FROM SBDB.OBRIGAÇÃO WHERE OBRIG_STATUS_COD = 'VENCIDA'  AND INSTR(OBRIG_TIPO,'ANUIDADE-PARCELA') <> 0 AND SÓCIO_MAT = vMat AND (TO_DATE(TO_CHAR(SYSDATE,'DD/MM/YYYY'),'DD/MM/YYYY') - TO_DATE(TO_CHAR((SELECT DATA_LIMITE_VENCIMENTO+DIAS_VALIDADE FROM SBDB.PARAMETRO_FINANCEIRO WHERE ANUIDADE = TO_CHAR(SYSDATE,'YYYY')),'DD/MM/YYYY'),'DD/MM/YYYY') > 1);
  if nComp >= 3 then
    DELETE FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = vMat AND OBRIG_TIPO LIKE 'ANUIDADE-PARCELA%' AND TO_CHAR(COMPETÊNCIA,'YYYY') = TO_CHAR(SYSDATE,'YYYY');
  end if;
exception
  when others then
    raise_application_error(-20000, 'Erro em LExclui_Parcelas - ' || SQLERRM);
end LExclui_Parcelas;
--------------------------------------------------------------------------------------------------------------
-- Altera a categoria dos sócios ASPIRANTES, com 5 anos de cadastro, para sócios CONTRIBUINTES.
--------------------------------------------------------------------------------------------------------------
Procedure LAltera_Categoria is
  nCategSeq number;
begin
  -- Seleciona os sócio ASPIRANTES com 5 anos(1826 dias) entre a data de cadastro e a data atual.
  -- Atualiza a categoria para CONTRIBUINTE, e insere na tabela de SÓCIO_CATEGORIA com a Obs. "ALTERAÇÃO DE CATEGORIA CONFORME ESTATUTO".
  for Cur in (SELECT MAT,CATEGORIA_COD,DATA_CADASTRO FROM SBDB.SÓCIO WHERE CATEGORIA_COD = 'ASPIRANTE' AND ABS(TRUNC(SYSDATE - DATA_CADASTRO)) >= 2190 ORDER BY MAT) loop
    SELECT NVL(MAX(SEQ),0)+ 1 AS SEQ INTO nCategSeq FROM SBDB.SÓCIO_CATEGORIA WHERE SÓCIO_MAT = Cur.MAT;
    UPDATE SBDB.SÓCIO SET CATEGORIA_COD = 'CONTRIBUINTE', SYS_STATUS = 'X' WHERE MAT = Cur.MAT;
    INSERT INTO SÓCIO_CATEGORIA (SÓCIO_MAT,CATEGORIA_COD,SEQ,DATA_ALTERAÇÃO,OBS) VALUES (Cur.MAT,'CONTRIBUINTE',nCategSeq,TO_DATE(TO_CHAR(Cur.DATA_CADASTRO,'DD/MM')||'/'||TO_CHAR(SYSDATE,'YYYY'),'dd/mm/yyyy'),'ALTERAÇÃO DE CATEGORIA CONFORME NOVO ESTATUTO (6 ANOS)');
  end loop;
  Commit;
exception
  when others then
    raise_application_error(-20000, 'Erro em LAltera_Categoria - ' || SQLERRM);
end LAltera_Categoria;

--------------------------------------------------------------------------------------------------------------
-- Procedimento para atualizar o status(FIN) das obrigações pertinentes aos sócios
---------------------------------------------------------------------------------------------------------------
Procedure LAtualiza_Obrig_Status(Atualiza in boolean default FALSE) is
  nI NUMBER;
--  nMat NUMBER;
Cursor CurSocio IS SELECT MAT FROM SBDB.SÓCIO WHERE MAT > 0 AND EXCLUÍDO = 0 ORDER BY MAT;
Begin
  nI := 0;
  for Cur in CurSocio loop
--     nMAT := CUR.MAT;
    LSBD.LOBRIGACAO_STATUS(CUR.MAT, Atualiza);
    nI := nI + 1;
  end loop;
  Commit;
exception
  when others then
  begin
    Close CurSocio;
    raise_application_error(-20000, 'Erro em LAtualiza_Obrig_Status - ' || SQLERRM);
  end;
end LAtualiza_Obrig_Status;
--------------------------------------------------------------------------------------------------------------
-- Altera o Status da Obrigação de acordo com o pagamento realizado.
--------------------------------------------------------------------------------------------------------------
Procedure LObrigacao_Status(nMat in number, Atualiza in boolean default FALSE) is
  -- Declaração do cursor
  CURSOR CUR_OBRIGPAG IS
        SELECT O.SÓCIO_MAT,
               O.SEQ,
               O.DATA_LANÇAMENTO,
               O.DATA_VENCIMENTO,
               ROUND(NVL(O.VALOR,0),2) AS OBRIG_VALOR,
               DECODE(P.DATA,NULL, TO_NUMBER(TO_CHAR(O.DATA_VENCIMENTO,'J'))-TO_NUMBER(TO_CHAR(SYSDATE,'J')), TO_NUMBER(TO_CHAR(O.DATA_VENCIMENTO,'J')) - TO_NUMBER(TO_CHAR(P.DATA,'J'))) AS DIAS_ATRASO,
               RTRIM(LTRIM(O.OBRIG_TIPO)) AS TIPO,
               O.COMPETÊNCIA,
               O.OBRIG_STATUS_COD,
               P.DATA AS PAG_DATA,
               ROUND(NVL(P.VALOR,0),2) AS PAG_VALOR,
               ROUND(NVL(P.DESCONTO,0),2) AS PAG_DESC,
               ROUND(NVL(P.MULTA,0),2) AS PAG_MULTA
        FROM SBDB.OBRIGAÇÃO O,SBDB.PAGAMENTO P
        WHERE ((O.OBRIG_STATUS_COD NOT IN ('SUBSTITUIDA','CANCELADA')) OR
                O.OBRIG_STATUS_COD IS NULL) AND
                P.OBRIG_SEQ(+) = O.SEQ AND
                P.SÓCIO_MAT(+) = O.SÓCIO_MAT AND
                O.SÓCIO_MAT = nMat
        GROUP BY O.SÓCIO_MAT,O.SEQ,O.DATA_LANÇAMENTO,
                O.DATA_VENCIMENTO,O.VALOR,O.OBRIG_TIPO,p.data,
                p.valor,P.DESCONTO,P.MULTA,P.JUROS,
                O.COMPETÊNCIA,O.OBRIG_STATUS_COD
        ORDER BY O.SEQ;
  -- Declaração das variáveis
  vSocioMat         SBDB.OBRIGAÇÃO.SÓCIO_MAT%type;
  vSeq              SBDB.OBRIGAÇÃO.SEQ%type;
  vObrigStatus      SBDB.OBRIGAÇÃO.OBRIG_STATUS_COD%type;
  vObrigStatusCod   SBDB.OBRIGAÇÃO.OBRIG_STATUS_COD%type;
  vPagValDesc       SBDB.PAGAMENTO.DESCONTO%type;
  vAnuidade         varchar2(4);
  vAnuidade_Vigente varchar2(4);
  vLog_Obrig_Status CLOB;
  vData_Limite      date;
  vPagData          Date;
  vPagDataVenc      Date;
  vPagValor         Float;
  vValPgto          Float;
  vObrigValor       Float;
  vCompetencia      Date;
  vDiaAtraso        Float;
  vTipo             SBDB.OBRIGAÇÃO.OBRIG_TIPO%type;
  vPagDesc          Float;
  vPagValMulta      Float;
  vDiasTolerancia   Integer;
  VDataTolerancia   Date;
  VDataVencToler    Date;
  vData_Atual       Date;
  vOP               Integer;
  vSocioT           Integer;
begin
  -- Cursor para seleção das obrigações e pagamentos do sócio.
  vAnuidade_Vigente := TO_CHAR(SYSDATE,'YYYY');
  vData_Atual := SYSDATE;
  --vData_Atual := TO_DATE('10/05/2008','DD/MM/YYYY');
  FOR vOP in CUR_OBRIGPAG
  LOOP
    vSocioMat       := vOP.SÓCIO_MAT;
    vSeq             := vOP.SEQ;
    vAnuidade       := TO_CHAR(vOP.COMPETÊNCIA,'YYYY');
    vCompetencia    := vOP.COMPETÊNCIA;
    vPagData        := vOP.PAG_DATA;
    vPagValor       := vOP.PAG_VALOR;
    vPagValDesc     := vOP.PAG_DESC;
    vPagValMulta    := vOP.PAG_MULTA;
    vPagDataVenc    := vOP.DATA_VENCIMENTO;
    vObrigValor     := vOP.OBRIG_VALOR;
    vValPgto        := vPagValor + vPagValDesc - vPagValMulta;
    vTipo           := vOP.TIPO;
    vDiaAtraso      := vOP.DIAS_ATRASO;
    vObrigStatus    := '';
    select DATA_LIMITE_VENCIMENTO, DIAS_VALIDADE INTO vData_Limite, vDiasTolerancia FROM SBDB.PARAMETRO_FINANCEIRO WHERE ANUIDADE = vAnuidade;
    VDataTolerancia := vData_Limite + vDiasTolerancia;
    VDataVencToler  := vPagDataVenc + vDiasTolerancia;
    --SE A DATA DE PAGAMENTO FOR NULA SIGNIFICA QUE NÃO EXISTE PAGAMENTO
    if vTipo <> 'PARCELAMENTO' then
      if vTipo = 'ANUIDADE' then
        if (vOP.PAG_DATA IS NULL) then
          -- OBS: FOI ASSUMIDO QUE EXISTIRÁ UM DATA DE VENCIMENTO ÚNICA TANTO PARA AS PARCELAS QUANTO PARA COTA ÚNICA, TEREI QUE COLOCAR UMA CONSULTA PARA PEGAR NA TABELA PARÂMETRO A DATA INFORMADA E COMPARAR COM A DATA DE VENCIMENTO, ASSIM FICARIA:
          if (TO_DATE(TO_CHAR(vData_Atual,'DD/MM/YYYY'),'DD/MM/YYYY')) <= (TO_DATE(TO_CHAR(VDataVencToler,'DD/MM/YYYY'),'DD/MM/YYYY')) then
            vObrigStatus := 'EM ABERTO';
          else
            vObrigStatus := 'VENCIDA';
          end if;
        else
          -- SEGUINDO A OBSERVAÇÃO ACIMA A CONDIÇÃO ACIMA:
          if (vObrigValor) <= (vValPgto) then
            vObrigStatus := 'BAIXADA';
          else
            vObrigStatus := 'EM ABERTO';
          end if;
        end if;
     else
        if (vOP.PAG_DATA IS NULL) then
          -- OBS: FOI CRIADO ESSA ALTERNATIVA PARA A ADRIANA UTILIZAR O TIPO ANUIDADE COM VALORES NÃO FIXADOS NA CATEGORIA:
          if (TO_DATE(TO_CHAR(vData_Atual,'DD/MM/YYYY'),'DD/MM/YYYY')) <= (TO_DATE(TO_CHAR(vPagDataVenc,'DD/MM/YYYY'),'DD/MM/YYYY')) then
            vObrigStatus := 'EM ABERTO';
          else
            vObrigStatus := 'VENCIDA';
          end if;
        else
          -- SEGUINDO A OBSERVAÇÃO ACIMA A CONDIÇÃO ACIMA:
          if (vObrigValor) <= (vValPgto) then
            vObrigStatus := 'BAIXADA';
          else
            vObrigStatus := 'EM ABERTO';
          end if;
        end if;
      end if;
    else
      if (vOP.PAG_DATA IS NULL) then
        -- OBS: FOI ASSUMIDO QUE EXISTIRÁ UM DATA DE VENCIMENTO ÚNICA TANTO PARA AS PARCELAS QUANTO PARA COTA ÚNICA, TEREI QUE COLOCAR UMA CONSULTA PARA PEGAR NA TABELA PARÂMETRO A DATA INFORMADA E COMPARAR COM A DATA DE VENCIMENTO, ASSIM FICARIA:
        if (TO_DATE(TO_CHAR(vData_Atual,'DD/MM/YYYY'),'DD/MM/YYYY')) <= (TO_DATE(TO_CHAR(vPagDataVenc,'DD/MM/YYYY'),'DD/MM/YYYY')) then
          vObrigStatus := 'EM ABERTO';
        else
          vObrigStatus := 'VENCIDA';
        end if;
      else
        -- SEGUINDO A OBSERVAÇÃO ACIMA A CONDIÇÃO ACIMA:
        if (vObrigValor) <= (vValPgto) then
          vObrigStatus := 'BAIXADA';
        else
          vObrigStatus := 'EM ABERTO';
        end if;
      end if;
    end if;
    if Atualiza then
      UPDATE SBDB.OBRIGAÇÃO SET OBRIG_STATUS_COD = vObrigStatus WHERE SÓCIO_MAT = vSocioMat AND SEQ = vSeq;
    ELSE
      UPDATE SBDB.OBRIGAÇÃO SET OBRIG_STATUS_COD = vObrigStatus, SYS_STATUS = 'X' WHERE SÓCIO_MAT = vSocioMat AND SEQ = vSeq;
    END IF;
  end loop;
  -- VARIÁVEL QUE ARMAZENARÁ OS DADOS QUE IRÃO PARA A TABELA SÓCIO
  vLog_Obrig_Status := vLog_Obrig_Status ||'['|| vAnuidade ||'|('|| TO_CHAR(vObrigValor) ||')-('|| TO_CHAR(vValPgto) ||')='||TO_CHAR((vObrigValor)-(vValPgto)) ||'|'|| vObrigStatus ||'] ';
  LExclui_Parcelas(nMat);
  -- ATUALIZA O CAMPO SYS_LOG_STATUS_COD PARA PODER SER CHECADO SE O STATUS DA OBRIGAÇÃO VERÍDICO
  UPDATE SBDB.SÓCIO SET OBRIG_STATUS_LOG = vLog_Obrig_Status, SYS_STATUS = 'X' WHERE MAT = vSocioMat;
exception
  when others then
  begin
    Close CUR_OBRIGPAG;
    raise_application_error(-20000, 'Erro em LObrigacao_Status - ' || SQLERRM);
  end;
end LObrigacao_Status;

--------------------------------------------------------------------------------------------------------------
-- Procedimento para atualizar o status(FIN) de todos sócio
--------------------------------------------------------------------------------------------------------------
Procedure LAtualiza_Socio_Status(Atualiza in boolean default FALSE) is
  Cursor CurSocio IS SELECT MAT FROM SBDB.SÓCIO WHERE MAT > 0 AND EXCLUÍDO = 0 ORDER BY MAT;
  Begin
    for Cur in CurSocio loop
      LSBD.LSOCIO_STATUS(CUR.MAT , Atualiza);
      commit;
    end loop;
  exception
    when others then
    begin
      Close CurSocio;
      raise_application_error(-20000, 'Erro em LAtualiza_Socio_Status - ' || SQLERRM);
    end;
end LAtualiza_Socio_Status;

-------------------------------------------------------------------------------------------------------------
-- Altera o Status do sócio de acordo com os status das obrigações.
--------------------------------------------------------------------------------------------------------------
Procedure LSocio_Status(nMat in number, bTrigger in boolean default false) is
  vStatus SBDB.SÓCIO.OBRIG_STATUS_COD%type;
  vObrigStatusCod SBDB.SÓCIO.OBRIG_STATUS_COD%type;
  vDataAtual date;
  vDataLimite date;
  vDataTolerancia date;
  vCompetenciaAtual Varchar2(4);
  vDiasValidade number;
  nS number;
begin
  vStatus := '';
  vObrigStatusCod := '';
  nS := 0;
  vDataAtual := TO_DATE(LB.LExibeData(SYSDATE,'sd'),'DD/MM/YYYY');
  --vDataAtual := TO_DATE('01/01/2011','DD/MM/YYYY');
  SELECT TO_DATE(TO_CHAR(DATA_LIMITE_VENCIMENTO,'DD/MM/YYYY'),'DD/MM/YYYY'), TO_DATE(TO_CHAR(DATA_LIMITE_VENCIMENTO + DIAS_VALIDADE,'DD/MM/YYYY'),'DD/MM/YYYY'),DIAS_VALIDADE INTO vDataLimite, vDataTolerancia, vDiasValidade FROM SBDB.PARAMETRO_FINANCEIRO WHERE ANUIDADE = (SELECT MAX(ANUIDADE) FROM SBDB.PARAMETRO_FINANCEIRO) ;
  --SELECT TO_CHAR(SYSDATE,'YYYY') INTO vCompetenciaAtual FROM DUAL;
  SELECT MAX(ANUIDADE) INTO vCompetenciaAtual FROM SBDB.PARAMETRO_FINANCEIRO;
  SELECT OBRIG_STATUS_COD INTO vObrigStatusCod FROM SBDB.SÓCIO WHERE MAT = nMat;
  select
  decode((SELECT MAT FROM SBDB.SÓCIO WHERE MAT = nMat AND MAT NOT IN (SELECT SÓCIO_MAT FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat GROUP BY SÓCIO_MAT) AND LSBD.LSOCIO_ISENTO(MAT) IS NULL),NULL,
  decode((SELECT LSBD.LSOCIO_ISENTO(nMat) FROM DUAL),NULL,
  decode((SELECT SOCIO_MAT FROM SBDB.HISTORICO_LICENCIADO WHERE SOCIO_MAT = nMat AND vDataAtual BETWEEN DATA_INICIO AND data_final GROUP BY socio_mat),NULL,
  decode((SELECT A + B FROM (SELECT COUNT(SÓCIO_MAT||SEQ) AS A FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND (OBRIG_TIPO <> 'PARCELAMENTO' AND OBRIG_TIPO <> 'ANUIDADE') AND OBRIG_STATUS_COD NOT IN ('CANCELADA','SUBSTITUIDA') AND SÓCIO_MAT||SEQ NOT IN (SELECT SÓCIO_MAT||OBRIG_SEQ FROM SBDB.PAGAMENTO WHERE SÓCIO_MAT = nMat) AND ((TO_CHAR(COMPETÊNCIA,'YYYY') < vCompetenciaAtual) OR ((vDataAtual) > (vDataTolerancia)))) A, (SELECT COUNT(SÓCIO_MAT||SEQ) AS B FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND (OBRIG_TIPO = 'PARCELAMENTO'  OR OBRIG_TIPO = 'ANUIDADE')  AND OBRIG_STATUS_COD NOT IN ('CANCELADA','SUBSTITUIDA') AND  SÓCIO_MAT||SEQ NOT IN (SELECT SÓCIO_MAT||OBRIG_SEQ FROM SBDB.PAGAMENTO WHERE SÓCIO_MAT = nMat) AND TO_DATE(TO_CHAR(SYSDATE,'DD/MM/YYYY'),'DD/MM/YYYY') > TO_DATE(TO_CHAR(DATA_VENCIMENTO,'DD/MM/YYYY'),'DD/MM/YYYY')) B),0,
  decode((SELECT A + B FROM (SELECT COUNT(SÓCIO_MAT||SEQ) AS A FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND OBRIG_TIPO NOT IN ('PARCELAMENTO','ANUIDADE') AND OBRIG_STATUS_COD NOT IN ('CANCELADA','SUBSTITUIDA') AND SÓCIO_MAT||SEQ NOT IN (SELECT SÓCIO_MAT||OBRIG_SEQ FROM SBDB.PAGAMENTO WHERE SÓCIO_MAT = nMat) AND (TO_CHAR(COMPETÊNCIA,'YYYY') = TO_CHAR(vDataAtual,'YYYY')) AND ((TO_CHAR(vDataAtual,'DD/MM/YYYY') > (vDataLimite)) AND ((vDataAtual) <= (vDataTolerancia)))) A,(SELECT COUNT(SÓCIO_MAT||SEQ) AS B FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND OBRIG_TIPO IN ('PARCELAMENTO','ANUIDADE') AND OBRIG_STATUS_COD NOT IN ('CANCELADA','SUBSTITUIDA') AND SÓCIO_MAT||SEQ NOT IN (SELECT SÓCIO_MAT||OBRIG_SEQ FROM SBDB.PAGAMENTO WHERE SÓCIO_MAT = nMat) AND (TO_CHAR(COMPETÊNCIA,'YYYY') = TO_CHAR(vDataAtual,'YYYY')) AND ((To_date(TO_CHAR(vDataAtual,'DD/MM/YYYY'),'DD/MM/YYYY') > (To_date(TO_CHAR(DATA_VENCIMENTO,'DD/MM/YYYY'),'DD/MM/YYYY'))) AND ((To_date(TO_CHAR(vDataAtual,'DD/MM/YYYY'),'DD/MM/YYYY') <= (To_date(TO_CHAR(DATA_VENCIMENTO + vDiasValidade,'DD/MM/YYYY'),'DD/MM/YYYY')))))) B),0,
  decode((SELECT A + B FROM (SELECT COUNT(SÓCIO_MAT||SEQ) AS A FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND OBRIG_STATUS_COD NOT IN ('CANCELADA','SUBSTITUIDA') AND SÓCIO_MAT||SEQ NOT IN (SELECT SÓCIO_MAT||OBRIG_SEQ FROM SBDB.PAGAMENTO WHERE SÓCIO_MAT = nmat)) A, (SELECT COUNT(SÓCIO_MAT||SEQ) AS B FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = nMat AND (OBRIG_TIPO = 'PARCELAMENTO'  OR OBRIG_TIPO = 'ANUIDADE') AND SÓCIO_MAT||SEQ NOT IN (SELECT SÓCIO_MAT||OBRIG_SEQ FROM SBDB.PAGAMENTO WHERE SÓCIO_MAT = nMat) AND TO_DATE(TO_CHAR(SYSDATE,'DD/MM/YYYY'),'DD/MM/YYYY') <= TO_DATE(TO_CHAR(DATA_VENCIMENTO,'DD/MM/YYYY'),'DD/MM/YYYY')) B),0,
  'QUITE',
  'QUITE - CO'),
  'QUITE - TL'),
  'INADIMPLENTE'),
  'LICENCIADO'),
  LSBD.LSOCIO_ISENTO(nMat)),
  'RECENTE') INTO vStatus FROM DUAL;
  if (vObrigStatusCod <> vStatus) then
    if bTrigger then
      UPDATE SÓCIO SET OBRIG_STATUS_COD = vStatus, OBRIG_STATUS_DATA = SYSDATE WHERE MAT = nMat;
    else
      UPDATE SÓCIO SET OBRIG_STATUS_COD = vStatus, OBRIG_STATUS_DATA = SYSDATE, SYS_STATUS = 'X' WHERE MAT = nMat;
    end if;
  end if;
  BEGIN
    begin
    SELECT O.SÓCIO_MAT INTO nS FROM OBRIGAÇÃO O FULL OUTER JOIN (SELECT P.SÓCIO_MAT, P.SÓCIO_MAT||P.OBRIG_SEQ AS MS FROM SBDB.PAGAMENTO P) P ON P.MS = O.SÓCIO_MAT||O.SEQ WHERE O.OBRIG_TIPO LIKE 'ANUIDADE%' AND O.SÓCIO_MAT=nMat AND O.DATA_VENCIMENTO+5 > (SELECT TO_CHAR(DATA_LIMITE_VENCIMENTO + DIAS_VALIDADE,'DD/MM/YYYY') AS vDataTolerancia FROM SBDB.PARAMETRO_FINANCEIRO WHERE ANUIDADE = TO_CHAR(sysdate,'YYYY')) AND TO_DATE(TO_CHAR(SYSDATE,'DD/MM/YYYY'),'DD/MM/YYYY') <= TO_DATE(TO_CHAR(O.DATA_VENCIMENTO+5,'DD/MM/YYYY'),'DD/MM/YYYY') AND P.MS IS NULL ORDER BY O.SÓCIO_MAT;
    exception
      when others then
        nS := 0;
    end;
    if (nMat=nS) then
      SELECT COUNT(*) INTO NS FROM SBDB.PAGAMENTO P WHERE P.SÓCIO_MAT = NMAT;
      IF NS=0 THEN
      	UPDATE SÓCIO SET OBRIG_STATUS_COD = 'RECENTE', OBRIG_STATUS_DATA = SYSDATE, SYS_STATUS = 'X' WHERE MAT = nMat;
      ELSE
        UPDATE SÓCIO SET OBRIG_STATUS_COD = 'QUITE - CO', OBRIG_STATUS_DATA = SYSDATE, SYS_STATUS = 'X' WHERE MAT = nMat;
      END IF;
    end if;
  END;
  exception
    when others then
    begin
      nS := nMat;
      raise_application_error(-20000, 'Erro em LSocio_Status - ' || SQLERRM);
    end;
end LSocio_Status;

----------------------------------------------------------------------------------------------------
-- Função que verifica se o sócio é isento ou não, seguindo os critérios estabelecidos no estatuto.
----------------------------------------------------------------------------------------------------
Function LSocio_Isento(nMat in number) Return varchar2 is
  dtAnoNasc number;
  nMatSocio number;
  nTotReg number;
  nAno number;
  vCategoria SÓCIO.CATEGORIA_COD%type;
  vTipoIsento varchar2(50);
  vRetorno varchar2(50);
  nLinha number;
begin
  nAno := TO_NUMBER(TO_CHAR(SYSDATE,'YYYY')) - 70;
  SELECT MAT, TO_NUMBER(TO_CHAR(DATA_NASCIMENTO,'YYYY')), CATEGORIA_COD INTO nMatSocio, dtAnoNasc, vCategoria  FROM SBDB.SÓCIO  WHERE MAT = nMat;
  -- Verifica se o sócio possui isenção temporária na tabela SÓCIO_ISENÇÃO
  begin
    select count(ise.sócio_mat), ise.tipo into nTotReg, vTipoIsento
    from (select sócio_mat,rownum as linha,tipo
          from sbdb.sócio_isenção
          where sócio_mat = nMat AND
                (Data_Fim >= SYSDATE OR
                DATA_FIM IS NULL)) ise,
  	 (select sócio_mat,max(linha) as linha
          from (select sócio_mat, rownum as linha
                from sbdb.sócio_isenção
                where sócio_mat = nmat AND
                      (Data_Fim >= SYSDATE OR
                       DATA_FIM IS NULL))
                       group by sócio_mat) isf
    where ise.linha = isf.linha
    group by ise.tipo;
  exception
    when NO_DATA_FOUND then
      nTotReg := 0;
  end;
  vRetorno := null;
  -- Verifica os critérios de isenção.
  if vCategoria = 'BENEMÉRITO' or vCategoria = 'HONORÁRIO' then
    vRetorno := 'ISENTO - CATEGORIA';
  elsif (dtAnoNasc <= nAno) then
    vRetorno := 'ISENTO';
  elsif nTotReg > 0 then
    vRetorno := 'ISENTO - ' || vTipoIsento;
  end if;
  Return vRetorno;
exception
  when others then
  raise_application_error(-20000, 'Erro em LSocio_Isento - ' || SQLERRM);
end LSocio_Isento;
--------------------------------------------------------------------------------------------------------------
-- Procedimento para atualizar a situção de LICENCIADO para QUITE após data final de periodo
--------------------------------------------------------------------------------------------------------------
PROCEDURE LAtualiza_Licenciados IS
  CURSOR ALL_HIST_LICEN_INICIO IS
    SELECT SOCIO_MAT,TO_CHAR(DATA_INICIO,'DD/MM/YYYY') FROM SBDB.HISTORICO_LICENCIADO
    WHERE SYSDATE >= DATA_INICIO AND SYSDATE <= DATA_FINAL
    ORDER BY DATA_INICIO;
  CURSOR ALL_HIST_LICEN_FINAL IS
    SELECT SOCIO_MAT,TO_CHAR(DATA_FINAL,'DD/MM/YYYY')
    FROM SBDB.HISTORICO_LICENCIADO
    WHERE (SYSDATE < DATA_INICIO OR SYSDATE > DATA_FINAL) AND (SOCIO_MAT NOT IN ( SELECT SOCIO_MAT FROM SBDB.HISTORICO_LICENCIADO WHERE SYSDATE <= DATA_FINAL))
    ORDER BY DATA_FINAL desc;
  TYPE t_SOCIO_MAT IS TABLE OF HISTORICO_LICENCIADO.SOCIO_MAT%TYPE INDEX BY BINARY_INTEGER;
  TYPE t_DATA_INICIO IS TABLE OF HISTORICO_LICENCIADO.DATA_INICIO%TYPE INDEX BY BINARY_INTEGER;
  TYPE t_DATA_FINAL IS TABLE OF HISTORICO_LICENCIADO.DATA_FINAL%TYPE INDEX BY BINARY_INTEGER;
  v_SOCIO_MAT t_SOCIO_MAT;
  v_DATA_INICIO t_DATA_INICIO;
  v_DATA_FINAL t_DATA_FINAL;
  v_INDICE BINARY_INTEGER;
BEGIN
  OPEN ALL_HIST_LICEN_INICIO;
  FETCH ALL_HIST_LICEN_INICIO BULK COLLECT  INTO v_SOCIO_MAT, v_DATA_INICIO;
  CLOSE ALL_HIST_LICEN_INICIO;
  FORALL v_INDICE IN v_SOCIO_MAT.FIRST..v_SOCIO_MAT.LAST
    UPDATE SBDB.SÓCIO SET OBRIG_STATUS_COD = 'LICENCIADO'
    WHERE (SBDB.SÓCIO.MAT = v_SOCIO_MAT(v_INDICE)) AND
          (SBDB.SÓCIO.OBRIG_STATUS_COD = 'QUITE' OR SBDB.SÓCIO.OBRIG_STATUS_COD = 'QUITE - CO');
  COMMIT;
  OPEN ALL_HIST_LICEN_FINAL;
  FETCH ALL_HIST_LICEN_FINAL BULK COLLECT
    INTO v_SOCIO_MAT, v_DATA_FINAL;
  CLOSE ALL_HIST_LICEN_FINAL;
  FORALL v_INDICE IN v_SOCIO_MAT.FIRST..v_SOCIO_MAT.LAST
    UPDATE SBDB.SÓCIO SET OBRIG_STATUS_COD = 'QUITE'
    WHERE (SBDB.SÓCIO.MAT = v_SOCIO_MAT(v_INDICE)) AND
          (SBDB.SÓCIO.OBRIG_STATUS_COD='LICENCIADO');
  COMMIT;
END LAtualiza_Licenciados;
--------------------------------------------------------------------------------------------------------------
-- Procedimento para atualizar a situção de PENALIZADO após data final de periodo
--------------------------------------------------------------------------------------------------------------
PROCEDURE LAtualiza_Penalizado IS
 CURSOR ALL_HIST_PENAL IS
   SELECT SOCIO_MAT,DATA_FINAL FROM SBDB.HISTORICO_PENALIZADO
   WHERE DATA_FINAL > SYSDATE
   ORDER BY DATA_FINAL desc;
 TYPE t_SOCIO_MAT IS TABLE OF HISTORICO_PENALIZADO.SOCIO_MAT%TYPE INDEX BY BINARY_INTEGER;
 TYPE t_DATA_FINAL IS TABLE OF HISTORICO_PENALIZADO.DATA_FINAL%TYPE INDEX BY BINARY_INTEGER;
 v_SOCIO_MAT t_SOCIO_MAT;
 v_DATA_FINAL t_DATA_FINAL;
 v_INDICE BINARY_INTEGER;
BEGIN
  OPEN ALL_HIST_PENAL;
  FETCH ALL_HIST_PENAL BULK COLLECT
     INTO v_SOCIO_MAT,v_DATA_FINAL;
  CLOSE ALL_HIST_PENAL;
  FORALL v_INDICE IN v_SOCIO_MAT.FIRST..v_SOCIO_MAT.LAST
     UPDATE SBDB.SÓCIO SET PENALIZADO = 'N'
     WHERE (SYSDATE >= V_DATA_FINAL(v_INDICE)) AND
           (SBDB.SÓCIO.MAT = v_SOCIO_MAT(v_INDICE)) AND
           (SBDB.SÓCIO.PENALIZADO='S');
  COMMIT;
END LAtualiza_Penalizado;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Função para colocar as primeiras letras em maiúsculo - Andre (06/01/2007) - Alterada pelo Luciano (13/02/2007)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Function  LPrimLetraMaius(TEXTO in Varchar2) Return varchar2 IS
  MAIUSC VARCHAR(2000) := ';AC;AL;AM;AP;BA;CE;DF;ES;GO;MA;MG;MS;MT;PA;PB;PE;PI;PR;RJ;RN;RO;RR;RS;SC;SE;SP;TO;IASERJ;HSE;UNIRIO;UERJ;UFRJ;UFF;UFSP;SBD;ABC;UFJF;INAMPS;SUS;UNICAMP;UFS;CEDER;UNOESTE;PUC;UFES;FMUSP;UFRGS;UFPR;FMJ;HUSC;UFP;HUT;CEDEM;HUCFF;EPM;HC;FFFCM;UNIFESP;EMC;';
  MINUSC VARCHAR(2000) := ';DA;DE;DI;DO;DU;DAS;DES;DIS;DOS;DUS;NA;NAS;NO;NOS;EM;AOS;AO;A;O';
  DELIM VARCHAR2(10) := ' -./()';
  POS INTEGER;
  POSF INTEGER;
  POSD VARCHAR2(1);
  CPOS INTEGER;
  CPOSF INTEGER;
  Z INTEGER;
  RETORNO VARCHAR2(2000) := '';
  PALAV VARCHAR2(300);
  TEXTOI VARCHAR2(2000);
BEGIN
 TEXTOI := NLS_INITCAP(TEXTO);
 POS := 1;
 WHILE POS <= LENGTH(TEXTOI) LOOP
  POSF := LENGTH(TEXTOI)+1;
  POSD := '';
  FOR Z IN 1..LENGTH(DELIM) LOOP
   CPOS := INSTR(TEXTOI, SUBSTR(DELIM,Z,1), POS);
   IF CPOS <> 0 THEN
    IF CPOS < POSF THEN
     POSF := CPOS;
     POSD := SUBSTR(DELIM,Z,1);
    END IF;
   END IF;
  END LOOP;
  PALAV := SUBSTR(TEXTOI, POS, POSF-POS);
  CPOS := INSTR(MAIUSC, ';' || UPPER(PALAV) || ';');
  IF CPOS <> 0 THEN
   CPOSF := INSTR(MAIUSC, ';', CPOS+1);
   IF CPOSF = 0 THEN
    RETURN '';
   ELSE
    PALAV := SUBSTR(MAIUSC, CPOS+1, CPOSF-CPOS-1);
   END IF;
  END IF;
  CPOS := INSTR(MINUSC, ';' || UPPER(PALAV) || ';');
  IF CPOS <> 0 THEN
   CPOSF := INSTR(MINUSC, ';', CPOS+1);
   IF CPOSF = 0 THEN
    RETURN '';
   ELSE
    PALAV := LOWER(SUBSTR(MINUSC, CPOS+1, CPOSF-CPOS-1));
   END IF;
  END IF;
  RETORNO := RETORNO || PALAV || POSD;
  POS := POSF + 1;
 END LOOP;
 RETURN RETORNO;
END;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Função para validar o CPF - Andre (14/05/2007) - Alterada pelo Luciano (13/02/2007)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Function LVal_CPF(CPF VARCHAR2) Return Varchar2 IS
  cpf_c         number ;
  tam           number(2);
  tot1          number(4) := 0;
  tot2          number(4) := 0;
  multiplicador number(2) := 9;
  digito        number(1) := 0;
  resto1        number(2) := 0;
  resto2        number(2) := 0;
  dc1_cpf       number(1) := 0;
  dc2_cpf       number(1) := 0;
  digito_dig    char(2);
  cpf_x         number;
  tamanho       number(2);
  dc_cpf        char(2);
begin
  cpf_c      := lpad(rtrim(ltrim(replace(CPF,'-',''))),11,'0');
  tam        := length(substr(cpf_c,-2,2));
  digito_dig := substr(cpf_c,-2,2);
  cpf_x      := substr(lpad(to_char(cpf_c),11,'0'),1,9);
  tamanho    := length(to_char(cpf_x));
  if (CPF IS NOT NULL)  THEN
    for i in reverse 1..tamanho loop
      tot1 := tot1 + multiplicador * (substr(to_char(cpf_x),i,1));
      multiplicador  := multiplicador - 1;
    end loop;
    resto1 := mod(tot1,11);
    if resto1 = 10 then
      dc1_cpf := 0;
    else
      dc1_cpf := resto1;
    end if;
    digito := dc1_cpf;
    tot2    := tot2 + 9 * digito;
    multiplicador := 8;
    for i in reverse 1..tamanho loop
      tot2 := tot2 + multiplicador * (substr(to_char(cpf_x),i,1));
      multiplicador := multiplicador - 1;
    end loop;
    resto2 := mod(tot2,11);
    if resto2 = 10 then
      dc2_cpf := 0;
    else
      dc2_cpf := resto2;
    end if;
    dc_cpf := to_char(dc1_cpf) || to_char(dc2_cpf);
    if dc_cpf = digito_dig then
      return 'V';
    else
      return 'F';
    end if;
  else
    return '';
  end if;
  exception
    WHEN VALUE_ERROR THEN
      return 'F';
END LVal_CPF;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Função para colocar todas as  letras em maiúsculo e tirando o acento - Carlos Gomes (26/10/2007)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Function  LMaiusculaSemAcento(CAMPO in Varchar2) Return varchar2 IS
  vCampo Varchar2(100);
BEGIN
  vCampo := Campo;
  Return UPPER(TRIM(TRANSLATE(vCampo,'ÁÉÍÓÚáéíóúÇçÀàÃãÕõÂâÊêÈèÔô','AEIOUaeiouCcAaAaOoAaEeEeOo')));
END;
FUNCTION LDif_Data (max_date STRING, min_date STRING) RETURN PLS_INTEGER IS
BEGIN
  RETURN TO_DATE(max_date) - TO_DATE(min_date);
EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL;
END LDif_Data;
FUNCTION DIA_UTIL(vData in date) RETURN string IS
  vData_util date;
  Cursor CurData is select dia||'/'||mes as Data_Feriado from sbdb.feriado order by dia,mes;
BEGIN
  vData_util := vData;
  for Cur in CurData loop
    if to_char(vData_util, 'd') = 1 or to_char(vData_util, 'd') = 7 then
      vData_util := vData_util + 2;
    end if;
    if to_char(vData_util,'dd/mm') = cur.data_feriado then
      vData_util := vData_util + 1;
    end if;
  end loop;
  return to_char(vData_util,'dd/mm/yyyy');
  Close CurData;
END DIA_UTIL;
----------------------------------------------------------------------------------------------------
-- Procedimento para gerar a obrigação DESPESAS BIBLIOTECA
----------------------------------------------------------------------------------------------------
PROCEDURE LBiblio_Despesas(vANUIDADE IN VARCHAR2) IS
  v_ANUIDADE VARCHAR2(4);
  x_ANUIDADE VARCHAR2(4);
  v_OBR_TIPO VARCHAR2(30);
  v_EMISSAO VARCHAR2(1);
  v_OBR_SEQ NUMBER(5);
BEGIN
  x_ANUIDADE := vANUIDADE;
  v_ANUIDADE := '';
  v_EMISSAO := '';
  SELECT MAX(ANUIDADE) INTO v_ANUIDADE FROM SBDB.PARAMETRO_FINANCEIRO;
  IF v_ANUIDADE = x_ANUIDADE THEN
    SELECT EMISSAO_BOLETO INTO v_EMISSAO FROM SBDB.PARAMETRO_FINANCEIRO WHERE ANUIDADE = x_ANUIDADE;
    if v_EMISSAO = 'S' THEN
      raise_application_error(-20011, 'Não é mais permitido gerar as obrigações. Os boletos já foram gerados.' || SQLERRM);
    end if;
    DELETE FROM SBDB.OBRIGAÇÃO WHERE COMPETÊNCIA = TO_DATE('01/01/'||x_ANUIDADE,'DD/MM/YYYY')  AND OBRIG_TIPO='DESPESAS BIBLIOTECA';
    FOR CUR IN (SELECT L.MAT,S.NOME,S.OBRIG_STATUS_COD AS STATUS, to_char(L.SALDO, '999D99') AS SALDO FROM
               (SELECT MAT, SALDO FROM (SELECT P.MAT_ASSOCIADO AS MAT, SUM(P.DESPBIBLIO) - SUM(NVL(L.VALOR,0)) AS SALDO
                FROM (select MAT_ASSOCIADO, COD, DECODE(QTDE_COPIAS,NULL,(CUSTO_SERVICO*QTDE_ATENDIDOS)+CUSTO_POSTAGEM,(CUSTO_SERVICO*QTDE_COPIAS)+CUSTO_POSTAGEM) AS DESPBIBLIO FROM BIBLIO_PEDIDO) P,
               (SELECT COD_PEDIDO, VALOR FROM BIBLIO_LANCAMENTO WHERE valor > 0 ) L
                WHERE P.COD = L.COD_PEDIDO(+) GROUP BY MAT_ASSOCIADO)  WHERE SALDO > 0 AND MAT IS NOT NULL ORDER BY MAT) L,
                SÓCIO S WHERE S.MAT = L.MAT AND S.OBRIG_STATUS_COD NOT LIKE 'ISENTO%') LOOP
      v_OBR_SEQ := NULL;
      SELECT NVL(MAX(SEQ)+1,1) INTO v_OBR_SEQ FROM SBDB.OBRIGAÇÃO WHERE SÓCIO_MAT = CUR.MAT GROUP BY SÓCIO_MAT;
      IF (v_OBR_SEQ IS NOT NULL) AND (v_OBR_TIPO IS NULL) THEN
        INSERT INTO SBDB.OBRIGAÇÃO (SÓCIO_MAT, SEQ, OBRIG_TIPO, DATA_LANÇAMENTO,COMPETÊNCIA, VALOR, DATA_VENCIMENTO, OBRIG_STATUS_COD)
                            VALUES (CUR.MAT,v_OBR_SEQ,'DESPESAS BIBLIOTECA',SYSDATE, TO_DATE('01/01/'||v_ANUIDADE,'DD/MM/YYYY'),CUR.SALDO,TO_DATE('30/04/'||v_ANUIDADE,'DD/MM/YYYY'),'EM ABERTO');
        COMMIT;
        FOR CRS IN (SELECT A.*,B.* FROM (select MAT_ASSOCIADO, COD, DECODE(QTDE_COPIAS,NULL,(CUSTO_SERVICO*QTDE_ATENDIDOS)+CUSTO_POSTAGEM,(CUSTO_SERVICO*QTDE_COPIAS)+CUSTO_POSTAGEM) AS DESPBIBLIO FROM SBDB.BIBLIO_PEDIDO WHERE MAT_ASSOCIADO = CUR.MAT ORDER BY MAT_ASSOCIADO,COD) A, (SELECT SÓCIO_MAT,NVL(MAX(SEQ),1) AS v_OBR_SEQ FROM SBDB.OBRIGAÇÃO GROUP BY SÓCIO_MAT) B WHERE B.SÓCIO_MAT = A.MAT_ASSOCIADO) LOOP
          UPDATE SBDB.BIBLIO_PEDIDO SET OBRIG_SEQ = CRS.V_OBR_SEQ WHERE MAT_ASSOCIADO=CRS.MAT_ASSOCIADO AND COD=CRS.COD;
          COMMIT;
        END LOOP;
        UPDATE SBDB.PARAMETRO_FINANCEIRO SET EMISSAO_BOLETO = 'S' WHERE ANUIDADE = x_ANUIDADE;
      END IF;
    END LOOP;
   else
      raise_application_error(-20010, 'Anuidade Inválida! ' || SQLERRM);
   END IF;
END LBiblio_Despesas;
----------------------------------------------------------------------------------------------------
-- Procedimento para Validar e-mail
----------------------------------------------------------------------------------------------------
Function LValidaEmail(email in varchar2) return varchar2 as
  ValEmail Varchar2(500);
begin
	select case when nvl(trim(email),null) is not null then
        nvl2 (REGEXP_SUBSTR (email, '^([a-z0-9._-]+)@([a-z0-9_-]+(\.[a-z0-9_-]+)+)$'),'Válido', '> E-mail Inválido: ('||email||')')
      else 'Válido'
 end into ValEmail from dual;
 Return ValEmail;
end;
----------------------------------------------------------------------------------------------------
-- Procedimento para enviar email de log
----------------------------------------------------------------------------------------------------

Procedure LAtualiza_Geral is
ret clob;
HOST_INFO VARCHAR2(4000);
begin
  ret := '<html><body><h1>ACOMPANHAMENTO EXEC JOB SBDB CIAD</h1>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'LAtualiza_Obrig_Status';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
  NULL;
	-- LAtualiza_Obrig_Status;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'LAtualiza_Socio_Status';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
  	LAtualiza_Socio_Status;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'LAltera_Categoria';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
  NULL;
	LAltera_Categoria;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'RSBD.AtualizaDelegados';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
	RSBD.AtualizaDelegados;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'LAtualiza_Licenciados';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
	LAtualiza_Licenciados;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'LAtualiza_Penalizado';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
	LAtualiza_Penalizado;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'LCompObjetos';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
	LB.LCompObjetos;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'DBMS_LOG';
  ret := ret || '<ul>';
  ret := ret || '<li>momento: ' || to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') || '</li>';
  begin
	DBMS_LOG;
  exception
     when others then
        ret := ret || '<li>erro: ' || SQLERRM || '</li>';
  end;
  RET := RET || '</ul></p>';
--
--
--
  RET := RET || '<p>';
  ret := ret || 'Objetos Modificados';
  RET := RET || '<ul>';
  ret := ret || SBDB.LSQLTOHTML('select OWNER, user, sysdate, OBJECT_NAME, OBJECT_TYPE, CREATED ,LAST_DDL_TIME from ALL_OBJECTS where OWNER IN (''ATLAS'',''ARCD'',''SBDB'',''PALESTRA'',''SURGICAL'',''ESEND'',''SEPON'',''ANAIS2'')  AND TO_CHAR(LAST_DDL_TIME,''YYYY-MM-DD'') = TO_CHAR(SYSDATE-1,''YYYY-MM-DD'')',7);
  RET := RET || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'Objetos inválidos';
  ret := ret || '<ul>';
  ret := ret || SBDB.LSQLTOHTML('SELECT OWNER, OBJECT_NAME, OBJECT_TYPE, STATUS FROM ALL_OBJECTS WHERE STATUS = ''INVALID'' AND OWNER<>''PUBLIC''  ORDER BY OWNER, LAST_DDL_TIME',4);
  ret := ret || '</ul></p>';
--
--
--
  ret := ret || '<p>';
  ret := ret || 'Índices Inválidos';
  ret := ret || '<ul>';
  ret := ret || SBDB.LSQLTOHTML('SELECT OWNER, INDEX_NAME, STATUS FROM ALL_INDEXES WHERE STATUS = ''UNUSABLE''  ORDER BY OWNER, INDEX_NAME',3);
  ret := ret || '</ul></p>';
--
--
  ret := ret || '<p>';
  ret := ret || 'Estado de Jobs';
  ret := ret || '<ul>';
  ret := ret || SBDB.LSQLTOHTML('SELECT JOB,''broken:'' || BROKEN,''failures:'' || FAILURES,WHAT FROM DBA_JOBS ORDER BY FAILURES DESC',4);
  ret := ret || '</ul></p>';
--
  ret := ret || '</body></html>';
  select UTL_INADDR.GET_HOST_NAME || ' - [' || UTL_INADDR.GET_HOST_ADDRESS || ']' INTO HOST_INFO from DUAL;
  SENDMAIL('WEB@SBD.ORG.BR','lucianol@icraft.com.br','SBD - Oracle SBDB - Acompanhamento de Job Atualiza Geral do HOST: '|| HOST_INFO,ret);
end;

end LSBD;
/

-- OBJETO 203 | TRIGGER | AFT_SOCIO_PUBL_END
create or replace TRIGGER "SBDB".AFT_SOCIO_PUBL_END AFTER UPDATE OF PUBLICAR_COMERCIAL_1,PUBLICAR_COMERCIAL_2 ON SÓCIO
FOR EACH ROW
DECLARE
  vPub_1 Integer;
  vPub_2 Integer;
  vSeqHistPubEnd Integer;
BEGIN
  IF :OLD.PUBLICAR_COMERCIAL_1 <> :NEW.PUBLICAR_COMERCIAL_1 THEN
    vPub_1 := :NEW.PUBLICAR_COMERCIAL_1;
  else
    vPub_1 := :OLD.PUBLICAR_COMERCIAL_1;
  END IF;
  IF :OLD.PUBLICAR_COMERCIAL_2 <> :NEW.PUBLICAR_COMERCIAL_2 THEN
    vPub_2 := :NEW.PUBLICAR_COMERCIAL_2;
  else
    vPub_2 := :OLD.PUBLICAR_COMERCIAL_2;
  END IF;
  IF (:OLD.PUBLICAR_COMERCIAL_1 <> :NEW.PUBLICAR_COMERCIAL_1) OR (:OLD.PUBLICAR_COMERCIAL_2 <> :NEW.PUBLICAR_COMERCIAL_2) THEN
    SELECT MAX(NVL(SEQ,0)) + 1 into vSeqHistPubEnd FROM SBDB.HISTORICO_SOCIO_PUBL_END;
    INSERT INTO HISTORICO_SOCIO_PUBL_END (SEQ,SOCIO_MAT, PUBLICAR_COM_1,PUBLICAR_COM_2) VALUES (vSeqHistPubEnd,:OLD.MAT, vPub_1, vPub_2);
  END IF;
END;
/

-- OBJETO 204 | PACKAGE | EMCD
create or replace
PACKAGE "EMCD" IS 
  PROCEDURE APURA_PERIODO (ANO IN VARCHAR2) ;
  PROCEDURE EMITE_EXTRATO (ANO IN VARCHAR2) ;
	FUNCTION VALIDAFASE	(SOC IN NUMBER,	APUR IN VARCHAR2)	RETURN NUMBER;
	FUNCTION VALIDACERTIFICADO (VALOR IN NUMBER,TOTAL_PONTO IN NUMBER)	RETURN NUMBER;
END;
/

create or replace
PACKAGE BODY "EMCD" AS
	-- AVISOS QUANTO ÀS RESTRIÇÕES NECESSÁRIAS
	-- NÃO SE PODE INCLUIR FASE QUE NÃO EXISTAM ANTERIORES
	-- PERMITIR PROCESSAR SOMENTE FASE ONDE A ANTERIOR JÁ ESTEJA PROCESSADA
	-------------------------------------------------------------------------------
	-- ROTINA PARA APURAR A PONTUAÇÃO EM UM ANO INFORMADO
	-------------------------------------------------------------------------------
  PROCEDURE APURA_PERIODO	(ANO IN VARCHAR2) AS
    VDATAFASEANTERIOR DATE;
    VFASEEXISTENTE VARCHAR2(10) ;
    VFASE VARCHAR2(4) ;
    VTOTPONTO NUMBER(5, 2) ;
  begin
  
    if ANO >= TO_NUMBER(2004)  then

      -------------------------------------------------------------------------------
      -- VERIFICA SE A FASE INFORMADA JÁ FOI APURADA
      -------------------------------------------------------------------------------
      select FASE, TOTAL_PONTO, NVL(SBDB.LB.LEXIBEDATA(DATA_APURACAO,'sd'),'NULO') into VFASE, VTOTPONTO, VFASEEXISTENTE FROM SBDB.EMCD_FASE WHERE SBDB.LB.LEXIBEDATA(DATA_INICIO,'yyyy') = ANO;

      -------------------------------------------------------------------------------
      -- ESTA SELECT DEVE SER ATIVADA CASO A APURAÇÃO SEJA FEITA ANTES DA VIRADA DO ANO E RETORNAR PARA INATIVA APÓS A VIRADA DO ANO
      -------------------------------------------------------------------------------
      --Select nvl(to_char(DATA_APURACAO,'dd/mm/yyyy'),'NULO') into FaseExistente FROM SBDB.EMCD_FASE WHERE FASE = Vfase;
      IF(VFASEEXISTENTE <> 'NULO') THEN
        RAISE_APPLICATION_ERROR( - 20001, 'A Fase ' || VFASE || ', Já Foi Apurada! Procedimento foi abortado.') ;
      ELSE
        begin
          SELECT NVL(DATA_APURACAO, TO_DATE('31/12/3999', 'dd/mm/yyyy')) INTO VDATAFASEANTERIOR FROM SBDB.EMCD_FASE WHERE TO_NUMBER(FASE) = TO_NUMBER(VFASE) - 1;
          if VDATAFASEANTERIOR = TO_DATE('31/12/3999', 'dd/mm/yyyy') then
            RAISE_APPLICATION_ERROR( - 20002, 'Para processar a fase ' || VFASE || ', as fases anteriores devem estar processadas. Procedimento foi abortado.') ;
          END IF;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          VFASEEXISTENTE := '0000';
        end;
      end if;
      
      -------------------------------------------------------------------------------
      -- DELETA TODOS OS REGITROS REFERENTE A FASE PARA QUE A APURAÇÃO POSSA SER REALIZADA EVITANDO DUPLICIDADES
      -------------------------------------------------------------------------------
      delete from SBDB.EMCD_PONTO_FASE where APURACAO = VFASE;
      delete from SBDB.EMCD_APURAÇÃO where APURACAO = VFASE;

      FOR CUR IN (SELECT FASE, DATA_INICIO, DATA_FINAL, TOTAL_PONTO	FROM SBDB.EMCD_FASE	WHERE SBDB.LB.LEXIBEDATA(DATA_INICIO,'yyyy') = ANO ORDER BY FASE)
      LOOP
      
        -------------------------------------------------------------------------------
        -- INCLUI PONTOS
        -------------------------------------------------------------------------------
        INSERT INTO SBDB.EMCD_PONTO_FASE (SOCIO_MAT, ATIV_COD, PONTO_COD, APURACAO, SUBFASE)
        select PONTOS.SÓCIO_MAT,  PONTOS.ATIV_COD, PONTOS.PONTO_COD, CUR.FASE, 
        TO_CHAR(TO_NUMBER(SBDB.LB.LEXIBEDATA(PONTO_DATA,'yyyy')) - TO_NUMBER(SBDB.LB.LEXIBEDATA(CUR.DATA_INICIO,'yyyy')) + 1) SUBFASE
        from SBDB.EMCD_PONTO_SÓCIO PONTOS,(select SBDB_PROX_FASE_CERTIF_L.MAT, SBDB_PROX_FASE_CERTIF_L.NAFASE,  SBDB_PROX_FASE_CERTIF_L.DATA_CADASTRO	
                                   FROM	(SELECT MAT, CUR.FASE APURACAO, EMCD.VALIDAFASE(MAT, CUR.FASE) NAFASE, DATA_CADASTRO, DATA_INICIO_CONTAGEM
                                         from SBDB.SÓCIO
                                         where EXCLUÍDO = 0 and MAT in (select SÓCIO_MAT from SBDB.SÓCIO_CATEGORIA where CATEGORIA_COD in ('TITULAR','CONTRIBUINTE','HONORÁRIO') and SBDB.LB.LEXIBEDATA(DATA_ALTERAÇÃO,'yyyy') <= ANO)) SBDB_PROX_FASE_CERTIF_L
                                   where SBDB_PROX_FASE_CERTIF_L.APURACAO = CUR.FASE and SBDB_PROX_FASE_CERTIF_L.NAFASE = - 1) AD_00_SÓCIOS_EM_CADA_FASE
               where PONTOS.PONTO_DATA >= CUR.DATA_INICIO and PONTOS.PONTO_DATA <= CUR.DATA_FINAL and AD_00_SÓCIOS_EM_CADA_FASE.DATA_CADASTRO <= PONTOS.PONTO_DATA and AD_00_SÓCIOS_EM_CADA_FASE.NAFASE = -1 and AD_00_SÓCIOS_EM_CADA_FASE.MAT = PONTOS.SÓCIO_MAT (+);

        -------------------------------------------------------------------------------
        -- INCLUI APURACAO
        -------------------------------------------------------------------------------
        insert into SBDB.EMCD_APURAÇÃO (DATA_INI_CONT, PONTUAÇÃO, SÓCIO_MAT, APURACAO, DATA_APURAÇÃO, QTD_REGS, CERTIF_IMPRIMIR)
        select * from (select min(PONTOS.PONTO_DATA) DATA_INI_CONT, SUM(PONTOS.PONTO_VALOR) PONTUAÇÃO, PONTOS.SÓCIO_MAT, CUR.FASE, sysdate, COUNT(PONTOS.SÓCIO_MAT) QTD_REGS, EMCD.VALIDACERTIFICADO(SUM(PONTO_VALOR), CUR.TOTAL_PONTO) as CERTIF_IMPRIMIR
               from SBDB.EMCD_PONTO_SÓCIO PONTOS,(select SBDB_PROX_FASE_CERTIF_L.MAT, SBDB_PROX_FASE_CERTIF_L.NAFASE, SBDB_PROX_FASE_CERTIF_L.DATA_CADASTRO
                                                  FROM (SELECT MAT, CUR.FASE APURACAO, EMCD.VALIDAFASE(MAT, CUR.FASE) NAFASE, DATA_CADASTRO
                                         from SBDB.SÓCIO
                                         where EXCLUÍDO = 0 and MAT in (select SÓCIO_MAT from SBDB.SÓCIO_CATEGORIA where CATEGORIA_COD in ('TITULAR','CONTRIBUINTE','HONORÁRIO') and SBDB.LB.LEXIBEDATA(DATA_ALTERAÇÃO,'yyyy') <= ANO))	SBDB_PROX_FASE_CERTIF_L
                                                  where SBDB_PROX_FASE_CERTIF_L.APURACAO = CUR.FASE and SBDB_PROX_FASE_CERTIF_L.NAFASE = - 1) AD_00_SÓCIOS_EM_CADA_FASE
              where PONTOS.PONTO_DATA >= CUR.DATA_INICIO and AD_00_SÓCIOS_EM_CADA_FASE.DATA_CADASTRO <= PONTOS.PONTO_DATA and PONTOS.PONTO_DATA <= CUR.DATA_FINAL and AD_00_SÓCIOS_EM_CADA_FASE.MAT = PONTOS.SÓCIO_MAT (+)
              group by PONTOS.SÓCIO_MAT, AD_00_SÓCIOS_EM_CADA_FASE.NAFASE)
              WHERE SBDB.LB.LEXIBEDATA(DATA_INI_CONT,'yyyy') = ANO;
      
        -------------------------------------------------------------------------------
        -- ATUALIZA DATA DE APURAÇÃO
        -------------------------------------------------------------------------------
        update SBDB.EMCD_FASE	set DATA_APURACAO = sysdate where FASE = CUR.FASE;
        commit;
       
      end LOOP; 
    else
      RAISE_APPLICATION_ERROR(-20011, 'Não é mais permitido apurar o ano inferior a 2004.' || SQLERRM);
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR( - 20000, 'Erro em Apura_Periodo: ' || SQLERRM) ;
END;

  -------------------------------------------------------------------------------
  -- VALIDA A FASE
  -------------------------------------------------------------------------------
  FUNCTION VALIDAFASE (SOC IN NUMBER,APUR IN VARCHAR2) RETURN NUMBER AS ULT_FASE VARCHAR2(5) ;
    PRIM_DIA_PROX_FASE DATE;
    FASE_PROX VARCHAR(5) ;
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
  
    SELECT NVL(MAX(APURACAO),-1) INTO ULT_FASE FROM SBDB.EMCD_APURAÇÃO WHERE SÓCIO_MAT = SOC AND CERTIF_IMPRIMIR = -1 AND TO_NUMBER(APURACAO) < TO_NUMBER(APUR);
    IF ULT_FASE = -1 THEN
      RETURN -1;
    ELSE
    
      -------------------------------------------------------------------------------
      --PRIMEIRO DIA DA PRÓXIMA FASE
      -------------------------------------------------------------------------------
      SELECT DATA_FINAL + 1	INTO PRIM_DIA_PROX_FASE FROM SBDB.EMCD_FASE WHERE FASE = ULT_FASE;
      
      -------------------------------------------------------------------------------
      --QUAL A PRÓXIMA FASE
      -------------------------------------------------------------------------------
      SELECT MAX(FASE) INTO FASE_PROX FROM SBDB.EMCD_FASE WHERE PRIM_DIA_PROX_FASE > (SELECT DATA_INICIO_CONTAGEM FROM SÓCIO WHERE MAT = SOC);
      
      -------------------------------------------------------------------------------
      --A FASE SOLICITADA ESTÁ CONTEMPLADA?
      -------------------------------------------------------------------------------
      IF APUR >= FASE_PROX THEN
        RETURN -1;
      ELSE
        RETURN 0;
      END IF;
      
    END IF;
    
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR( - 20000, 'Erro em ValidaFase: ' || SQLERRM) ;
  END;

  -------------------------------------------------------------------------------
  -- VALIDA A CERTIFICAÇÃO
  -------------------------------------------------------------------------------
  FUNCTION VALIDACERTIFICADO (VALOR IN NUMBER, TOTAL_PONTO IN NUMBER)	RETURN NUMBER AS
  BEGIN
    IF VALOR >= TOTAL_PONTO THEN
      RETURN -1;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR( - 20000, 'Erro em ValidaCertificado: ' || SQLERRM) ;
  END;


-------------------------------------------------------------------------------
-- ROTINA DE EMISSÃO DE EXTRATO
-------------------------------------------------------------------------------
PROCEDURE EMITE_EXTRATO(ANO IN VARCHAR2) AS
  STRSQL VARCHAR2(2500) ;
  VFASE VARCHAR2(4) ;
  VTOTPONTO NUMBER(5, 2) ;
BEGIN
  SELECT FASE, TOTAL_PONTO INTO VFASE, VTOTPONTO  FROM SBDB.EMCD_FASE  WHERE SBDB.LB.LEXIBEDATA(DATA_INICIO,'yyyy') = ANO;
  DELETE FROM SBDB.EMCD_PONTO_FASE WHERE APURACAO = VFASE;
  DELETE FROM SBDB.EMCD_APURAÇÃO WHERE APURACAO = VFASE;
  -------------------------------------------------------------------------------
  -- LOOPING DAS FASES A SEREM TRATADAS
  -------------------------------------------------------------------------------
  FOR CUR IN (SELECT FASE, DATA_INICIO, DATA_FINAL, TOTAL_PONTO	FROM SBDB.EMCD_FASE	WHERE SBDB.LB.LEXIBEDATA(DATA_INICIO,'yyyy') = ANO	ORDER BY FASE)
  LOOP
    -------------------------------------------------------------------------------
    -- INCLUI PONTO_FASE
    -------------------------------------------------------------------------------
    INSERT INTO SBDB.EMCD_PONTO_FASE(SOCIO_MAT, ATIV_COD, PONTO_COD, APURACAO, SUBFASE)		
    SELECT PONTOS.SÓCIO_MAT, PONTOS.ATIV_COD, PONTOS.PONTO_COD, CUR.FASE, TO_CHAR(TO_NUMBER(SBDB.LB.LEXIBEDATA(PONTO_DATA,'yyyy')) - TO_NUMBER(SBDB.LB.LEXIBEDATA(CUR.DATA_INICIO,'yyyy')) + 1) SUBFASE
    FROM SBDB.EMCD_PONTO_SÓCIO PONTOS,(SELECT SBDB_PROX_FASE_CERTIF_L.MAT, SBDB_PROX_FASE_CERTIF_L.NAFASE
                                       FROM (SELECT MAT, CUR.FASE APURACAO, EMCD.VALIDAFASE(MAT, CUR.FASE) NAFASE
                                             FROM SBDB.SÓCIO
                                             WHERE SBDB.LB.LEXIBEDATA(DATA_CADASTRO,'yyyy') <= ANO AND EXCLUÍDO = 0) SBDB_PROX_FASE_CERTIF_L
                                       WHERE SBDB_PROX_FASE_CERTIF_L.APURACAO = CUR.FASE AND SBDB_PROX_FASE_CERTIF_L.NAFASE = - 1) AD_00_SÓCIOS_EM_CADA_FASE
    WHERE PONTOS.PONTO_DATA >= CUR.DATA_INICIO AND PONTOS.PONTO_DATA <= CUR.DATA_FINAL AND AD_00_SÓCIOS_EM_CADA_FASE.NAFASE = - 1 AND AD_00_SÓCIOS_EM_CADA_FASE.MAT = PONTOS.SÓCIO_MAT (+);
    -------------------------------------------------------------------------------
    -- INCLUI APURACAO
    -------------------------------------------------------------------------------
    INSERT INTO SBDB.EMCD_APURAÇÃO(DATA_INI_CONT, PONTUAÇÃO, SÓCIO_MAT, APURACAO, DATA_APURAÇÃO, QTD_REGS, CERTIF_IMPRIMIR)
    select * from (select min(PONTOS.PONTO_DATA) DATA_INI_CONT, SUM(PONTOS.PONTO_VALOR) PONTUAÇÃO, PONTOS.SÓCIO_MAT, CUR.FASE, sysdate, COUNT(PONTOS.SÓCIO_MAT) QTD_REGS, VALIDACERTIFICADO(SUM(PONTO_VALOR), CUR.TOTAL_PONTO) as CERTIF_IMPRIMIR
                   from SBDB.EMCD_PONTO_SÓCIO PONTOS,(select SBDB_PROX_FASE_CERTIF_L.MAT, SBDB_PROX_FASE_CERTIF_L.NAFASE
                                                      from(select MAT, CUR.FASE APURACAO, EMCD.VALIDAFASE(MAT, CUR.FASE) as NAFASE
                                                           FROM SBDB.SÓCIO
                                                           WHERE SBDB.LB.LEXIBEDATA(DATA_CADASTRO,'yyyy') <= ANO AND EXCLUÍDO = 0)	SBDB_PROX_FASE_CERTIF_L
                                                       WHERE SBDB_PROX_FASE_CERTIF_L.APURACAO = CUR.FASE AND SBDB_PROX_FASE_CERTIF_L.NAFASE = - 1) AD_00_SÓCIOS_EM_CADA_FASE
                  where PONTOS.PONTO_DATA >= CUR.DATA_INICIO and PONTOS.PONTO_DATA <= CUR.DATA_FINAL and PONTOS.SÓCIO_MAT (+) = AD_00_SÓCIOS_EM_CADA_FASE.MAT
                  GROUP BY PONTOS.SÓCIO_MAT, AD_00_SÓCIOS_EM_CADA_FASE.NAFASE 
                  order by PONTOS.SÓCIO_MAT)
      WHERE SBDB.LB.LEXIBEDATA(DATA_INI_CONT,'yyyy') = ANO;
      COMMIT;
  END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR( - 20000, 'Erro em Emitir_Extrato: ' || SQLERRM) ;
  END;



END EMCD;

/

-- OBJETO 205 | PACKAGE | SITE
create or replace PACKAGE "SITE" AS
  FUNCTION GERAR_SENHA RETURN VARCHAR2;
END SITE;
/

create or replace PACKAGE BODY "SITE" AS
  FUNCTION GERAR_SENHA RETURN VARCHAR2 IS
    NOVASENHA VARCHAR2(5);
  BEGIN
    NOVASENHA := DBMS_RANDOM.STRING('A', 5);
    RETURN NOVASENHA;
  END GERAR_SENHA;
END SITE;
/

-- OBJETO 217 | VISÃO | VW_EDITORIAL_ASSINATURAS
CREATE OR REPLACE VIEW SBDB.VW_EDITORIAL_ASSINATURAS AS SELECT E.SEQ AS EDITORIAL_SEQ ,
    A.SEQ       AS ASSINATURA_SEQ,
    E.NOME                       ,
    E.NOME_2                     ,
    A.DATA_INICIO                ,
    A.DATA_FINAL                 ,
    A.TIPO_ASSINATURA            ,
    A.TIPO_REMESSA               ,
    A.TIPO_POSTAGEM              ,
    E.EMAIL                      ,
    E.ESTADO                     ,
    E.PAÍS
     FROM EDITORIAL E
  LEFT JOIN EDITORIAL_TIPO_ASSINATURA A
       ON E.SEQ = A.EDITORIAL_SEQ
 GROUP BY E.SEQ      ,
    A.SEQ            ,
    E.NOME           ,
    E.NOME_2         ,
    E.EMAIL          ,
    E.ESTADO         ,
    E.PAÍS           ,
    A.DATA_INICIO    ,
    A.DATA_FINAL     ,
    A.TIPO_ASSINATURA,
    A.TIPO_REMESSA   ,
    A.TIPO_POSTAGEM
/

-- OBJETO 218 | VISÃO | VW_FIN_CHECK_OBRIG_STATUS
CREATE OR REPLACE VIEW SBDB.VW_FIN_CHECK_OBRIG_STATUS AS SELECT S.MAT, S.obrig_status_cod STATUS_FIN_SOCIO, F.OBRIG_STATUS_COD STATUS_FIN_OBRIG
/*
  TODOS ASSOCIADOS */
FROM SBDB.SÓCIO S,
/*
  BUSCANDO POSSÍVEIS STATUS EM OBRIGAÇÃO PARA CADA ASSOCIADO */
(SELECT SÓCIO_MAT, WM_CONCAT(OBRIG_STATUS_COD) OBRIG_STATUS_COD FROM
(SELECT O.SÓCIO_MAT, O.OBRIG_STATUS_COD FROM SBDB.OBRIGAÇÃO O WHERE NOT
O.obrig_status_cod IN ('CANCELADA','SUBSTITUIDA')
GROUP BY O.SÓCIO_MAT, O.OBRIG_STATUS_COD ORDER BY O.SÓCIO_MAT,O.OBRIG_STATUS_COD) GROUP BY SÓCIO_MAT) F
WHERE
S.EXCLUÍDO = 0 AND
S.MAT = F.SÓCIO_MAT (+)
/

-- OBJETO 219 | VISÃO | VW_SOCIO_ATRIB_GRUPO
CREATE OR REPLACE VIEW SBDB.VW_SOCIO_ATRIB_GRUPO AS SELECT ROWNUM SEQ  ,
  GR.CAT_FIN CAT_FIN,
  P.CONTEUDO GRUPO
   FROM
  (SELECT CATEGORIA_COD
    || '+'
    || OBRIG_STATUS_COD CAT_FIN
     FROM SBDB.SÓCIO
 GROUP BY CATEGORIA_COD,
    OBRIG_STATUS_COD
  ) GR         ,
  (SELECT CHAVE,
    CONTEUDO
     FROM TABLE
    (SELECT DICT(CONFIG,'|')
       FROM SBDB.SYS_CONFIG_GLOBAL
      WHERE PARAM = 'SOCIO_ATRIB_GRUPO'
    )
  ) P
  WHERE GR.CAT_FIN = CHAVE (+)
/

-- OBJETO 220 | VISÃO | VW_SOCIO_ATIVO
CREATE OR REPLACE VIEW SBDB.VW_SOCIO_ATIVO AS SELECT
      S.MAT,
      S.NOME,
      S.CATEGORIA_COD,
      S.REGIONAL_COD,
      S.OBRIG_STATUS_COD,
      S.OBRIG_STATUS_DATA,
      S.ISENTO,
      S.CRM,
      S.CRM_ESTADO,
      S.CRM_DATA,
      S.CPF,
      S.DATA_CADASTRO,
      S.DATA_NASCIMENTO,
      S.SEXO,
      S.NACIONALIDADE,
      S.NATURALIDADE,
      S.FILIAÇÃO_PAI,
      S.FILIAÇÃO_MÃE,
      S.MALA_DIRETA,
      S.ENDEREÇO_RESIDENCIAL || DECODE(S.NUMERO_RESIDENCIAL, NULL, '', ', ') || S.NUMERO_RESIDENCIAL || DECODE(S.COMPLEMENTO_RESIDENCIAL, NULL, '', '/ ') || S.COMPLEMENTO_RESIDENCIAL AS ENDEREÇO_RESIDENCIAL,
      S.BAIRRO_RESIDENCIAL,
      S.CIDADE_RESIDENCIAL,
      DECODE(S.PAÍS_RESIDENCIAL, 'BRASIL', S.ESTADO_RESIDENCIAL, S.ESTADO_RESIDENCIAL_EX) AS ESTADO_RESIDENCIAL,
      S.PAÍS_RESIDENCIAL,
      S.CEP_RESIDENCIAL,
      S.DDI_RESIDENCIAL,
      S.DDD_RESIDENCIAL,
      S.TEL_RESIDENCIAL,
      S.FAX_RESIDENCIAL,
      S.TEL_CELULAR_RESIDENCIAL,
      S.EMAIL_RESIDENCIAL,
      S.ENDEREÇO_COMERCIAL_1 || DECODE(S.NUMERO_COMERCIAL_1, NULL, '', ', ') || S.NUMERO_COMERCIAL_1 || DECODE(S.COMPLEMENTO_COMERCIAL_1, NULL, '', '/ ') || S.COMPLEMENTO_COMERCIAL_1 AS ENDEREÇO_COMERCIAL_1,
      S.BAIRRO_COMERCIAL_1,
      S.CIDADE_COMERCIAL_1,
      DECODE(S.PAÍS_COMERCIAL_1, 'BRASIL', S.ESTADO_COMERCIAL_1, S.ESTADO_COMERCIAL_1_EX) AS ESTADO_COMERCIAL_1,
      S.PAÍS_COMERCIAL_1,
      S.CEP_COMERCIAL_1,
      S.DDI_COMERCIAL_1,
      S.DDD_COMERCIAL_1,
      S.TEL_COMERCIAL_1,
      S.FAX_COMERCIAL_1,
      S.EMAIL_COMERCIAL_1,
      S.ENDEREÇO_COMERCIAL_2 || DECODE(S.NUMERO_COMERCIAL_2, NULL, '', ', ') || S.NUMERO_COMERCIAL_2 || DECODE(S.COMPLEMENTO_COMERCIAL_2, NULL, '', '/ ') || S.COMPLEMENTO_COMERCIAL_2 AS ENDEREÇO_COMERCIAL_2,
      S.BAIRRO_COMERCIAL_2,
      S.CIDADE_COMERCIAL_2,
      DECODE(S.PAÍS_COMERCIAL_2, 'BRASIL', S.ESTADO_COMERCIAL_2, S.ESTADO_COMERCIAL_2_EX) AS ESTADO_COMERCIAL_2,
      S.CEP_COMERCIAL_2,
      S.PAÍS_COMERCIAL_2,
      S.DDI_COMERCIAL_2,
      S.DDD_COMERCIAL_2,
      S.TEL_COMERCIAL_2,
      S.FAX_COMERCIAL_2,
      S.EMAIL_COMERCIAL_2,
      S.TED,
      S.TED_ANO_CONCURSO,
      S.TED_DATA_EXPEDIÇÃO,
      S.TED_DATA_APROVAÇÃO,
      S.TED_IMPRESSÃO,
      S.UNIVERSIDADE_NOME,
      S.UNIVERSIDADE_DATA_FORMA,
      S.UNIVERSIDADE_LOCAL,
      S.RESIDÊNCIA_1_NOME,
      S.RESIDÊNCIA_1_DATA_INI,
      S.RESIDÊNCIA_1_DATA_FIM,
      S.RESIDÊNCIA_1_LOCAL,
      S.RESIDÊNCIA_2_NOME,
      S.RESIDÊNCIA_2_DATA_INI,
      S.RESIDÊNCIA_2_DATA_FIM,
      S.RESIDÊNCIA_2_LOCAL,
      S.RESIDÊNCIA_3_NOME,
      S.RESIDÊNCIA_3_LOCAL,
      S.RESIDÊNCIA_3_DATA_FIM,
      S.RESIDÊNCIA_3_DATA_INI,
      S.TITULAÇÃO,
      S.PÓS_DOUTORADO_NOME,
      S.PÓS_DOUTORADO_INST,
      S.PÓS_DOUTORADO_LOCAL,
      S.PÓS_DOUTORADO_DATA,
      S.LIVRE_DOCÊNCIA_NOME,
      S.LIVRE_DOCÊNCIA_INST,
      S.LIVRE_DOCÊNCIA_LOCAL,
      S.LIVRE_DOCÊNCIA_DATA,
      S.DOUTORADO_NOME,
      S.DOUTORADO_INST,
      S.DOUTORADO_LOCAL,
      S.DOUTORADO_DATA,
      S.MESTRADO_NOME,
      S.MESTRADO_INST,
      S.MESTRADO_LOCAL,
      S.MESTRADO_DATA,
      S.PESQUISA_TEMA,
      S. TRABALHO1_NOME,
      S.TRABALHO1_CARGO,
      S.TRABALHO2_NOME,
      S.TRABALHO2_CARGO,
      S.TRABALHO3_NOME,
      S.TRABALHO3_CARGO,
      S.OBS,
      S.EMCD_DATA_IMP_ETIQ,
      S.EMCD_IMP_ETIQ,
      S.EXCLUÍDO,
      S.MOTIVO_EXCLUSÃO,
      S.DATA_EXCLUSÃO,
      S.RESP_EXCLUSÃO,
      S.DATA_INICIO_CONTAGEM,
      S.IDENTIDADE,
      S.ID_ORGAO,
      S.ESTADO_CIVIL,
      S.CFM_ADESAO,
      S.CFM_OBS,
      S.PENALIZADO,
      S.NOME_PREFERENCIAL,
      S.SENHA,
      S.REG_LOG,
      S.TRATAMENTO,
      S.QUALIF_PROF,
      S.QUALIF_PROF_I,
      S.QUALIF_PROF_E,
      S.OBRIG_STATUS_LOG,
      S.SITE,
      S.FALECIDO,
      S.SOCIO_ELETRONICO,
      S.PUBLICAR_COMERCIAL_1,
      S.PUBLICAR_COMERCIAL_2,
      S.SYS_MOMENTO_CRIA,
      S.SYS_USUARIO_CRIA,
      S.SYS_LOCAL_CRIA,
      S.SYS_MOMENTO_ATUALIZA,
      S.SYS_USUARIO_ATUALIZA,
      S.SYS_LOCAL_ATUALIZA,
      S.SYS_STATUS,
      DECODE(NVL(S.TRATAMENTO, ''), '', '', S.TRATAMENTO || ' ') || NVL(S.NOME_PREFERENCIAL, S.NOME) AS NOME_APRES
    FROM
      SBDB.SÓCIO S
    WHERE
      S.EXCLUÍDO = 0
/

-- OBJETO 221 | VISÃO | VW_LOGIN_EMAIL
CREATE OR REPLACE VIEW SBDB.VW_LOGIN_EMAIL AS SELECT DISTINCT EMAIL.MAT,
  EMAIL.EMAIL            ,
  SC.CRM_ESTADO          ,
  SC.CRM                 ,
  SC.SENHA               ,
  SC.NOME                ,
  SC.CPF                 ,
  SC.CATEGORIA_COD       ,
  SC.OBRIG_STATUS_COD    ,
  SC.CNRM                ,
  DECODE(NVL(TRATAMENTO,''),'','',TRATAMENTO
  || ' ')
  || NVL(NOME_PREFERENCIAL,NOME) AS NOME_APRES
   FROM
  (SELECT MAT,
    EMAIL_RESIDENCIAL EMAIL
     FROM SÓCIO
    WHERE NOT EMAIL_RESIDENCIAL IS NULL
    UNION
   SELECT MAT,
    EMAIL_COMERCIAL_1 EMAIL
     FROM SÓCIO
    WHERE NOT EMAIL_COMERCIAL_1 IS NULL
    UNION
   SELECT MAT,
    EMAIL_COMERCIAL_2 EMAIL
     FROM SÓCIO
    WHERE NOT EMAIL_COMERCIAL_2 IS NULL
  ) EMAIL,
  SBDB.SÓCIO SC
  WHERE EMAIL.MAT = SC.MAT
AND SC.EXCLUÍDO   = 0
/

-- OBJETO 225 | VISÃO | VW_LOGIN_GERAL
CREATE OR REPLACE VIEW SBDB.VW_LOGIN_GERAL AS SELECT C.USUARIO,
  C.SENHAABERTA  ,
  C.NOME_APRES   ,
  C.MAT          ,
  C.CATEGORIA_COD,
  C.OBRIG_STATUS_COD,
  P.CONTEUDO GRUPO
   FROM
  (
  /*
  --
  -- LOGIN POR EMAIL VÁLIDO
  */
   SELECT EM.EMAIL USUARIO ,
    EM.SENHA AS SENHAABERTA,
    NOME_APRES             ,
    EM.CATEGORIA_COD       ,
    EM.OBRIG_STATUS_COD    ,
    EM.MAT
     FROM SBDB.VW_LOGIN_EMAIL EM
UNION ALL
  /*
  --
  -- LOGIN POR CRM ESTADO DE USUÁRIOS SEM EMAIL
  */
   SELECT S.CRM_ESTADO
    || ' '
    || S.CRM USUARIO   ,
    S.SENHA SENHAABERTA,
    S.NOME_APRES       ,
    S.CATEGORIA_COD    ,
    S.OBRIG_STATUS_COD ,
    S.MAT
     FROM SBDB.VW_SOCIO_ATIVO S,
    SBDB.VW_LOGIN_EMAIL VW
    WHERE S.MAT = VW.MAT (+)
  AND VW.MAT   IS NULL
  ) C,
  TABLE
  (SELECT DICT(CONFIG,'|')
     FROM SBDB.SYS_CONFIG_GLOBAL
    WHERE PARAM = 'SOCIO_ATRIB_GRUPO'
  ) P
  WHERE (C.CATEGORIA_COD
  || '+'
  || C.OBRIG_STATUS_COD) = P.CHAVE (+)
UNION ALL
/*
--
-- USUÁRIOS ADMINISTRATIVOS E OPERADORES DO SISTEMA
*/
 SELECT USUARIO       ,
  SENHA AS SENHAABERTA,
  NOME  AS NOME_APRES ,
  NULL AS MAT         ,
  NULL AS CATEGORIA_COD,
  NULL AS OBRIG_STATUS_COD,
  GRUPO
   FROM SBDB.GER_USUARIO
WHERE (VALIDO_ATE IS NULL
OR VALIDO_ATE       <= TRUNC(SYSDATE))
/

-- OBJETO 300 | VISÃO | BIBLIO_LANCAMENTO_PEDIDO
CREATE OR REPLACE VIEW SBDB.BIBLIO_LANCAMENTO_PEDIDO AS SELECT Q."COD",
  Q."VALOR"    ,
  (SELECT L2.DATA
     FROM BIBLIO_LANCAMENTO L2
    WHERE L2.COD_PEDIDO = Q.COD
  AND ROWNUM            = 1
  ) AS DATA
   FROM
  (SELECT P.COD,
    SUM(ABS(L1.VALOR)) AS VALOR
     FROM BIBLIO_LANCAMENTO L1
  INNER JOIN BIBLIO_PEDIDO P
       ON L1.COD_PEDIDO = P.COD
    WHERE CANCELADO     = 0
 GROUP BY P.COD
  ) Q
/

-- OBJETO 301 | VISÃO | BIBLIO_SERVICO_PRECO_ATUAL
CREATE OR REPLACE VIEW SBDB.BIBLIO_SERVICO_PRECO_ATUAL AS SELECT S.COD    ,
  S.DESCRICAO    ,
  S.OBS          ,
  SP.PRECO_ASSOC ,
  SP.PRECO_NASSOC,
  SP.DATA
   FROM BIBLIO_SERVICO S
LEFT JOIN BIBLIO_SERVICO_PRECO SP
     ON S.COD = SP.COD_SERVICO
  WHERE SP.SEQ=
  (SELECT MAX(SEQ) FROM BIBLIO_SERVICO_PRECO WHERE COD_SERVICO = S.COD
  )
/

-- OBJETO 302 | VISÃO | DEMOGRAF
CREATE OR REPLACE VIEW SBDB.DEMOGRAF AS SELECT S.MAT, S.NOME , S.REGIONAL_COD AS REGIONAL, RG.ESTADO,
       S.DATA_INICIO_CONTAGEM, UF.REGIAO,
       S.CATEGORIA_COD CATEGORIA, A.PONTUAÇÃO, A.APURACAO AS FASE
FROM SBDB.SÓCIO S,
     SBDB.REGIONAL RG,
     SBDB.ESTADO UF,
     SBDB.EMCD_APURAÇÃO A
WHERE S.REGIONAL_COD = RG.COD (+) AND
      RG.ESTADO = UF.SIGLA (+) AND
      S.EXCLUÍDO = 0 AND
      S.MAT = A.SÓCIO_MAT (+)
ORDER BY A.APURACAO DESC
/

-- OBJETO 303 | VISÃO | EMCD_CURSO_ANO
CREATE OR REPLACE VIEW SBDB.EMCD_CURSO_ANO AS SELECT
ANO,
SUM(ASPIRANTE) AS ASPIRANTE,
SUM(BENEMÉRITO) AS BENEMÉRITO,
SUM(COLABORADOR) AS COLABORADOR,
SUM(CONTRIBUINTE) AS CONTRIBUINTE,
SUM(CORRESPONDENTE) AS CORRESPONDENTE,
SUM(TITULAR) AS TITULAR,
SUM(ESTRANGEIRO) AS ESTRANGEIRO,
SUM(HONORÁRIO) AS HONORÁRIO
FROM(
SELECT
ANO,
SUM(CASE WHEN (ASPIRANTE=1) AND (BENEMÉRITO=0) AND (COLABORADOR=0) AND (CONTRIBUINTE=0) AND (CORRESPONDENTE=0) AND (TITULAR=0) AND (ESTRANGEIRO=0) AND (HONORÁRIO=0) THEN 1 ELSE DECODE(CAT,'ASPIRANTE',1,0) END) AS ASPIRANTE,
SUM(CASE WHEN (BENEMÉRITO=1) AND (ASPIRANTE=0) AND (COLABORADOR=0) AND (CONTRIBUINTE=0) AND (CORRESPONDENTE=0) AND (TITULAR=0) AND (ESTRANGEIRO=0) AND (HONORÁRIO=0) THEN 1 ELSE DECODE(CAT,'BENEMÉRITO',1,0) END) AS BENEMÉRITO,
SUM(CASE WHEN (COLABORADOR=1) AND (BENEMÉRITO=0) AND (ASPIRANTE=0) AND (CONTRIBUINTE=0) AND (CORRESPONDENTE=0) AND (TITULAR=0) AND (ESTRANGEIRO=0) AND (HONORÁRIO=0) THEN 1 ELSE DECODE(CAT,'COLABORADOR',1,0) END) AS COLABORADOR,
SUM(CASE WHEN (CONTRIBUINTE=1) AND (BENEMÉRITO=0) AND (COLABORADOR=0) AND (ASPIRANTE=0) AND (CORRESPONDENTE=0) AND (TITULAR=0) AND (ESTRANGEIRO=0) AND (HONORÁRIO=0) THEN 1 ELSE DECODE(CAT,'CONTRIBUINTE',1,0) END) AS CONTRIBUINTE,
SUM(CASE WHEN (CORRESPONDENTE=1) AND (BENEMÉRITO=0) AND (COLABORADOR=0) AND (CONTRIBUINTE=0) AND (ASPIRANTE=0) AND (TITULAR=0) AND (ESTRANGEIRO=0) AND (HONORÁRIO=0) THEN 1 ELSE DECODE(CAT,'CORRESPONDENTE',1,0) END) AS CORRESPONDENTE,
SUM(CASE WHEN (TITULAR=1) AND (BENEMÉRITO=0) AND (COLABORADOR=0) AND (CONTRIBUINTE=0) AND (CORRESPONDENTE=0) AND (ASPIRANTE=0) AND (ESTRANGEIRO=0) AND (HONORÁRIO=0) THEN 1 ELSE DECODE(CAT,'TITULAR',1,0) END) AS TITULAR,
SUM(CASE WHEN (ESTRANGEIRO=1) AND (BENEMÉRITO=0) AND (COLABORADOR=0) AND (CONTRIBUINTE=0) AND (CORRESPONDENTE=0) AND (TITULAR=0) AND (ASPIRANTE=0) AND (HONORÁRIO=0) THEN 1 ELSE DECODE(CAT,'ESTRANGEIRO',1,0) END) AS ESTRANGEIRO,
SUM(CASE WHEN (HONORÁRIO=1) AND (BENEMÉRITO=0) AND (COLABORADOR=0) AND (CONTRIBUINTE=0) AND (CORRESPONDENTE=0) AND (TITULAR=0) AND (ESTRANGEIRO=0) AND (ASPIRANTE=0) THEN 1 ELSE DECODE(CAT,'HONORÁRIO',1,0) END) AS HONORÁRIO
FROM (
SELECT
SÓCIO_MAT,
ANO,
SUM(ASPIRANTE) AS ASPIRANTE,
SUM(BENEMÉRITO) AS BENEMÉRITO,
SUM(COLABORADOR) AS COLABORADOR,
SUM(CONTRIBUINTE) AS CONTRIBUINTE,
SUM(CORRESPONDENTE) AS CORRESPONDENTE,
SUM(TITULAR) AS TITULAR,
SUM(ESTRANGEIRO) AS ESTRANGEIRO,
SUM(HONORÁRIO) AS HONORÁRIO,
CAT
FROM (
SELECT
SÓCIO_MAT,
ANO,
SUM(ASPIRANTE) AS ASPIRANTE,
SUM(BENEMÉRITO) AS BENEMÉRITO,
SUM(COLABORADOR) AS COLABORADOR,
SUM(CONTRIBUINTE) AS CONTRIBUINTE,
SUM(CORRESPONDENTE) AS CORRESPONDENTE,
SUM(TITULAR) AS TITULAR,
SUM(ESTRANGEIRO) AS ESTRANGEIRO,
SUM(HONORÁRIO) AS HONORÁRIO,
LAST_VALUE(CATEGORIA_COD) OVER (ORDER BY SÓCIO_MAT) AS CAT
FROM
(
SELECT
ANO,
sócio_mat,max_data_alt_cat,CATEGORIA_COD,
DECODE(CATEGORIA_COD,'ASPIRANTE',1,0) AS ASPIRANTE,
DECODE(CATEGORIA_COD,'BENEMÉRITO',1,0) AS BENEMÉRITO,
DECODE(CATEGORIA_COD,'COLABORADOR',1,0) AS COLABORADOR,
DECODE(CATEGORIA_COD,'CONTRIBUINTE',1,0) AS CONTRIBUINTE,
DECODE(CATEGORIA_COD,'CORRESPONDENTE',1,0) AS CORRESPONDENTE,
DECODE(CATEGORIA_COD,'TITULAR',1,0) AS TITULAR,
DECODE(CATEGORIA_COD,'ESTRANGEIRO',1,0) AS ESTRANGEIRO,
DECODE(CATEGORIA_COD,'HONORÁRIO',1,0) AS HONORÁRIO
FROM
(
	select
	ps.sócio_mat,
	ps.ativ_cod,
	max(lcat.data_alteração) max_data_alt_cat,
	max(lcat.seq) max_seq_alt_cat,
	LCAT.CATEGORIA_COD,
	TO_CHAR(ps.ponto_data,'YYYY') AS ANO
	from
	emcd_ponto_sócio ps,
	(select sócio_mat, seq, CATEGORIA_COD,data_alteração from sócio_categoria) lcat
	where
	ps.sócio_mat = lcat.sócio_mat (+)
	and
	ps.ponto_data > lcat.data_alteração
	/*and
	(ps.sócio_mat = 3551 OR ps.sócio_mat = 150)*/
	group by
	ps.sócio_mat,
	ps.ativ_cod,
	LCAT.CATEGORIA_COD,TO_CHAR(ps.ponto_data,'YYYY')
)
GROUP BY
ANO,
sócio_mat,
max_data_alt_cat,
max_seq_alt_cat,
CATEGORIA_COD)
GROUP BY
ANO,SÓCIO_MAT,max_data_alt_cat,CATEGORIA_COD
ORDER BY ANO)
GROUP BY
SÓCIO_MAT,
ANO,
CAT)
GROUP BY
ANO,
CAT)
GROUP
BY
ANO
/

-- OBJETO 304 | VISÃO | REL_AGENDATEL
CREATE OR REPLACE VIEW SBDB.REL_AGENDATEL AS SELECT
	regional_cod,
	LPAD(MAT, 5, '0') AS MAT,
	nome,
  DECODE(LTRIM(TEL_RESIDENCIAL),NULL,'', DECODE(LTRIM(DDI_RESIDENCIAL),NULL,'','+ ' ||DDI_RESIDENCIAL) || DECODE(LTRIM(DDD_RESIDENCIAL),NULL,'',' (' ||DDD_RESIDENCIAL ||') ') || TEL_RESIDENCIAL) AS TEL_RESIDENCIAL,
  DECODE(LTRIM(TEL_COMERCIAL_1),NULL,'', DECODE(LTRIM(DDI_COMERCIAL_1),NULL,'','+ ' ||DDI_COMERCIAL_1) || DECODE(LTRIM(DDD_COMERCIAL_1),NULL,'',' (' ||DDD_COMERCIAL_1 ||') ') || TEL_COMERCIAL_1) AS TEL_COMERCIAL_1,
  DECODE(LTRIM(FAX_COMERCIAL_1),NULL,'', DECODE(LTRIM(DDI_COMERCIAL_1),NULL,'','+ ' ||DDI_COMERCIAL_1) || DECODE(LTRIM(DDD_COMERCIAL_1),NULL,'',' (' ||DDD_COMERCIAL_1 ||') ') || FAX_COMERCIAL_1) AS FAX_COMERCIAL_1,
  DECODE(LTRIM(TEL_COMERCIAL_2),NULL,'', DECODE(LTRIM(DDI_COMERCIAL_2),NULL,'','+ ' ||DDI_COMERCIAL_2) || DECODE(LTRIM(DDD_COMERCIAL_2),NULL,'',' (' ||DDD_COMERCIAL_2 ||') ') || TEL_COMERCIAL_2) AS TEL_COMERCIAL_2,
  DECODE(LTRIM(TEL_CELULAR_RESIDENCIAL),NULL,'', DECODE(LTRIM(DDI_RESIDENCIAL),NULL,'','+ ' || DDI_RESIDENCIAL) || DECODE(LTRIM(DDD_RESIDENCIAL),NULL,'',' (' ||DDD_RESIDENCIAL ||') ') || TEL_CELULAR_RESIDENCIAL) AS TTEL_CELULAR_RESIDENCIAL
FROM
	SBDB.SÓCIO
WHERE
	MAT > 0 AND EXCLUÍDO = 0
/

-- OBJETO 305 | VISÃO | REL_ASSOCANIV
CREATE OR REPLACE VIEW SBDB.REL_ASSOCANIV AS SELECT
 EXTRACT(MONTH FROM DATA_NASCIMENTO) AS MES1,
LB.LEXIBEDATA(DATA_NASCIMENTO, 'mmmm') AS MES,
	lpad(EXTRACT(DAY FROM DATA_NASCIMENTO), 2, '0')AS DIA,
	LPAD(MAT, 5, '0') AS MAT,
	NOME,
  TRUNC((SYSDATE - DATA_NASCIMENTO) / 365) || ' anos' AS IDADE
FROM
	SBDB.SÓCIO
WHERE
	EXCLUÍDO = 0 AND MAT > 0
ORDER BY
	MES1,
	DIA
/

-- OBJETO 306 | VISÃO | SOCIO_ENDERECO
CREATE OR REPLACE VIEW SBDB.SOCIO_ENDERECO AS SELECT
      MAT,
      NOME,
      CPF,
      CRM,
      EXCLUÍDO,
      OBRIG_STATUS_COD,
      CATEGORIA_COD,
      REGIONAL_COD,
      PENALIZADO,
      SOCIO_ELETRONICO,
      DATA_CADASTRO,
      TED_DATA_APROVAÇÃO,
      TED_ANO_CONCURSO,
      TIPO_END,
      ENDEREÇO_MALAD,
      BAIRRO_MALAD,
      CIDADE_MALAD,
      ESTADO_MALAD,
      PAÍS_MALAD,
      CEP_MALAD,
      DDI_MALAD,
      DDD_MALAD,
      TEL_MALAD,
      FAX_MALAD,
      TEL_CELULAR_MALAD,
      EMAIL_MALAD
    FROM
      (SELECT
          MAT,
          NOME,
          CPF,
          CRM_ESTADO||CRM AS CRM,
          EXCLUÍDO,
          OBRIG_STATUS_COD,
          CATEGORIA_COD,
          REGIONAL_COD,
          PENALIZADO,
          SOCIO_ELETRONICO,
          DATA_CADASTRO,
          TED_DATA_APROVAÇÃO,
          TED_ANO_CONCURSO,
          'MALA' AS TIPO_END,
          DECODE(MALA_DIRETA, 'R', ENDEREÇO_RESIDENCIAL||DECODE(NUMERO_RESIDENCIAL, NULL, '', ', ') ||NUMERO_RESIDENCIAL||DECODE(COMPLEMENTO_RESIDENCIAL, NULL, '', '/ ') ||COMPLEMENTO_RESIDENCIAL, '1', ENDEREÇO_COMERCIAL_1||DECODE(NUMERO_COMERCIAL_1, NULL, '', ', ') ||NUMERO_COMERCIAL_1||DECODE(COMPLEMENTO_COMERCIAL_1, NULL, '', '/ ') ||COMPLEMENTO_COMERCIAL_1, '2', ENDEREÇO_COMERCIAL_2||DECODE(NUMERO_COMERCIAL_2, NULL, '', ', ') ||NUMERO_COMERCIAL_2||DECODE(COMPLEMENTO_COMERCIAL_2, NULL, '', '/ ') ||COMPLEMENTO_COMERCIAL_2) AS ENDEREÇO_MALAD,
          DECODE(MALA_DIRETA, 'R', BAIRRO_RESIDENCIAL, '1', BAIRRO_COMERCIAL_1, '2', BAIRRO_COMERCIAL_2) AS BAIRRO_MALAD,
          DECODE(MALA_DIRETA, 'R', CIDADE_RESIDENCIAL, '1', CIDADE_COMERCIAL_1, '2', CIDADE_COMERCIAL_2) AS CIDADE_MALAD,
          DECODE(MALA_DIRETA, 'R', DECODE(PAÍS_RESIDENCIAL, 'BRASIL', ESTADO_RESIDENCIAL, ESTADO_RESIDENCIAL_EX), '1', DECODE(PAÍS_COMERCIAL_1, 'BRASIL', ESTADO_COMERCIAL_1, ESTADO_COMERCIAL_1_EX), '2', DECODE(PAÍS_COMERCIAL_2, 'BRASIL', ESTADO_COMERCIAL_2, ESTADO_COMERCIAL_2_EX)) AS ESTADO_MALAD,
          DECODE(MALA_DIRETA, 'R', PAÍS_RESIDENCIAL, '1', PAÍS_COMERCIAL_1, '2', PAÍS_COMERCIAL_2) AS PAÍS_MALAD,
          DECODE(MALA_DIRETA, 'R', CEP_RESIDENCIAL, '1', CEP_COMERCIAL_1, '2', CEP_COMERCIAL_2) AS CEP_MALAD,
          DECODE(MALA_DIRETA, 'R', DDI_RESIDENCIAL, '1', DDI_COMERCIAL_1, '2', DDI_COMERCIAL_2) AS DDI_MALAD,
          DECODE(MALA_DIRETA, 'R', DDD_RESIDENCIAL, '1', DDD_COMERCIAL_1, '2', DDD_COMERCIAL_2) AS DDD_MALAD,
          DECODE(MALA_DIRETA, 'R', TEL_RESIDENCIAL, '1', TEL_COMERCIAL_1, '2', TEL_COMERCIAL_2) AS TEL_MALAD,
          DECODE(MALA_DIRETA, 'R', FAX_RESIDENCIAL, '1', FAX_COMERCIAL_1, '2', FAX_COMERCIAL_2) AS FAX_MALAD,
          DECODE(MALA_DIRETA, 'R', TEL_CELULAR_RESIDENCIAL, '1', NULL) AS TEL_CELULAR_MALAD,
          DECODE(MALA_DIRETA, 'R', EMAIL_RESIDENCIAL, '1', EMAIL_COMERCIAL_1, '2', EMAIL_COMERCIAL_2) AS EMAIL_MALAD
        FROM
          SBDB.SÓCIO
      )
    UNION
        (SELECT
            MAT,
            NOME,
            CPF,
            CRM_ESTADO||CRM AS CRM,
            EXCLUÍDO,
            OBRIG_STATUS_COD,
            CATEGORIA_COD,
            REGIONAL_COD,
            PENALIZADO,
            SOCIO_ELETRONICO,
            DATA_CADASTRO,
            TED_DATA_APROVAÇÃO,
            TED_ANO_CONCURSO,
            'RESIDENCIAL' AS TIPO_END,
            ENDEREÇO_RESIDENCIAL||DECODE(NUMERO_RESIDENCIAL, NULL, '', ', ') ||NUMERO_RESIDENCIAL||DECODE(COMPLEMENTO_RESIDENCIAL, NULL, '', '/ ') ||COMPLEMENTO_RESIDENCIAL AS ENDEREÇO_MALAD,
            BAIRRO_RESIDENCIAL AS BAIRRO_MALAD,
            CIDADE_RESIDENCIAL AS CIDADE_MALAD,
            DECODE(PAÍS_RESIDENCIAL, 'BRASIL', ESTADO_RESIDENCIAL, ESTADO_RESIDENCIAL_EX) AS ESTADO_MALAD,
            PAÍS_RESIDENCIAL AS PAÍS_MALAD,
            CEP_RESIDENCIAL AS CEP_MALAD,
            DDI_RESIDENCIAL AS DDI_MALAD,
            DDD_RESIDENCIAL AS DDD_MALAD,
            TEL_RESIDENCIAL AS TEL_MALAD,
            FAX_RESIDENCIAL AS FAX_MALAD,
            TEL_CELULAR_RESIDENCIAL AS TEL_CELULAR_MALAD,
            EMAIL_RESIDENCIAL AS EMAIL_MALAD
          FROM
            SBDB.SÓCIO
        )
      UNION
          (SELECT
              MAT,
              NOME,
              CPF,
              CRM_ESTADO||CRM AS CRM,
              EXCLUÍDO,
              OBRIG_STATUS_COD,
              CATEGORIA_COD,
              REGIONAL_COD,
              PENALIZADO,
              SOCIO_ELETRONICO,
              DATA_CADASTRO,
              TED_DATA_APROVAÇÃO,
              TED_ANO_CONCURSO,
              'COMERCIAL_1' AS TIPO_END,
              ENDEREÇO_COMERCIAL_1||DECODE(NUMERO_COMERCIAL_1, NULL, '', ', ') ||NUMERO_COMERCIAL_1||DECODE(COMPLEMENTO_COMERCIAL_1, NULL, '', '/ ') ||COMPLEMENTO_COMERCIAL_1 AS ENDEREÇO_MALAD,
              BAIRRO_COMERCIAL_1 AS BAIRRO_MALAD,
              CIDADE_COMERCIAL_1 AS CIDADE_MALAD,
              DECODE(PAÍS_COMERCIAL_1, 'BRASIL', ESTADO_COMERCIAL_1, ESTADO_COMERCIAL_1_EX) AS ESTADO_MALAD,
              PAÍS_COMERCIAL_1 AS PAÍS_MALAD,
              CEP_COMERCIAL_1 AS CEP_MALAD,
              DDI_COMERCIAL_1 AS DDI_MALAD,
              DDD_COMERCIAL_1 AS DDD_MALAD,
              TEL_COMERCIAL_1 AS TEL_MALAD,
              FAX_COMERCIAL_1 AS FAX_MALAD,
              '' AS TEL_CELULAR_MALAD,
              EMAIL_COMERCIAL_1 AS EMAIL_MALAD
            FROM
              SBDB.SÓCIO
          )
        UNION
            (SELECT
                MAT,
                NOME,
                CPF,
                CRM_ESTADO||CRM AS CRM,
                EXCLUÍDO,
                OBRIG_STATUS_COD,
                CATEGORIA_COD,
                REGIONAL_COD,
                PENALIZADO,
                SOCIO_ELETRONICO,
                DATA_CADASTRO,
                TED_DATA_APROVAÇÃO,
                TED_ANO_CONCURSO,
                'COMERCIAL_2' AS TIPO_END,
                ENDEREÇO_COMERCIAL_2||DECODE(NUMERO_COMERCIAL_2, NULL, '', ', ') ||NUMERO_COMERCIAL_2||DECODE(COMPLEMENTO_COMERCIAL_2, NULL, '', '/ ') ||COMPLEMENTO_COMERCIAL_2 AS ENDEREÇO_MALAD,
                BAIRRO_COMERCIAL_2 AS BAIRRO_MALAD,
                CIDADE_COMERCIAL_2 AS CIDADE_MALAD,
                DECODE(PAÍS_COMERCIAL_2, 'BRASIL', ESTADO_COMERCIAL_2, ESTADO_COMERCIAL_2_EX) AS ESTADO_MALAD,
                PAÍS_COMERCIAL_2 AS PAÍS_MALAD,
                CEP_COMERCIAL_2 AS CEP_MALAD,
                DDI_COMERCIAL_2 AS DDI_MALAD,
                DDD_COMERCIAL_2 AS DDD_MALAD,
                TEL_COMERCIAL_2 AS TEL_MALAD,
                FAX_COMERCIAL_2 AS FAX_MALAD,
                '' AS TEL_CELULAR_MALAD,
                EMAIL_COMERCIAL_2 AS EMAIL_MALAD
              FROM
                SBDB.SÓCIO
            )
          ORDER BY
            MAT
/

-- OBJETO 307 | VISÃO | REL_ASSOCCIDADE
CREATE OR REPLACE VIEW SBDB.REL_ASSOCCIDADE AS SELECT
	LPAD(S.MAT,5,'0') AS MAT,
	S.NOME,
	S.CATEGORIA_COD,
	S.REGIONAL_COD,
	S.OBRIG_STATUS_COD,
	SE.ENDEREÇO_MALAD,
	SE.BAIRRO_MALAD,
	SE.CIDADE_MALAD,
	SE.ESTADO_MALAD,
	SE.PAÍS_MALAD,
	SE.CEP_MALAD,
	DECODE(LTRIM(SE.TEL_MALAD), NULL, '', DECODE(LTRIM(SE.DDI_MALAD), NULL, '', '+ ' ||SE.DDI_MALAD) || DECODE(LTRIM(SE.DDD_MALAD), NULL, '', ' (' ||SE.DDD_MALAD ||') ') || SE.TEL_MALAD) AS TEL_MALAD,
	DECODE(LTRIM(SE.FAX_MALAD), NULL, '', DECODE(LTRIM(SE.DDI_MALAD), NULL, '', '+ ' ||SE.DDI_MALAD) || DECODE(LTRIM(SE.DDD_MALAD), NULL, '', ' (' ||SE.DDD_MALAD ||') ') || SE.FAX_MALAD) AS FAX_MALAD,
	DECODE(LTRIM(SE.TEL_CELULAR_MALAD), NULL, '', DECODE(LTRIM(SE.DDI_MALAD), NULL, '', '+ ' || SE.DDI_MALAD) || DECODE(LTRIM(SE.DDD_MALAD), NULL, '', ' (' ||SE.DDD_MALAD ||') ') || SE.TEL_CELULAR_MALAD) AS TEL_CELULAR_MALAD,
	SE.EMAIL_MALAD
FROM
	SBDB.SÓCIO S,
	SBDB.SOCIO_ENDERECO SE
WHERE
	S.MAT > 0 AND S.EXCLUÍDO = 0 AND S.MAT = SE.MAT AND SE.TIPO_END = 'MALA'
/

-- OBJETO 307 | VISÃO | REL_ASSOCREGIONAL
CREATE OR REPLACE VIEW SBDB.REL_ASSOCREGIONAL AS SELECT
	regional_cod,
	LPAD(MAT,5,'0') AS MAT,
	nome,
	categoria_cod,
	obrig_status_cod,
	data_cadastro
FROM
	SBDB.SÓCIO
WHERE
	MAT > 0 AND EXCLUÍDO = 0
/

-- OBJETO 308 | VISÃO | REL_ASSOCSERVCRED
CREATE OR REPLACE VIEW SBDB.REL_ASSOCSERVCRED AS SELECT LPAD(S.MAT, 5, '0') AS MAT                         ,
  S.NOME                                                   ,
  EXTRACT(YEAR FROM S.TED_ANO_CONCURSO) AS TED_ANO_CONCURSO,
  S.RESIDÊNCIA_1_DATA_INI                                  ,
  S.RESIDÊNCIA_1_DATA_FIM                                  ,
  SC.SERVIÇO_NOME                                          ,
  SC.QTD_VAGAS                                             ,
  SC.ESTADO                                                ,
  S.RESIDÊNCIA_1_NOME AS SERVIÇO
   FROM SBDB.SÓCIO S,
  SBDB.SERVIÇO_CREDENCIADO SC
  WHERE S.EXCLUÍDO       = 0
AND S.MAT               >= 0
AND S.RESIDÊNCIA_1_LOCAL = 'DERMATOLOGIA'
AND S.RESIDÊNCIA_1_NOME  = SC.INSTITUIÇÃO(+)
AND SC.CREDENCIADO       = 'S'
  UNION
 SELECT LPAD(S.MAT, 5, '0') AS MAT                         ,
  S.NOME                                                   ,
  EXTRACT(YEAR FROM S.TED_ANO_CONCURSO) AS TED_ANO_CONCURSO,
  S.RESIDÊNCIA_2_DATA_INI                                  ,
  S.RESIDÊNCIA_2_DATA_FIM                                  ,
  SC.SERVIÇO_NOME                                          ,
  SC.QTD_VAGAS                                             ,
  SC.ESTADO                                                ,
  S.RESIDÊNCIA_2_NOME AS SERVIÇO
   FROM SBDB.SÓCIO S,
  SBDB.SERVIÇO_CREDENCIADO SC
  WHERE S.EXCLUÍDO       = 0
AND S.MAT               >= 0
AND S.RESIDÊNCIA_1_LOCAL = 'DERMATOLOGIA'
AND S.RESIDÊNCIA_1_NOME  = SC.INSTITUIÇÃO(+)
AND SC.CREDENCIADO       = 'S'
  UNION
 SELECT LPAD(S.MAT, 5, '0') AS MAT                         ,
  S.NOME                                                   ,
  EXTRACT(YEAR FROM S.TED_ANO_CONCURSO) AS TED_ANO_CONCURSO,
  S.RESIDÊNCIA_3_DATA_INI                                  ,
  S.RESIDÊNCIA_3_DATA_FIM                                  ,
  SC.SERVIÇO_NOME                                          ,
  SC.QTD_VAGAS                                             ,
  SC.ESTADO                                                ,
  S.RESIDÊNCIA_3_NOME AS SERVIÇO
   FROM SBDB.SÓCIO S,
  SBDB.SERVIÇO_CREDENCIADO SC
  WHERE S.EXCLUÍDO       = 0
AND S.MAT               >= 0
AND S.RESIDÊNCIA_1_LOCAL = 'DERMATOLOGIA'
AND S.RESIDÊNCIA_1_NOME  = SC.INSTITUIÇÃO(+)
AND SC.CREDENCIADO       = 'S'
/

-- OBJETO 309 | VISÃO | REL_ASSOCSIMPLES
CREATE OR REPLACE VIEW SBDB.REL_ASSOCSIMPLES AS SELECT LPAD(MAT, 5, '0') AS MAT                      ,
  NOME                                                ,
  TO_CHAR(DATA_CADASTRO,'dd/mm/yyyy') AS DATA_CADASTRO,
  REGIONAL_COD                                        ,
  CRM_ESTADO                                          ,
  CRM                                                 ,
  CPF                                                 ,
  CATEGORIA_COD                                       ,
  OBRIG_STATUS_COD                                    ,
  DECODE(SYS_USUARIO_ATUALIZA,NULL,SYS_USUARIO_CRIA,SYS_USUARIO_ATUALIZA) AS USUARIO
   FROM SBDB.SÓCIO
  WHERE EXCLUÍDO = 0
AND MAT          > 0
/

-- OBJETO 310 | VISÃO | REL_DECLARAPROVTED
CREATE OR REPLACE VIEW SBDB.REL_DECLARAPROVTED AS   SELECT 'Declaramos que' || CASE WHEN S.sexo = 'M' THEN ' o Dr. ' || initcap(S.nome) ELSE ' a Dra. ' || initcap(S.nome) END || ', obteve aprovação no ' ||
    (SELECT CONFIG FROM SBDB.SYS_CONFIG_GLOBAL WHERE PARAM = 'TÍTULO__TED'
    ) || ', realizado pela Sociedade Brasileira de Dermatologia em convênio com a Associação Médica Brasileira, no dia ' ||
    (SELECT CONFIG FROM SBDB.SYS_CONFIG_GLOBAL WHERE PARAM = 'DATA_TED'
    ) ||
    (SELECT CONFIG FROM SBDB.SYS_CONFIG_GLOBAL WHERE PARAM = 'CIDADE_TED'
    ) || '.' AS TEXTO, (SELECT CONFIG FROM SBDB.SYS_CONFIG_GLOBAL WHERE PARAM = 'EMISSAO_TED'
    ) AS DATA_EMISSAO, (SELECT CONFIG FROM SBDB.SYS_CONFIG_GLOBAL WHERE PARAM = 'PRESIDENTE'
    ) AS PRESIDENTE FROM SBDB.SÓCIO S WHERE S.MAT > 0 AND S.OBRIG_STATUS_COD NOT IN ('LICENCIADO','RECENTE') AND S.PENALIZADO = 'N' AND S.EXCLUÍDO = 0
/

-- OBJETO 311 | VISÃO | REL_DECLARASBDISENTO
CREATE OR REPLACE VIEW SBDB.REL_DECLARASBDISENTO AS SELECT 'Declaramos que'
  ||
  CASE
    WHEN S.SEXO = 'M'
    THEN ' o Dr. '
      || INITCAP(S.NOME)
    ELSE ' a Dra. '
      || INITCAP(S.NOME)
  END
  || ', é associado da Sociedade Brasileira de Dermatologia, na categoria de associado '
  || S.CATEGORIA_COD
  || ', estando '
  ||
  CASE
    WHEN S.SEXO = 'M'
    THEN ' isento '
    ELSE 'isenta'
  END
  || ' da contribuição anual por ter completado 70 anos de idade, como rege o Estatuto da SBD.' AS TEXTO,
  (SELECT INITCAP(NOME)
     FROM SBDB.SÓCIO
    WHERE MAT =
    (SELECT MAX(SÓCIO_MAT) KEEP (DENSE_RANK LAST
   ORDER BY ÓRGÃO_NOME,ÓRGÃO_CARGO,ÓRGÃO_GESTÃO_INI)
       FROM SBDB.ÓRGÃO_MEMBRO
      WHERE ÓRGÃO_NOME='DIRETORIA SBD'
    AND ÓRGÃO_CARGO   ='PRESIDENTE'
   GROUP BY ÓRGÃO_NOME,
      ÓRGÃO_CARGO
    )
  ) AS PRESIDENTE,
  'Rio de Janeiro, '
  || LB.LEXIBEDATA(SYSDATE,'p') AS DATA_EMISSAO
   FROM SBDB.SÓCIO S
  WHERE S.MAT          > 0
AND S.PENALIZADO       = 'N'
AND S.EXCLUÍDO         = 0
AND S.OBRIG_STATUS_COD = 'ISENTO'
/

-- OBJETO 312 | VISÃO | REL_FICHACADASTRO
CREATE OR REPLACE VIEW SBDB.REL_FICHACADASTRO AS SELECT LPAD(S.MAT,5,'0') AS MAT                    ,
  S.NOME                                            ,
  SBDB.LB.LEXIBEDATA(S.DATA_CADASTRO,'sd') as DATA_CADASTRO                                  ,
  S.CPF                                             ,
  S.IDENTIDADE                                      ,
  S.ID_ORGAO                                        ,
  S.ESTADO_CIVIL                                    ,
  SBDB.LB.LEXIBEDATA(S.DATA_NASCIMENTO,'sd') as DATA_NASCIMENTO                                 ,
  DECODE(S.SEXO,'M','MASCULINO','FEMININO') AS SEXO ,
  S.REGIONAL_COD                                    ,
  S.CRM_ESTADO || ' - ' || S.CRM AS CRM             ,
  SBDB.LB.LEXIBEDATA(S.CRM_DATA,'sd') as CRM_DATA                                 ,
  SBDB.LB.LEXIBEDATA(S.TED_DATA_EXPEDIÇÃO,'sd') as TED_DATA_EXPEDIÇÃO                                 ,
  S.NATURALIDADE                                               ,
  S.NACIONALIDADE                                              ,
  SBDB.LB.LEXIBEDATA(S.TED_DATA_APROVAÇÃO,'sd') as ED_TED_DATA_APROVAÇÃO                                 ,
  S.CATEGORIA_COD                                              ,
  S.OBRIG_STATUS_COD                                           ,
  DECODE(S.SOCIO_ELETRONICO,0,'NÃO','SIM') AS SOCIO_ELETRONICO ,
  DECODE(S.PENALIZADO,'N','NÃO','SIM')     AS PENALIZADO       ,
  S.SITE                                                       ,
  SE.ENDEREÇO_MALAD                                            ,
  SE.BAIRRO_MALAD                                              ,
  SE.CIDADE_MALAD                                              ,
  SE.ESTADO_MALAD                                              ,
  SE.PAÍS_MALAD                                                ,
  SE.CEP_MALAD                                                 ,
  DECODE(LTRIM(SE.TEL_MALAD),NULL,'', DECODE(LTRIM(SE.DDI_MALAD),NULL,'','+ ' ||SE.DDI_MALAD) || DECODE(LTRIM(SE.DDD_MALAD),NULL,'',' (' ||SE.DDD_MALAD ||') ') || SE.TEL_MALAD) AS TEL_MALAD,
  DECODE(LTRIM(SE.FAX_MALAD),NULL,'', DECODE(LTRIM(SE.DDI_MALAD),NULL,'','+ ' ||SE.DDI_MALAD) || DECODE(LTRIM(SE.DDD_MALAD),NULL,'',' (' ||SE.DDD_MALAD ||') ') || SE.FAX_MALAD) AS FAX_MALAD,
  DECODE(LTRIM(SE.TEL_CELULAR_MALAD),NULL,'', DECODE(LTRIM(SE.DDI_MALAD),NULL,'','+ ' || SE.DDI_MALAD) || DECODE(LTRIM(SE.DDD_MALAD),NULL,'',' (' ||SE.DDD_MALAD ||') ') || SE.TEL_CELULAR_MALAD) AS TEL_CELULAR_MALAD, SE.EMAIL_MALAD                               ,
  S.UNIVERSIDADE_NOME                          ,
  S.UNIVERSIDADE_LOCAL                         ,
  S.UNIVERSIDADE_DATA_FORMA                    ,
  S.RESIDÊNCIA_1_NOME                          ,
  S.RESIDÊNCIA_1_LOCAL                         ,
  S.RESIDÊNCIA_1_DATA_INI                      ,
  S.RESIDÊNCIA_1_DATA_FIM                      ,
  S.RESIDÊNCIA_2_NOME                          ,
  S.RESIDÊNCIA_2_LOCAL                         ,
  S.RESIDÊNCIA_2_DATA_INI                      ,
  S.RESIDÊNCIA_2_DATA_FIM                      ,
  S.RESIDÊNCIA_3_NOME                          ,
  S.RESIDÊNCIA_3_LOCAL                         ,
  S.RESIDÊNCIA_3_DATA_FIM                      ,
  S.RESIDÊNCIA_3_DATA_INI                      ,
  S.PÓS_DOUTORADO_NOME                         ,
  S.PÓS_DOUTORADO_INST                         ,
  S.PÓS_DOUTORADO_LOCAL                        ,
  S.PÓS_DOUTORADO_DATA                         ,
  S.LIVRE_DOCÊNCIA_NOME                        ,
  S.LIVRE_DOCÊNCIA_INST                        ,
  S.LIVRE_DOCÊNCIA_LOCAL                       ,
  S.LIVRE_DOCÊNCIA_DATA                        ,
  S.DOUTORADO_NOME                             ,
  S.DOUTORADO_INST                             ,
  S.DOUTORADO_LOCAL                            ,
  S.DOUTORADO_DATA                             ,
  S.MESTRADO_NOME                              ,
  S.MESTRADO_INST                              ,
  S.MESTRADO_LOCAL                             ,
  S.MESTRADO_DATA                              ,
  S.PESQUISA_TEMA                              ,
  S.TRABALHO1_NOME                             ,
  S.TRABALHO1_CARGO                            ,
  S.TRABALHO2_NOME                             ,
  S.TRABALHO2_CARGO                            ,
  S.TRABALHO3_NOME                             ,
  S.TRABALHO3_CARGO                            ,
  S.OBS
   FROM SBDB.SÓCIO S,
  SBDB.SOCIO_ENDERECO SE
  WHERE S.MAT > 0 AND S.EXCLUÍDO = 0 AND S.MAT   = SE.MAT
AND SE.TIPO_END = 'MALA'
/

-- OBJETO 313 | VISÃO | REL_LISTENDSIMPLES
CREATE OR REPLACE VIEW SBDB.REL_LISTENDSIMPLES AS   SELECT
	LPAD(MAT, 5, '0') AS MAT,
	nome,
	categoria_cod,
	regional_cod,
	obrig_status_cod,
	TO_CHAR(obrig_status_data, 'DD/MM/YYYY') AS obrig_status_data,
	CRM_ESTADO || ' - ' || CRM AS CRM             ,
	data_cadastro,
	DECODE(SEXO, 'M', 'MASCULINO', 'FEMININO') AS SEXO,
	ENDEREÇO_RESIDENCIAL||DECODE (NUMERO_RESIDENCIAL,NULL,'',', ')||NUMERO_RESIDENCIAL||DECODE (COMPLEMENTO_RESIDENCIAL,NULL,'','/ ')||COMPLEMENTO_RESIDENCIAL AS ENDEREÇO_RESIDENCIAL,
	BAIRRO_RESIDENCIAL,
	CIDADE_RESIDENCIAL,
	DECODE(PAÍS_RESIDENCIAL, 'BRASIL', ESTADO_RESIDENCIAL, ESTADO_RESIDENCIAL_EX) AS ESTADO_RESIDENCIAL,
	PAÍS_RESIDENCIAL,
	CEP_RESIDENCIAL,
  DECODE(LTRIM(TEL_RESIDENCIAL),NULL,'', DECODE(LTRIM(DDI_RESIDENCIAL),NULL,'','+ ' ||DDI_RESIDENCIAL) || DECODE(LTRIM(DDD_RESIDENCIAL),NULL,'',' (' ||DDD_RESIDENCIAL ||') ') || TEL_RESIDENCIAL) AS TEL_RESIDENCIAL,
  DECODE(LTRIM(FAX_RESIDENCIAL),NULL,'', DECODE(LTRIM(DDI_RESIDENCIAL),NULL,'','+ ' ||DDI_RESIDENCIAL) || DECODE(LTRIM(DDD_RESIDENCIAL),NULL,'',' (' ||DDD_RESIDENCIAL ||') ') || FAX_RESIDENCIAL) AS FAX_RESIDENCIAL,
  DECODE(LTRIM(TEL_CELULAR_RESIDENCIAL),NULL,'', DECODE(LTRIM(DDI_RESIDENCIAL),NULL,'','+ ' || DDI_RESIDENCIAL) || DECODE(LTRIM(DDD_RESIDENCIAL),NULL,'',' (' ||DDD_RESIDENCIAL ||') ') || TEL_CELULAR_RESIDENCIAL) AS TEL_CELULAR_RESIDENCIAL,
  EMAIL_RESIDENCIAL,
	ENDEREÇO_COMERCIAL_1||DECODE (NUMERO_COMERCIAL_1,NULL,'',', ')||NUMERO_COMERCIAL_1||DECODE (COMPLEMENTO_COMERCIAL_1,NULL,'','/ ')||COMPLEMENTO_COMERCIAL_1 AS ENDEREÇO_COMERCIAL_1,
	BAIRRO_COMERCIAL_1,
	CIDADE_COMERCIAL_1,
	DECODE(PAÍS_COMERCIAL_1, 'BRASIL', ESTADO_COMERCIAL_1, ESTADO_COMERCIAL_1_EX) AS ESTADO_COMERCIAL_1,
	PAÍS_COMERCIAL_1,
	CEP_COMERCIAL_1,
  DECODE(LTRIM(TEL_COMERCIAL_1),NULL,'', DECODE(LTRIM(DDI_COMERCIAL_1),NULL,'','+ ' ||DDI_COMERCIAL_1) || DECODE(LTRIM(DDD_COMERCIAL_1),NULL,'',' (' ||DDD_COMERCIAL_1 ||') ') || TEL_COMERCIAL_1) AS TEL_COMERCIAL_1,
  DECODE(LTRIM(FAX_COMERCIAL_1),NULL,'', DECODE(LTRIM(DDI_COMERCIAL_1),NULL,'','+ ' ||DDI_COMERCIAL_1) || DECODE(LTRIM(DDD_COMERCIAL_1),NULL,'',' (' ||DDD_COMERCIAL_1 ||') ') || FAX_COMERCIAL_1) AS FAX_COMERCIAL_1D,
	EMAIL_COMERCIAL_1
FROM
	SBDB.SÓCIO
WHERE
	MAT > 0 AND EXCLUÍDO = 0
/

-- OBJETO 314 | VISÃO | REL_PAGDEL
CREATE OR REPLACE VIEW SBDB.REL_PAGDEL AS SELECT LPAD(MAT, 5, '0') AS MAT,
  NOME                          ,
  OBRIG_TIPO                    ,
  REGIONAL_COD                  ,
  VAL_OBRIG                     ,
  DATA                          ,
  DESCONTO                      ,
  MULTA                         ,
  TARIFA                        ,
  VAL_PGTO
   FROM
  (SELECT MAT   ,
    NOME        ,
    SEQ         ,
    OBRIG_TIPO  ,
    REGIONAL_COD,
    VAL_OBRIG
     FROM
    (SELECT MAT                                 , NOME, REGIONAL_COD FROM SBDB.SÓCIO WHERE EXCLUÍDO = 0
    ) S                                         ,
    (SELECT SÓCIO_MAT                           ,
      SEQ                                       ,
      OBRIG_TIPO                                ,
      TO_CHAR(COMPETÊNCIA,'YYYY') AS COMPETENCIA,
      VALOR                       AS VAL_OBRIG
       FROM SBDB.OBRIGAÇÃO
    ) O
    WHERE S.MAT    = O.SÓCIO_MAT
  AND O.COMPETENCIA='2009'
  ) O              ,
  (SELECT SÓCIO_MAT,
    OBRIG_SEQ      ,
    SEQ            ,
    DATA           ,
    DESCONTO       ,
    MULTA          ,
    TARIFA         ,
    VALOR AS VAL_PGTO
     FROM SBDB.PAGAMENTO
  ) P
  WHERE O.MAT      = P.SÓCIO_MAT
AND O.SEQ          = P.OBRIG_SEQ
AND ( O.OBRIG_TIPO = 'ANUIDADE - COTA ÚNICA'
OR O.OBRIG_TIPO    = 'ANUIDADE-PARCELA 1'
OR O.OBRIG_TIPO    = 'ANUIDADE-PARCELA 2'
OR O.OBRIG_TIPO    = 'ANUIDADE-PARCELA 3'
OR O.OBRIG_TIPO    = 'ANUIDADES'
OR O.OBRIG_TIPO    = 'DESPESAS BIBLIOTECA'
OR O.OBRIG_TIPO    = 'PARCELAMENTO')
ORDER BY DATA DESC
/

-- OBJETO 316 | VISÃO | REL_RECIBO
CREATE OR REPLACE VIEW SBDB.REL_RECIBO AS SELECT S.MAT                         ,
  S.NOME                              ,
  S.REGIONAL_COD                      ,
  P.VALOR                             ,
  P.DESCONTO                          ,
  LB.LEXTENSO(P.VALOR,'R$') AS EXTENSO,
  O.OBRIG_TIPO
  ||' '
  || TO_CHAR (O.COMPETÊNCIA, 'YYYY') AS REFERENCIA,
  P.DATA                                          ,
  O.BANCO                                         ,
  O.AGÊNCIA                                       ,
  O.CONTA_CORRENTE                                ,
  O.NR_CHEQUE                                     ,
  'Rio de Janeiro, '
  || LB.LEXIBEDATA(SYSDATE,'p') AS DATAIMP
   FROM SBDB.OBRIGAÇÃO O,
  SBDB.PAGAMENTO P      ,
  SBDB.SÓCIO S
  WHERE S.MAT   > 0
AND EXCLUÍDO    = 0
AND S.MAT       = O.SÓCIO_MAT
AND O.SÓCIO_MAT = P.SÓCIO_MAT
AND O.SEQ       = P.OBRIG_SEQ
AND P.SÓCIO_MAT = '3'
AND P.OBRIG_SEQ = '15'
/

-- OBJETO 317 | VISÃO | REL_REGIONALCOMPL
CREATE OR REPLACE VIEW SBDB.REL_REGIONALCOMPL AS SELECT SIGLA,
  REGIONAL   ,
  ENDEREÇO   ,
  BAIRRO     ,
  CIDADE     ,
  ESTADO     ,
  CEP        ,
  TELFONE_REG,
  FAX        ,
  E_MAIL     ,
  CONTATO    ,
  DDD        ,
  SITE       ,
  PRESIDENTE ,
  TELEFONE
   FROM
  (SELECT COD AS SIGLA   ,
    NOME      AS REGIONAL,
    ENDEREÇO             ,
    BAIRRO               ,
    CIDADE               ,
    ESTADO               ,
    CEP                  ,
    TEL AS TELFONE_REG   ,
    FAX                  ,
    E_MAIL               ,
    CONTATO              ,
    DDD                  ,
    SITE
     FROM REGIONAL
  ) R                 ,
  (SELECT MAT         ,
    NOME            AS PRESIDENTE,
    TEL_COMERCIAL_1 AS TELEFONE
     FROM SBDB.SÓCIO
    WHERE MAT  > 0
  AND EXCLUÍDO = 0
  ) S                                         ,
  (SELECT TRIM(SUBSTR(ÓRGÃO_NOME,11,3)) AS REG,
    ÓRGÃO_NOME                                ,
    MAX(SÓCIO_MAT)        AS SÓCIO_MAT               ,
    MAX(ÓRGÃO_GESTÃO_INI) AS GESTÃO_INI
     FROM ÓRGÃO_MEMBRO
    WHERE ÓRGÃO_CARGO='PRESIDENTE'
 GROUP BY ÓRGÃO_NOME
  ) OM
  WHERE R.SIGLA = OM.REG
AND S.MAT       = OM.SÓCIO_MAT
/

-- OBJETO 318 | VISÃO | REL_SERVCRED
CREATE OR REPLACE VIEW SBDB.REL_SERVCRED AS   SELECT LPAD(SERV.COD,5,'0')  AS COD       ,
  SERV.INSTITUIÇÃO      ,
  SERV.SERVIÇO_NOME     ,
  SERV.DEPTO            ,
  SERV.SÓCIO_MAT        ,
  SERV.ENDEREÇO         ,
  SERV.BAIRRO           ,
  SERV.CIDADE           ,
  SERV.ESTADO           ,
  SERV.CEP              ,
  SERV.PAÍS             ,
  SERV.DDI              ,
  SERV.DDD              ,
  SERV.TEL              ,
  SERV.RAMAL            ,
  SERV.FAX              ,
  SERV.QTD_VAGAS        ,
  EXTRACT(YEAR FROM SERV.DATAFIM) - EXTRACT(YEAR FROM SERV.DATAINI) AS ANO,
  SERV.OBS              ,
  SERV.CONTATO          ,
  SERV.EMAIL            ,
  SERV.SITE             ,
  SERV.CREDENCIADO      ,
  SERV.MAT              ,
  SERV.NOME             ,
  SERV.EMAIL_RESIDENCIAL,
  SERV.E_C              ,
  SERV.EMAIL_COMERCIAL_2,
  SERV.ENDEREÇO_MALAD   ,
  SERV.BAIRRO_MALAD     ,
  SERV.CIDADE_MALAD     ,
  SERV.ESTADO_MALAD     ,
  SERV.PAÍS_MALAD       ,
  SERV.CEP_MALAD        ,
  SERV.DDI_MALAD        ,
  SERV.DDD_MALAD        ,
  SERV.TEL_MALAD        ,
  SERV.FAX_MALAD        ,
  SERV.EMAIL_MALAD      ,
  SERV.TEL_CELULAR_MALAD,
  SERV.SERV_CRED_COD    ,
  SERV.DATAINI          ,
  SERV.DATAFIM          ,
  SERV.ENDEREÇO_COM     ,
  SERV.BAIRRO_COM       ,
  SERV.CIDADE_COM       ,
  SERV.ESTADO_COM       ,
  SERV.PAÍS_COM         ,
  SERV.CEP_COM          ,
  SERV.DDI_COM          ,
  SERV.DDD_COM          ,
  SERV.TEL_COM          ,
  SERV.FAX_COM          ,
  SERV.EMAIL_COM
   FROM
  (SELECT SC.COD                                                         ,
    SC.INSTITUIÇÃO                                                       ,
    SC.SERVIÇO_NOME                                                      ,
    SC.DEPTO                                                             ,
    SC.SÓCIO_MAT                                                         ,
    SC.ENDEREÇO                                                          ,
    SC.BAIRRO                                                            ,
    SC.CIDADE                                                            ,
    SC.ESTADO                                                            ,
    SC.CEP                                                               ,
    SC.PAÍS                                                              ,
    SC.DDI                                                               ,
    SC.DDD                                                               ,
    SC.TEL                                                               ,
    SC.RAMAL                                                             ,
    SC.FAX                                                               ,
    SC.QTD_VAGAS                                                         ,
    SC.OBS                                                               ,
    SC.CONTATO                                                           ,
    SC.EMAIL                                                             ,
    SC.SITE                                                             ,
    SC.CREDENCIADO                                                       ,
    S.MAT                                                                ,
    S.NOME                                                               ,
    S.EMAIL_RESIDENCIAL                                                  ,
    S.EMAIL_COMERCIAL_1 AS E_C                                           ,
    S.EMAIL_COMERCIAL_2                                                  ,
    S.ENDEREÇO_RESIDENCIAL||DECODE (S.NUMERO_RESIDENCIAL,NULL,'',', ')||S.NUMERO_RESIDENCIAL||DECODE (S.COMPLEMENTO_RESIDENCIAL,NULL,'','/ ')||S.COMPLEMENTO_RESIDENCIAL AS ENDEREÇO_MALAD                             ,
    S.BAIRRO_RESIDENCIAL   AS BAIRRO_MALAD                               ,
    S.CIDADE_RESIDENCIAL   AS CIDADE_MALAD                               ,
    S.ESTADO_RESIDENCIAL   AS ESTADO_MALAD                               ,
    S.PAÍS_RESIDENCIAL     AS PAÍS_MALAD                                 ,
    S.CEP_RESIDENCIAL      AS CEP_MALAD                                  ,
    S.DDI_RESIDENCIAL      AS DDI_MALAD                                  ,
    S.DDD_RESIDENCIAL DDD_MALAD                                          ,
    S.TEL_RESIDENCIAL         AS TEL_MALAD                               ,
    S.FAX_RESIDENCIAL         AS FAX_MALAD                               ,
    S.EMAIL_RESIDENCIAL       AS EMAIL_MALAD                             ,
    S.TEL_CELULAR_RESIDENCIAL AS TEL_CELULAR_MALAD                       ,
    S.ENDEREÇO_COMERCIAL_1||DECODE (S.NUMERO_COMERCIAL_1,NULL,'',', ')||S.NUMERO_COMERCIAL_1||DECODE (S.COMPLEMENTO_COMERCIAL_1,NULL,'','/ ')||S.COMPLEMENTO_COMERCIAL_1    AS ENDEREÇO_COM                            ,
    S.BAIRRO_COMERCIAL_1      AS BAIRRO_COM                              ,
    S.CIDADE_COMERCIAL_1      AS CIDADE_COM                              ,
    S.ESTADO_COMERCIAL_1      AS ESTADO_COM                              ,
    S.PAÍS_COMERCIAL_1        AS PAÍS_COM                                ,
    S.CEP_COMERCIAL_1         AS CEP_COM                                 ,
    S.DDI_COMERCIAL_1         AS DDI_COM                                 ,
    S.DDD_COMERCIAL_1         AS DDD_COM                                 ,
    S.TEL_COMERCIAL_1         AS TEL_COM                                 ,
    S.FAX_COMERCIAL_1         AS FAX_COM                                 ,
    S.EMAIL_COMERCIAL_1       AS EMAIL_COM                               ,
    SCR.SERV_CRED_COD                                                    ,
    LAST_VALUE(SCR.DATA_INI) OVER (ORDER BY SCR.SERV_CRED_COD) AS DATAINI,
    LAST_VALUE(SCR.DATA_FIM) OVER (ORDER BY SCR.SERV_CRED_COD) AS DATAFIM
     FROM SBDB.SERVIÇO_CREDENCIADO SC,
    SBDB.SÓCIO S                     ,
    SBDB.SERV_CRED_RENOVAÇÃO SCR
    WHERE S.MAT > 0 AND EXCLUÍDO = 0 AND S.MAT (+)       = SC.SÓCIO_MAT
  AND SC.COD              = SCR.SERV_CRED_COD (+)
  AND CREDENCIADO         = 'S'
  ) SERV
GROUP BY SERV.COD       ,
  SERV.INSTITUIÇÃO      ,
  SERV.SERVIÇO_NOME     ,
  SERV.DEPTO            ,
  SERV.SÓCIO_MAT        ,
  SERV.ENDEREÇO         ,
  SERV.BAIRRO           ,
  SERV.CIDADE           ,
  SERV.ESTADO           ,
  SERV.CEP              ,
  SERV.PAÍS             ,
  SERV.DDI              ,
  SERV.DDD              ,
  SERV.TEL              ,
  SERV.RAMAL            ,
  SERV.FAX              ,
  SERV.QTD_VAGAS        ,
  SERV.OBS              ,
  SERV.CONTATO          ,
  SERV.EMAIL            ,
  SERV.SITE            ,
  SERV.CREDENCIADO      ,
  SERV.MAT              ,
  SERV.NOME             ,
  SERV.EMAIL_RESIDENCIAL,
  SERV.E_C              ,
  SERV.EMAIL_COMERCIAL_2,
  SERV.ENDEREÇO_MALAD   ,
  SERV.BAIRRO_MALAD     ,
  SERV.CIDADE_MALAD     ,
  SERV.ESTADO_MALAD     ,
  SERV.PAÍS_MALAD       ,
  SERV.CEP_MALAD        ,
  SERV.DDI_MALAD        ,
  SERV.DDD_MALAD        ,
  SERV.TEL_MALAD        ,
  SERV.FAX_MALAD        ,
  SERV.EMAIL_MALAD      ,
  SERV.TEL_CELULAR_MALAD,
  SERV.SERV_CRED_COD    ,
  SERV.DATAINI          ,
  SERV.DATAFIM          ,
  SERV.ENDEREÇO_COM     ,
  SERV.BAIRRO_COM       ,
  SERV.CIDADE_COM       ,
  SERV.ESTADO_COM       ,
  SERV.PAÍS_COM         ,
  SERV.CEP_COM          ,
  SERV.DDI_COM          ,
  SERV.DDD_COM          ,
  SERV.TEL_COM          ,
  SERV.FAX_COM          ,
  SERV.EMAIL_COM
ORDER BY ESTADO
/

-- OBJETO 320 | VISÃO | VW_AGRUPA_ANO_NOTICIA
CREATE OR REPLACE VIEW SBDB.VW_AGRUPA_ANO_NOTICIA AS SELECT
		EXTRACT(YEAR FROM DATA_CADASTRO) AS ANO
	FROM
		SBDB.SITE_NOTICIA
	GROUP BY
		EXTRACT(YEAR FROM DATA_CADASTRO)
	ORDER BY
		ANO DESC
/

-- OBJETO 325 | VISÃO | VW_SOC_ELETR_ESTAT_CAT_REG
CREATE OR REPLACE VIEW SBDB.VW_SOC_ELETR_ESTAT_CAT_REG AS SELECT
      COD AS REGIONAL_COD,
      COUNT(A.EFEQ) + COUNT(A.EFEIN) + COUNT(A.EFEIS) + COUNT(A.EFELI) TITULAR,
      COUNT(A.EFEQ) TITULARQ,
      COUNT(A.EFEIN) TITULARIN,
      COUNT(A.EFEIS) TITULARIS,
      COUNT(A.EFELI) TITULARLI,
      COUNT(A.ASPQ) + COUNT(A.ASPQ) + COUNT(A.ASPIN) + COUNT(A.ASPLI) ASPIRANTE,
      COUNT(A.ASPQ) ASPIRANTEQ,
      COUNT(A.ASPIN) ASPIRANTEIN,
      COUNT(A.ASPIS) ASPIRANTEIS,
      COUNT(A.ASPLI) ASPIRANTELI,
      COUNT(A.CONQ) + COUNT(A.CONIN) + COUNT(A.CONIS) + COUNT(A.CONLI) CONTRIBUINTE,
      COUNT(A.CONQ) CONTRIBUINTEQ,
      COUNT(A.CONIN) CONTRIBUINTEIN,
      COUNT(A.CONIS) CONTRIBUINTEIS,
      COUNT(A.CONLI) CONTRIBUINTELI,
      COUNT(A.HONQ) + COUNT(A.HONIN) + COUNT(A.HONIS) HONORARIO,
      COUNT(A.HONQ) HONORARIOQ,
      COUNT(A.HONIN) HONORARIOIN,
      COUNT(A.HONIS) HONORARIOIS,
      COUNT(A.BENQ) + COUNT(A.BENIN) + COUNT(A.BENIS) BENEMERITO,
      COUNT(A.BENQ) BENEMERITOQ,
      COUNT(A.BENIN) BENEMERITOIN,
      COUNT(A.BENIS) BENEMERITOIS,
      COUNT(A.CORQ) + COUNT(A.CORIN) + COUNT(A.CORIS) + COUNT(A.CORLI) CORRESPONDENTE,
      COUNT(A.CORQ) CORRESPONDENTEQ,
      COUNT(A.CORIN) CORRESPONDENTEIN,
      COUNT(A.CORIS) CORRESPONDENTEIS,
      COUNT(A.CORLI) CORRESPONDENTELI,
      COUNT(A.COLQ) + COUNT(A.COLIN) + COUNT(A.COLIS) + COUNT(A.COLLI) COLABORADOR,
      COUNT(A.COLQ) COLABORADORQ,
      COUNT(A.COLIN) COLABORADORIN,
      COUNT(A.COLIS) COLABORADORIS,
      COUNT(A.COLLI) COLABORADORLI,
      COUNT(A.COLQ) + COUNT(A.COLIN) + COUNT(A.COLIS) + COUNT(A.COLLI) + COUNT(A.CORQ) + COUNT(A.CORIN) + COUNT(A.CORIS) + COUNT(A.CORLI) + COUNT(A.HONQ) + COUNT(A.HONIN) + COUNT(A.HONIS) + COUNT(A.CONQ) + COUNT(A.CONIN) + COUNT(A.CONIS) + COUNT(A.CONLI) + COUNT(A.ASPQ) + COUNT(A.ASPQ) + COUNT(A.ASPIN) + COUNT(A.ASPLI) + COUNT(A.EFEQ) + COUNT(A.EFEIN) + COUNT(A.EFEIS) + COUNT(A.EFELI) + COUNT(A.BENQ) + COUNT(A.BENIN) + COUNT(A.BENIS) TOTAL
    FROM
      (SELECT
          R.COD,
          S.MAT,
          S.CATEGORIA_COD,
          DECODE(S.PAÍS_RESIDENCIAL, 'BRASIL', S.ESTADO_RESIDENCIAL, S.ESTADO_RESIDENCIAL_EX) AS ESTADO_RESIDENCIAL,
          DECODE(S.PAÍS_COMERCIAL_1, 'BRASIL', S.ESTADO_COMERCIAL_1, S.ESTADO_COMERCIAL_1_EX) AS ESTADO_COMERCIAL_1,
          DECODE(S.PAÍS_COMERCIAL_2, 'BRASIL', S.ESTADO_COMERCIAL_2, S.ESTADO_COMERCIAL_2_EX) AS ESTADO_COMERCIAL_2,
          MALA_DIRETA,
          S.SOCIO_ELETRONICO,
          CASE WHEN(SUBSTR(S.OBRIG_STATUS_COD, 1, 5) = 'QUITE' OR SUBSTR(S.OBRIG_STATUS_COD, 1, 7) = 'RECENTE') AND S.CATEGORIA_COD = 'TITULAR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END EFEQ,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 12) = 'INADIMPLENTE' AND S.CATEGORIA_COD = 'TITULAR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END EFEIN,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 6) = 'ISENTO' AND S.CATEGORIA_COD = 'TITULAR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END EFEIS,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 10) = 'LICENCIADO' AND S.CATEGORIA_COD = 'TITULAR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END EFELI,
          CASE WHEN(SUBSTR(S.OBRIG_STATUS_COD, 1, 5) = 'QUITE' OR SUBSTR(S.OBRIG_STATUS_COD, 1, 7) = 'RECENTE') AND S.CATEGORIA_COD = 'ASPIRANTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END ASPQ,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 12) = 'INADIMPLENTE' AND S.CATEGORIA_COD = 'ASPIRANTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END ASPIN,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 6) = 'ISENTO' AND S.CATEGORIA_COD = 'ASPIRANTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END ASPIS,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 10) = 'LICENCIADO' AND S.CATEGORIA_COD = 'ASPIRANTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END ASPLI,
          CASE WHEN(SUBSTR(S.OBRIG_STATUS_COD, 1, 5) = 'QUITE' OR SUBSTR(S.OBRIG_STATUS_COD, 1, 7) = 'RECENTE') AND S.CATEGORIA_COD = 'CONTRIBUINTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CONQ,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 12) = 'INADIMPLENTE' AND S.CATEGORIA_COD = 'CONTRIBUINTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CONIN,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 6) = 'ISENTO' AND S.CATEGORIA_COD = 'CONTRIBUINTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CONIS,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 10) = 'LICENCIADO' AND S.CATEGORIA_COD = 'CONTRIBUINTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CONLI,
          CASE WHEN(SUBSTR(S.OBRIG_STATUS_COD, 1, 5) = 'QUITE' OR SUBSTR(S.OBRIG_STATUS_COD, 1, 7) = 'RECENTE') AND S.CATEGORIA_COD = 'HONORÁRIO' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END HONQ,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 12) = 'INADIMPLENTE' AND S.CATEGORIA_COD = 'HONORÁRIO' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END HONIN,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 6) = 'ISENTO' AND S.CATEGORIA_COD = 'HONORÁRIO' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END HONIS,
          CASE WHEN(SUBSTR(S.OBRIG_STATUS_COD, 1, 5) = 'QUITE' OR SUBSTR(S.OBRIG_STATUS_COD, 1, 7) = 'RECENTE') AND S.CATEGORIA_COD = 'BENEMÉRITO' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END BENQ,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 12) = 'INADIMPLENTE' AND S.CATEGORIA_COD = 'BENEMÉRITO' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END BENIN,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 6) = 'ISENTO' AND S.CATEGORIA_COD = 'BENEMÉRITO' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END BENIS,
          CASE WHEN(SUBSTR(S.OBRIG_STATUS_COD, 1, 5) = 'QUITE' OR SUBSTR(S.OBRIG_STATUS_COD, 1, 7) = 'RECENTE') AND S.CATEGORIA_COD = 'CORRESPONDENTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CORQ,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 12) = 'INADIMPLENTE' AND S.CATEGORIA_COD = 'CORRESPONDENTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CORIN,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 6) = 'ISENTO' AND S.CATEGORIA_COD = 'CORRESPONDENTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CORIS,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 10) = 'LICENCIADO' AND S.CATEGORIA_COD = 'CORRESPONDENTE' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END CORLI,
          CASE WHEN(SUBSTR(S.OBRIG_STATUS_COD, 1, 5) = 'QUITE' OR SUBSTR(S.OBRIG_STATUS_COD, 1, 7) = 'RECENTE') AND S.CATEGORIA_COD = 'COLABORADOR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END COLQ,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 12) = 'INADIMPLENTE' AND S.CATEGORIA_COD = 'COLABORADOR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END COLIN,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 6) = 'ISENTO' AND S.CATEGORIA_COD = 'COLABORADOR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END COLIS,
          CASE WHEN SUBSTR(S.OBRIG_STATUS_COD, 1, 10) = 'LICENCIADO' AND S.CATEGORIA_COD = 'COLABORADOR' AND S.SOCIO_ELETRONICO = 1 THEN S.MAT
          END COLLI
        FROM
          SBDB.SÓCIO S,
          SBDB.REGIONAL R
        WHERE
          R.COD (+) = S.REGIONAL_COD
        AND S.MAT > 0
        AND S.EXCLUÍDO = 0
        AND( S.PENALIZADO <> 'S'
        OR S.PENALIZADO IS NULL)
      ) A
    GROUP BY
      COD
    ORDER BY
      COD
/

-- OBJETO 500 | FUNCTION | DIF_DATA
create or replace FUNCTION "DIF_DATA" (max_date STRING, min_date STRING)
RETURN PLS_INTEGER IS
BEGIN
  RETURN TO_DATE(max_date) - TO_DATE(min_date);
EXCEPTION
  WHEN OTHERS THEN
  RETURN NULL;
END Dif_Data;
/

-- OBJETO 501 | FUNCTION | STREND
create or replace FUNCTION STREND ( 
   TIPO IN VARCHAR2 := 'LINEAR',
   INITCAP IN CHAR := 'N',
   LOGRADOURO IN VARCHAR2 := '', 
   NUMERO IN VARCHAR2 := '', 
   COMPLEMENTO IN VARCHAR2 := '', 
   BAIRRO IN VARCHAR2 := '', 
   CIDADE IN VARCHAR2 := '', 
   ESTADO IN VARCHAR2 := '', 
   PAIS IN VARCHAR2 := '', 
   CEP IN VARCHAR2 := '', 
   CXPOSTAL IN VARCHAR2 := '',
   OPCIONAL IN VARCHAR2 := '') RETURN VARCHAR2
   AS 
    vETIQUETA VARCHAR2(4000);
    VPROXLINHA VARCHAR2(5);
    VCXPOSTAL VARCHAR2(20);
    VLINHA1 VARCHAR2(4000);
    VLINHA2 VARCHAR2(4000);
    VLINHA3 VARCHAR2(4000);
    VLINHA4 VARCHAR2(4000);
BEGIN
  CASE WHEN PAIS = 'BRASIL' THEN
    VCXPOSTAL := 'CAIXA POSTAL: ';
  ELSE
    VCXPOSTAL := 'PO BOX: ';
  END CASE;
  
  IF UPPER(INITCAP) = 'S' THEN
    VLINHA1 := TRIM(SBDB.LSBD.LPrimLetraMaius(LOGRADOURO)) || 
                CASE WHEN TRIM(NUMERO) IS NOT NULL THEN  ', ' || TRIM(SBDB.LSBD.LPrimLetraMaius(NUMERO)) ELSE TRIM(NUMERO) END || 
                CASE WHEN TRIM(COMPLEMENTO) IS NOT NULL THEN '/' || TRIM( SBDB.LSBD.LPrimLetraMaius(COMPLEMENTO)) ELSE TRIM(COMPLEMENTO) END || 
                CASE WHEN CXPOSTAL IS NOT NULL THEN ' / ' || TRIM(VCXPOSTAL || CXPOSTAL) ELSE CXPOSTAL  END  ; 
    VLINHA2 := TRIM(SBDB.LSBD.LPrimLetraMaius(BAIRRO)) || 
               CASE WHEN TRIM(CIDADE) IS NULL THEN TRIM(CIDADE) ELSE  ' - ' || TRIM( SBDB.LSBD.LPrimLetraMaius(CIDADE)) END || 
               CASE WHEN TRIM(ESTADO) IS NULL THEN TRIM(ESTADO) ELSE  ' - ' || TRIM(UPPER(ESTADO)) END ;
    VLINHA3 := TRIM(SBDB.LSBD.LPrimLetraMaius(PAIS)) || 
               CASE WHEN TRIM(CEP) IS NOT NULL THEN ' - ' || TRIM(CEP) ELSE  TRIM(CEP) END ;
    VLINHA4 := OPCIONAL;
  ELSE
    VLINHA1 := TRIM(LOGRADOURO) || CASE WHEN TRIM(NUMERO) IS NOT NULL THEN ', ' || TRIM(NUMERO) ELSE  TRIM(NUMERO) END || 
                                   CASE WHEN TRIM(COMPLEMENTO) IS NOT NULL THEN '/' || TRIM(COMPLEMENTO) ELSE  TRIM(COMPLEMENTO) END || 
                                   CASE WHEN TRIM(CXPOSTAL) IS NOT NULL THEN ' - ' || TRIM(VCXPOSTAL || CXPOSTAL) ELSE TRIM(CXPOSTAL) END ; 
    
    VLINHA2 := TRIM(BAIRRO) || CASE WHEN TRIM(CIDADE) IS NOT NULL THEN ' - ' || TRIM(CIDADE) ELSE TRIM(CIDADE) END || 
                               CASE WHEN TRIM(ESTADO) IS NOT NULL THEN ' - ' || TRIM(UPPER(ESTADO)) ELSE  TRIM(UPPER(ESTADO)) END ;
                               
    VLINHA3 := TRIM(PAIS) || CASE WHEN TRIM(CEP) IS NOT NULL THEN ' - ' || TRIM(CEP) ELSE  TRIM(CEP) END ;
    VLINHA4 := OPCIONAL;
  END IF;    
  CASE WHEN UPPER(TIPO) = 'ETIQ' THEN
      VPROXLINHA := CHR(13);
  ELSE
      VPROXLINHA := ' - ';
  END CASE;
  vETIQUETA := VLINHA1 || CASE WHEN VLINHA2 IS NULL THEN VLINHA2 ELSE VPROXLINHA || VLINHA2 END || CASE WHEN VLINHA3 IS NULL THEN VLINHA3 ELSE VPROXLINHA || VLINHA3 END || CASE WHEN VLINHA4 IS NULL THEN VLINHA4 ELSE VPROXLINHA || VLINHA4 END;
  RETURN TRIM(vETIQUETA); 
EXCEPTION 
   WHEN OTHERS THEN 
      DECLARE 
         v_sqlerrm VARCHAR2(250) := SUBSTR(SQLERRM,1,250); 
      BEGIN 
        RAISE_APPLICATION_ERROR(-20000,'Erro em STREND: '||v_sqlerrm);     
      END;
END STREND;
/

-- OBJETO 502 | FUNCTION | CONEXAO_VAL
create or replace FUNCTION CONEXAO_VAL
    (
      pUSUARIO_SEQ  NUMBER,
      pUSUARIO_NOME VARCHAR2,
      pIP_CLIENTE   VARCHAR2,
      pLINK_SEQ     NUMBER,
      pIP_SERVIDOR  VARCHAR2,
      pNAVEGADOR    VARCHAR2,
      pMOMENTO_CONFIRM DATE,
      pSLIDE_VISUALIZADO VARCHAR2,
      pMOMENTO_ENTRADA DATE )
    RETURN NUMBER
  IS
    MAXSEQ NUMBER;
  BEGIN
    SELECT NVL(MAX(SEQ),0) + 1 INTO MAXSEQ FROM SEPON.CONEXAO;
    INSERT
    INTO SEPON.CONEXAO
      (
        SEQ,
        USUARIO_SEQ,
        USUARIO_NOME,
        IP_CLIENTE,
        LINK_SEQ,
        IP_SERVIDOR,
        NAVEGADOR,
        MOMENTO_CONFIRM,
        SLIDE_VISUALIZADO,
        MOMENTO_ENTRADA
      )
      VALUES
      (
        MAXSEQ,
        pUSUARIO_SEQ,
        pUSUARIO_NOME,
        pIP_CLIENTE,
        pLINK_SEQ,
        pIP_SERVIDOR,
        pNAVEGADOR,
        pMOMENTO_CONFIRM,
        pSLIDE_VISUALIZADO,
        pMOMENTO_ENTRADA
      );
    RETURN MAXSEQ;
  EXCEPTION
  WHEN OTHERS THEN
    RETURN 0;
  END;
/

-- OBJETO 900 | CRIA_JOBS | JOB
----------------------------------------------------------------------------------------------------
-- CRIA OS JOBS DA BASE
----------------------------------------------------------------------------------------------------
EXEC LB.LCRIA_JOB_N('SBDB - Atualiza Status e Notifica','LSBD.LAtualiza_Geral','00:00:00',1,0,'d');
----------------------------------------------------------------------------------------------------
-- RODA OS JOBS DA BASE
----------------------------------------------------------------------------------------------------
SET SERVEROUTPUT ON SIZE 40000

DECLARE
  QTD NUMBER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM SBDB.SÓCIO;
  IF QTD>0 THEN
    FOR CUR IN
    (SELECT JOB, WHAT FROM USER_JOBS WHERE SCHEMA_USER='SBDB'
    )
    LOOP
      BEGIN
        DBMS_JOB.RUN(CUR.JOB);
      EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM || ' - JOB ' || CUR.WHAT);
      END;
    END LOOP;
  END IF;
END;
/

-- OBJETO 920 | EXEC | VALOR_DEFAULT
ALTER TABLE SBDB.EDITORIAL_TIPO_ASSINATURA MODIFY ( AVISO_REN DEFAULT 1, QUANTIDADE_ASSINATURA DEFAULT 0, TIPO_ASSINATURA DEFAULT 'REVISTA ABD', TIPO_POSTAGEM DEFAULT 'NACIONAL');
ALTER TABLE SBDB.SÓCIO MODIFY ( FALECIDO DEFAULT 0, PENALIZADO DEFAULT 'N', PUBLICAR_COMERCIAL_1 DEFAULT 1, PUBLICAR_COMERCIAL_2 DEFAULT 1, SOCIO_ELETRONICO DEFAULT 1)
/

-- OBJETO 930 | EXEC | CHECK_NOT_NULL
ALTER TABLE SBDB.EDITORIAL_TIPO_ASSINATURA MODIFY TIPO_ASSINATURA NOT NULL;
ALTER TABLE SBDB.ESTADO MODIFY NOME NOT NULL;
ALTER TABLE SBDB.HISTORICO_SOCIO_ELETRONICO MODIFY ( DATA NOT NULL, OPCAO NOT NULL, SOCIO_MAT NOT NULL);
ALTER TABLE SBDB.SERV_CRED_USUARIO MODIFY SENHA NOT NULL;
ALTER TABLE SBDB.SERVIÇO_CREDENCIADO MODIFY CREDENCIADO NOT NULL;
ALTER TABLE SBDB.SÓCIO MODIFY ( PUBLICAR_COMERCIAL_1 NOT NULL, PUBLICAR_COMERCIAL_2 NOT NULL, SENHA NOT NULL, SOCIO_ELETRONICO NOT NULL, MALA_DIRETA NOT NULL)
/

-- OBJETO 940 | GRANT | ATRIB_PUBLIC_VIEW
GRANT SELECT ON SBDB.VW_SOCIO_ATIVO  TO PUBLIC;                 
GRANT SELECT ON SBDB.SOCIO_ENDERECO  TO PUBLIC;                 
GRANT SELECT ON SBDB.BIBLIO_LANCAMENTO_PEDIDO  TO PUBLIC;       
GRANT SELECT ON SBDB.BIBLIO_SERVICO_PRECO_ATUAL  TO PUBLIC;     
GRANT SELECT ON SBDB.DEMOGRAF  TO PUBLIC;                       
GRANT SELECT ON SBDB.EMCD_CURSO_ANO  TO PUBLIC;                 
GRANT SELECT ON SBDB.REL_AGENDATEL  TO PUBLIC;                  
GRANT SELECT ON SBDB.REL_ASSOCANIV  TO PUBLIC;                  
GRANT SELECT ON SBDB.REL_ASSOCCIDADE  TO PUBLIC;                
GRANT SELECT ON SBDB.REL_ASSOCREGIONAL  TO PUBLIC;              
GRANT SELECT ON SBDB.REL_ASSOCSERVCRED  TO PUBLIC;              
GRANT SELECT ON SBDB.REL_ASSOCSIMPLES  TO PUBLIC;               
GRANT SELECT ON SBDB.REL_DECLARAPROVTED  TO PUBLIC;             
GRANT SELECT ON SBDB.REL_DECLARASBDISENTO  TO PUBLIC;           
GRANT SELECT ON SBDB.REL_FICHACADASTRO  TO PUBLIC;              
GRANT SELECT ON SBDB.REL_LISTENDSIMPLES  TO PUBLIC;             
GRANT SELECT ON SBDB.REL_PAGDEL  TO PUBLIC;                     
GRANT SELECT ON SBDB.REL_RECIBO  TO PUBLIC;                     
GRANT SELECT ON SBDB.REL_REGIONALCOMPL  TO PUBLIC;              
GRANT SELECT ON SBDB.REL_SERVCRED  TO PUBLIC;                   
GRANT SELECT ON SBDB.VW_AGRUPA_ANO_NOTICIA  TO PUBLIC;                
GRANT SELECT ON SBDB.VW_SOC_ELETR_ESTAT_CAT_REG  TO PUBLIC;     
GRANT SELECT ON SBDB.VW_LOGIN_EMAIL  TO PUBLIC;                 
GRANT SELECT ON SBDB.VW_FIN_CHECK_OBRIG_STATUS  TO PUBLIC;      
GRANT SELECT ON SBDB.VW_SOCIO_ATRIB_GRUPO  TO PUBLIC;           
GRANT SELECT ON SBDB.VW_LOGIN_GERAL  TO PUBLIC;                 
GRANT SELECT ON SBDB.VW_SOCIO_ELETRONICO  TO PUBLIC;
GRANT SELECT,UPDATE ON SBDB.SYS_CONFIG_GLOBAL TO PUBLIC;
GRANT SELECT ON SBDB.SYS_CONFIG_USUARIO TO PUBLIC;
GRANT SELECT ON SBDB.SYS_DELETE TO PUBLIC;
GRANT SELECT ON SBDB.SYS_LOCALID TO PUBLIC;
GRANT SELECT ON SBDB.SYS_OCORRENCIA TO PUBLIC;
/

-- OBJETO 940 | INDEX | IDX_SÓCIO_CPF
CREATE UNIQUE INDEX "IDX_SÓCIO_CPF" ON "SBDB"."SÓCIO" ("CPF")
/

-- OBJETO 950 | INDEX | IDX_BIBLIO_REQ_CPF
CREATE UNIQUE INDEX "IDX_BIBLIO_REQ_CPF" ON "SBDB"."BIBLIO_REQUISITANTE" ("CPF")
/

-- OBJETO 960 | INDEX | IDX_BIBLIO_REQ_PASSAPORTE
CREATE UNIQUE INDEX "IDX_BIBLIO_REQ_PASSAPORTE" ON "SBDB"."BIBLIO_REQUISITANTE" ("PASSAPORTE")
/

-- OBJETO 970 | INDEX | IDX_PROD_FINA_TITULO
CREATE UNIQUE INDEX "IDX_PROD_FINA_TITULO" ON "SBDB"."PROD_FINA" ("TITULO")
/

-- OBJETO 980 | TRIGGER | AFT_SOCIO_CHECK
CREATE OR REPLACE TRIGGER AFT_SOCIO_CHECK
AFTER INSERT OR UPDATE ON "SÓCIO"
DECLARE
  QTD INTEGER;
BEGIN
  FOR CUR IN (SELECT * FROM (SELECT EMAIL, COUNT(MAT) QTD FROM SBDB.VW_LOGIN_EMAIL GROUP BY EMAIL) WHERE QTD>1) LOOP
    RAISE_APPLICATION_ERROR(-20000, 'Um dos emails informados encontra-se vinculado à outra matrícula.');
  END LOOP;
END;
/

-- OBJETO 1001 | VISÃO | VW_EDITORIAL_ASS_ATIVAS
CREATE OR REPLACE VIEW SBDB.VW_EDITORIAL_ASS_ATIVAS AS SELECT EDITORIAL_SEQ ,
  ASSINATURA_SEQ      ,
  NOME                ,
  NOME_2              ,
  DATA_INICIO         ,
  DATA_FINAL          ,
  TIPO_ASSINATURA     ,
  TIPO_REMESSA        ,
  TIPO_POSTAGEM
   FROM SBDB.VW_EDITORIAL_ASSINATURAS
  WHERE TRUNC(NVL(DATA_INICIO,TO_DATE('0001-01-01','YYYY-MM-DD'))) <= TRUNC(SYSDATE) AND
  TRUNC(NVL(DATA_FINAL,TO_DATE('9999-12-31','YYYY-MM-DD'))) >= TRUNC(SYSDATE)
/

-- OBJETO 1601 | VISÃO | VW_RESIDENTE_ATIVO
CREATE OR REPLACE VIEW SBDB.VW_RESIDENTE_ATIVO AS SELECT SCR.CPF,
  SCR.NOME,
  SCR.MATRICULA,
  SCR.ANO,
  SCR.DATA_INICIO,
  SCR.DATA_FINAL,
  SC.COD,
  SC.SERVIÇO_NOME,
  SC.INSTITUIÇÃO,
  SCR.CURSO,
  SCR.SYS_MOMENTO_CRIA,
  SCR.SYS_USUARIO_CRIA,
  SCR.SYS_LOCAL_CRIA,
  SCR.SYS_MOMENTO_ATUALIZA,
  SCR.SYS_USUARIO_ATUALIZA,
  SCR.SYS_LOCAL_ATUALIZA,
  SCR.SYS_STATUS
FROM SBDB.SERV_CRED_RESIDENTE SCR,
  SBDB.SERVIÇO_CREDENCIADO SC
WHERE  (SCR.DATA_INICIO <= SYSDATE AND SYSDATE <= SCR.DATA_FINAL)
AND SC.COD              = SCR.SERV_CRED_COD
AND SC.CREDENCIADO = 'S'


/


/* **********************************************************************************
   CRIAÇÃO DE USUÁRIOS
*/

DECLARE
  QTD INTEGER;
BEGIN
  SELECT COUNT(*) INTO QTD FROM ALL_USERS WHERE USERNAME = 'ERISTIDES';
  IF QTD = 0 THEN
    EXECUTE IMMEDIATE 'CREATE USER ERISTIDES IDENTIFIED BY XXXXXX DEFAULT TABLESPACE T_SBDB_DAT TEMPORARY TABLESPACE TEMP PROFILE DEFAULT ACCOUNT UNLOCK';
  ELSE
    EXECUTE IMMEDIATE 'ALTER USER ERISTIDES IDENTIFIED BY XXXXXX ACCOUNT UNLOCK';
  END IF;
END;
/

GRANT CREATE SESSION, EXECUTE ANY LIBRARY, EXECUTE ANY PROCEDURE, CREATE ANY VIEW TO ERISTIDES;
GRANT SELECT ON SBDB.ANUIDADE_CATEGORIA TO ERISTIDES;
GRANT SELECT ON SBDB.ARQ_RETORNO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.CONVÊNIO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE, DELETE ON SBDB.EDITORIAL_TIPO_ASSINATURA TO ERISTIDES;
GRANT SELECT ON SBDB.EMCD_ATIV_PONTO TO ERISTIDES;
GRANT SELECT ON SBDB.EMCD_PONTO_FASE TO ERISTIDES;
GRANT SELECT ON SBDB.EMCD_TIPO_PONTO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.HISTORICO_LICENCIADO TO ERISTIDES;
GRANT SELECT ON SBDB.HISTORICO_SOCIO_ELETRONICO TO ERISTIDES;
GRANT SELECT ON SBDB.HISTORICO_SOCIO_PUBL_END TO ERISTIDES;
GRANT SELECT ON SBDB.OBRIGAÇÃO TO ERISTIDES;
GRANT SELECT ON SBDB.OBRIGAÇÃO_STATUS TO ERISTIDES;
GRANT SELECT ON SBDB.ÓRGÃO TO ERISTIDES;
GRANT SELECT ON SBDB.ÓRGÃO_MEMBRO TO ERISTIDES;
GRANT SELECT ON SBDB.PAGAMENTO TO ERISTIDES;
GRANT SELECT ON SBDB.PARCELAMENTO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.REGIÃO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE, DELETE ON SBDB.REUNIAO TO ERISTIDES;
GRANT SELECT ON SBDB.SERV_CRED_RENOVAÇÃO TO ERISTIDES;
GRANT SELECT ON SBDB.SERVIÇO_CREDENCIADO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.SÓCIO_CATEGORIA TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.SÓCIO_SUB_ESPECIALIDADE TO ERISTIDES;
GRANT SELECT ON SBDB.USUARIO TO ERISTIDES;
GRANT SELECT, UPDATE ON SBDB.ADM_HIST_TED TO ERISTIDES;
GRANT SELECT ON SBDB.ARQ_PAGAMENTO TO ERISTIDES;
GRANT SELECT ON SBDB.ARQ_REMESSA TO ERISTIDES;
GRANT SELECT ON SBDB.CARGO TO ERISTIDES;
GRANT SELECT ON SBDB.CATEGORIA TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE, DELETE ON SBDB.EDITORIAL TO ERISTIDES;
GRANT SELECT ON SBDB.EMCD_APURAÇÃO TO ERISTIDES;
GRANT SELECT ON SBDB.EMCD_ATIVIDADE TO ERISTIDES;
GRANT SELECT ON SBDB.EMCD_FASE TO ERISTIDES;
GRANT SELECT ON SBDB.EMCD_PONTO_SÓCIO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.ESTADO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.HISTORICO_PENALIZADO TO ERISTIDES;
GRANT SELECT ON SBDB.NEGOCIAÇÃO TO ERISTIDES;
GRANT SELECT ON SBDB.OBRIGAÇÃO_TIPO TO ERISTIDES;
GRANT SELECT ON SBDB.ÓRGÃO_GESTÃO TO ERISTIDES;
GRANT SELECT ON SBDB.ÓRGÃO_TIPO TO ERISTIDES;
GRANT SELECT ON SBDB.PARAMETRO_FINANCEIRO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.REGIONAL TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE, DELETE ON SBDB.REUNIAO_SOCIO TO ERISTIDES;
GRANT SELECT ON SBDB.SERV_CRED_RESIDENTE TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.SÓCIO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.SÓCIO_CONVÊNIO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.SÓCIO_ISENÇÃO TO ERISTIDES;
GRANT SELECT, INSERT, UPDATE ON SBDB.SUB_ESPECIALIDADE TO ERISTIDES;
GRANT SELECT ON SBDB.VW_SOCIO_ELETRONICO TO ERISTIDES;


GRANT CREATE SESSION, EXECUTE ANY LIBRARY, EXECUTE ANY PROCEDURE, CREATE ANY VIEW TO JACKSON;

SPOOL OFF
$ECHO - >>"C:\SBDB_PARTES.LOG"
$ECHO - >>"C:\SBDB_PARTES.LOG"
$ECHO - >>"C:\SBDB_PARTES.LOG"
$COMMAND /C ECHO %DATE% %TIME% >>"C:\SBDB_PARTES.LOG"
$COMMAND /C FIND "ORA-" "C:\SBDB_PARTE2.LOG" >>"C:\SBDB_PARTES.LOG"
$COMMAND /C FIND "SP2-" "C:\SBDB_PARTE2.LOG" >>"C:\SBDB_PARTES.LOG"
