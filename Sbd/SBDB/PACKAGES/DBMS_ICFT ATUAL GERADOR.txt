DROP TYPE DICT_OBJ FORCE
/

CREATE OR REPLACE TYPE DICT_OBJ  AS  OBJECT  ( CHAVE  VARCHAR2 (70), CONTEUDO VARCHAR2 (4000) )
/


DROP TYPE DICT_TBL FORCE
/

CREATE OR REPLACE TYPE DICT_TBL AS  TABLE OF DICT_OBJ;
/


DROP TYPE MANUT_OBJ FORCE
/

CREATE OR REPLACE TYPE MANUT_OBJ AS OBJECT (
      SEQ NUMBER,
      TABELA VARCHAR2(100),
      MANUT_MOMENTO_STR VARCHAR2(50),
      CRIA_MOMENTO DATE,
      ATUALIZA_MOMENTO DATE,
      MANUT_MOMENTO DATE,
      MANUT_USUARIO VARCHAR2(100),
      MANUT_LOCAL VARCHAR2(100),
      MAP MEMBER FUNCTION GET_IDNO RETURN NUMBER
)
/

CREATE OR REPLACE TYPE BODY MANUT_OBJ AS
  MAP MEMBER FUNCTION GET_IDNO RETURN NUMBER IS
  BEGIN
    RETURN SEQ;
  END;
END;
/

DROP TYPE MANUT_TBL FORCE
/

CREATE OR REPLACE TYPE MANUT_TBL AS TABLE OF MANUT_OBJ;
/

-- DICT, MANTIDA POR COMPATIBILIDADE. UTILIZAR DICT QUE ESTÁ EM DBMS_ICRAFT.
CREATE OR REPLACE FUNCTION DICT
  (
    LISTA VARCHAR2,
    DELIM VARCHAR2 := ';',
    ATRIB VARCHAR2 := ':' )
  RETURN DICT_TBL PIPELINED
                  IS
  POS PLS_INTEGER := 1;
  PROX PLS_INTEGER;
  TERMO VARCHAR2(4000);
  PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
  WHILE POS<=LENGTH(LISTA)
  LOOP
    PROX    := INSTR(LISTA, DELIM, POS);
    IF PROX <> 0 THEN
      TERMO := SUBSTR(LISTA, POS, PROX-POS);
      POS   := PROX                   +1;
    ELSE
      TERMO := SUBSTR(LISTA, POS);
      POS   := LENGTH(LISTA)+1;
    END IF;
    PROX        := INSTR(TERMO, ATRIB);
    IF PROX     <>0 THEN
      PAR.CHAVE := SUBSTR(TERMO, 1, PROX-1);
    ELSE
      PAR.CHAVE := '';
    END IF;
    PAR.CONTEUDO := SUBSTR(TERMO, PROX+1);
    PIPE ROW(PAR);
  END LOOP;
END DICT;
/


create or replace PACKAGE DBMS_ICRAFT IS
 FUNCTION MANUT_ULTIMO_MOMENTO(ESQUEMA_PRINC VARCHAR2) RETURN DATE;
 FUNCTION MANUT_ULTIMAS(ESQUEMA_PRINC IN VARCHAR2, QTD IN INTEGER) RETURN MANUT_TBL PIPELINED;
 FUNCTION DICT (LISTA VARCHAR2, DELIM VARCHAR2 := ';',  ATRIB VARCHAR2 := ':' ) RETURN DICT_TBL PIPELINED;
 FUNCTION DATEDIFF(FORMATO VARCHAR2,INICIO DATE, FINAL DATE, CASASDECIMAIS INTEGER DEFAULT 0) RETURN FLOAT;
 FUNCTION OBTEM_CONFIG_USUARIO_PADRAO(ESQUEMA VARCHAR2 ,PARAM VARCHAR2 ,USUARIO VARCHAR2 ,USUARIO_PADRAO VARCHAR2 ) RETURN DICT_TBL PIPELINED;
 FUNCTION OBJ_ID_MAX RETURN INTEGER;
 FUNCTION SERVIDOR_IP RETURN VARCHAR2;
 FUNCTION SERVIDOR_NOME RETURN VARCHAR2;
 PROCEDURE OBJ_APARTIR_ID(ID NUMBER);
END;
/

create or replace PACKAGE BODY DBMS_ICRAFT AS 
FUNCTION MANUT_ULTIMO_MOMENTO (ESQUEMA_PRINC VARCHAR2) RETURN DATE
  -- EXEMPLO PARA TESTES
  -- SELECT TO_CHAR(DBMS_ICRAFT.MANUT_ULTIMO_MOMENTO('SBDB'),'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
AS
  DT DATE;
  DT_ACUM DATE := NULL;
  COMANDO VARCHAR2(4000);
BEGIN
  FOR CUR IN
  (SELECT OWNER,
    TABLE_NAME
     FROM ALL_TABLES
    WHERE OWNER IN
    (SELECT USERNAME
       FROM ALL_USERS
      WHERE USER_ID >=
      (SELECT USER_ID FROM ALL_USERS WHERE USERNAME=ESQUEMA_PRINC
      )
    )
  )
  LOOP
    BEGIN
      IF INSTR(';SYS_CONFIG_GLOBAL;SYS_CONFIG_USUARIO;SYS_LOCALID;SYS_OCORRENCIA;',';' || CUR.TABLE_NAME || ';')=0 THEN
        IF CUR.TABLE_NAME                                                                                       = 'SYS_DELETE' THEN
          COMANDO                                                                                              := 'SELECT MAX(MOMENTO) FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME ;
        ELSE
          COMANDO := 'SELECT GREATEST(NVL(MAXC,MAXA),NVL(MAXA,MAXC)) FROM (SELECT MAX(SYS_MOMENTO_CRIA) AS MAXC, MAX(SYS_MOMENTO_ATUALIZA) AS MAXA FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ')';
        END IF;
        EXECUTE IMMEDIATE COMANDO INTO DT;
         SELECT GREATEST(NVL(DT,DT_ACUM), NVL(DT_ACUM,DT)) INTO DT_ACUM FROM DUAL;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      NULL;
    END;
  END LOOP;
  RETURN DT_ACUM;
END;
FUNCTION DICT
  (
    LISTA VARCHAR2,
    DELIM VARCHAR2 := ';',
    ATRIB VARCHAR2 := ':' )
  RETURN DICT_TBL PIPELINED
                  IS
  POS PLS_INTEGER := 1;
  PROX PLS_INTEGER;
  TERMO VARCHAR2(4000);
  PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
  WHILE POS<=LENGTH(LISTA)
  LOOP
    PROX    := INSTR(LISTA, DELIM, POS);
    IF PROX <> 0 THEN
      TERMO := SUBSTR(LISTA, POS, PROX-POS);
      POS   := PROX                   +1;
    ELSE
      TERMO := SUBSTR(LISTA, POS);
      POS   := LENGTH(LISTA)+1;
    END IF;
    PROX        := INSTR(TERMO, ATRIB);
    IF PROX     <>0 THEN
      PAR.CHAVE := SUBSTR(TERMO, 1, PROX-1);
    ELSE
      PAR.CHAVE := '';
    END IF;
    PAR.CONTEUDO := SUBSTR(TERMO, PROX+1);
    PIPE ROW(PAR);
  END LOOP;
END DICT;
FUNCTION MANUT_ULTIMAS(ESQUEMA_PRINC IN VARCHAR2, QTD IN INTEGER) RETURN MANUT_TBL PIPELINED AS  
M_REG MANUT_OBJ := MANUT_OBJ(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
  --
  -- ESTRUTURA PARA GUARDAR MANUTENÇÕES
  -- MANUT_MOMENTO_STR É A CHAVE E PERMITIRÁ ORGANIZAR A TAB POR MOMENTO DE MANUTENÇÃO
  --
  TYPE MANUT_TBL_ORD is table of MANUT_OBJ index by VARCHAR2(200);
  MANUT MANUT_TBL := NEW MANUT_TBL();
  --
  -- MANUT2 SERVE PARA JUNTAR AS CONSULTAS. DEPOIS DE JUNTAR VOU PEGAR SOMENTE OS N ÚLTIMOS
  --
  MANUT2 MANUT_TBL;
  --
  -- MANUTS SERVE PARA ORDENAR A JUNÇÃO DE PESQUISAS
  --
  MANUTS MANUT_TBL_ORD;
  --
  --
  --
  COMANDO VARCHAR2(4000);
  CONST1_INICIO VARCHAR2(1000);
  CONST1_FIM VARCHAR2(1000);
  ORD INTEGER;
  CHAVE VARCHAR2(50);
  --
  --
  TYPE C_T IS REF CURSOR;
  C C_T;
  REG_SEQ INTEGER;
  REG_BUSCA VARCHAR2(50);
  --
BEGIN
  --
  -- LOOPING NAS TABELAS OBTIDAS A PARTIR DO ESQUEMA PRINCIPAL
  --
  FOR CUR    IN
  (SELECT OWNER,
    TABLE_NAME
     FROM ALL_TABLES
    WHERE OWNER IN
    (SELECT USERNAME
       FROM ALL_USERS
      WHERE USER_ID >=
      (SELECT USER_ID FROM ALL_USERS WHERE USERNAME=ESQUEMA_PRINC
      )
    )
  )
  LOOP
    IF INSTR(';SYS_DELETE;SYS_CONFIG_GLOBAL;SYS_CONFIG_USUARIO;SYS_LOCALID;SYS_OCORRENCIA;',';' || CUR.TABLE_NAME || ';')=0 THEN
    --
    --
    --
    -- OBTENDO REGISTROS MAIS ATUAIS
    --
    COMANDO := 'SELECT SEQ, ''' || CUR.TABLE_NAME || ''' TABELA, TO_CHAR(MANUT_MOMENTO_STR,''YYYY-MM-DD HH24:MI:SS'') MANUT_MOMENTO_STR, CRIA_MOMENTO, ATUALIZA_MOMENTO, MANUT_MOMENTO, MANUT_USUARIO, MANUT_LOCAL
    FROM
    (SELECT ROWNUM SEQ,
    SYS_MOMENTO_CRIA CRIA_MOMENTO,
    SYS_MOMENTO_ATUALIZA ATUALIZA_MOMENTO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END AS MANUT_MOMENTO_STR,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END AS MANUT_MOMENTO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_USUARIO_ATUALIZA
      ELSE SYS_USUARIO_CRIA
    END AS MANUT_USUARIO,
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_LOCAL_ATUALIZA
      ELSE SYS_LOCAL_CRIA
    END AS MANUT_LOCAL FROM ' || CUR.OWNER || '.' || CUR.TABLE_NAME || ' ORDER BY
    CASE
      WHEN NOT SYS_MOMENTO_ATUALIZA IS NULL
      AND SYS_MOMENTO_ATUALIZA       > SYS_MOMENTO_CRIA
      THEN SYS_MOMENTO_ATUALIZA
      ELSE SYS_MOMENTO_CRIA
    END DESC
    )
    WHERE SEQ <= ' || QTD;
    --
    --
    --
    --
    -- JOGA PARA MANUT.... E JUNTA COM MANUT2
    --
    BEGIN
      --
      MANUT.DELETE;
      OPEN C FOR COMANDO;
      --
      LOOP
        --
        --
        BEGIN
          FETCH c INTO M_REG.SEQ, M_REG.TABELA, M_REG.MANUT_MOMENTO_STR, M_REG.CRIA_MOMENTO, M_REG.ATUALIZA_MOMENTO, M_REG.MANUT_MOMENTO, M_REG.MANUT_USUARIO, M_REG.MANUT_LOCAL;
          EXIT WHEN C%NOTFOUND;
        EXCEPTION
          WHEN OTHERS THEN
	   -- DBMS_OUTPUT.PUT_LINE('FETCH ' || CUR.TABLE_NAME || '>>' || SQLERRM);
           NULL;
        END;
        MANUT.EXTEND;
        MANUT(MANUT.COUNT) := M_REG;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
	   -- DBMS_OUTPUT.PUT_LINE('OPEN ' || CUR.TABLE_NAME || '>>' || SQLERRM);
           NULL;
    END;
    --
    --
    --
    IF MANUT2 IS NULL THEN
      MANUT2 := MANUT;
    ELSE
      MANUT2 := MANUT MULTISET UNION MANUT2;
    END IF;
    --
    --
    -- ORDENA ITENS PEGANDO SÓ A QUANTIDADE MÁXIMA SOLICITADA
    --
    IF MANUT2.COUNT > 0 THEN
	MANUTS.DELETE;
        -- DBMS_OUTPUT.PUT_LINE('TABELA ' || CUR.TABLE_NAME || ' ... ANTES');
        FOR Z IN MANUT2.FIRST .. MANUT2.LAST LOOP
          IF NOT MANUT2(Z).MANUT_MOMENTO_STR IS NULL THEN
            -- DBMS_OUTPUT.PUT_LINE(MANUT2(Z).MANUT_MOMENTO_STR);
            REG_SEQ := 1;
	    LOOP
              REG_BUSCA := MANUT2(Z).MANUT_MOMENTO_STR || '-' || TO_CHAR(REG_SEQ,'0000');
              EXIT WHEN NOT MANUTS.EXISTS(REG_BUSCA);
              REG_SEQ := REG_SEQ + 1;
            END LOOP;
            MANUTS(REG_BUSCA) := MANUT2(Z);
          END IF;
        END LOOP;
	MANUT2.DELETE;
        ORD := 1;
        CHAVE := MANUTS.LAST;
        -- DBMS_OUTPUT.PUT_LINE('TABELA ' || CUR.TABLE_NAME || ' ... DEPOIS');
        LOOP
          EXIT WHEN ORD > QTD OR CHAVE IS NULL;
          -- DBMS_OUTPUT.PUT_LINE(CHAVE);
          MANUT2.EXTEND;
          MANUT2(ORD) := MANUTS(CHAVE);
          ORD := ORD + 1;
          CHAVE := MANUTS.PRIOR(CHAVE);
        END LOOP;
        -- DBMS_OUTPUT.PUT_LINE('..........');
    END IF;
    --
    --
    --
    END IF;
  END LOOP;
  --
  --
  --
  -- DANDO SAÍDA NO RESULTADO
  --
  CHAVE := MANUT2.FIRST;
  LOOP
    EXIT WHEN CHAVE IS NULL;
    PIPE ROW (MANUT2(CHAVE));
    CHAVE := MANUT2.NEXT(CHAVE);
  END LOOP;
  --
  --
  --
  RETURN;
END MANUT_ULTIMAS;
FUNCTION DATEDIFF(FORMATO VARCHAR2,INICIO DATE, FINAL DATE, CASASDECIMAIS INTEGER DEFAULT 0) RETURN FLOAT AS
  RET FLOAT;
BEGIN
  IF FORMATO = 'ANO' THEN
    RET := MONTHS_BETWEEN(FINAL, INICIO)/12;
  ELSIF FORMATO = 'MES' THEN
    RET := MONTHS_BETWEEN(FINAL, INICIO);
  ELSIF FORMATO = 'DIA' THEN
    RET := FINAL - INICIO;
  ELSIF FORMATO = 'HORA' THEN
    RET := (FINAL - INICIO)*24;
  ELSIF FORMATO = 'MIN' THEN
    RET := (FINAL - INICIO)*24*60;
  ELSIF FORMATO = 'SEG' THEN
    RET := (FINAL - INICIO)*24*60*60;
  END IF;
  RET := TRUNC(RET,CASASDECIMAIS);
  RETURN RET;
END;
FUNCTION OBTEM_CONFIG_USUARIO_PADRAO(ESQUEMA VARCHAR2 ,PARAM VARCHAR2 ,USUARIO VARCHAR2 ,USUARIO_PADRAO VARCHAR2 ) RETURN DICT_TBL PIPELINED IS
PAR DICT_OBJ := DICT_OBJ(NULL,NULL);
BEGIN
            BEGIN
                        SELECT CONFIG INTO PAR.CONTEUDO FROM SYS_CONFIG_USUARIO S WHERE S.USUARIO=USUARIO AND S.PARAM=PARAM;
                        PAR.CHAVE := USUARIO;
            EXCEPTION WHEN OTHERS THEN
                        BEGIN                         
                                   SELECT CONFIG INTO PAR.CONTEUDO FROM SYS_CONFIG_USUARIO S WHERE S.USUARIO=USUARIO_PADRAO AND S.PARAM=PARAM;
                                   PAR.CHAVE := USUARIO_PADRAO; 
                        EXCEPTION WHEN OTHERS THEN
                                   PAR.CHAVE := USUARIO;
                                   PAR.CONTEUDO := '';
                        END;
            END;
            PIPE ROW(PAR);        
END;

FUNCTION OBJ_ID_MAX RETURN INTEGER AS
  M  NUMBER;
BEGIN
  SELECT MAX(OBJECT_ID) INTO M FROM ALL_OBJECTS;
  RETURN M;
END;


FUNCTION SERVIDOR_IP RETURN VARCHAR2 AS
  IP VARCHAR2(30);
BEGIN
  SELECT UTL_INADDR.GET_HOST_ADDRESS INTO IP FROM DUAL;
  RETURN IP;
END;


FUNCTION SERVIDOR_NOME RETURN VARCHAR2 AS
  NOME VARCHAR2(30);
BEGIN
  SELECT UTL_INADDR.GET_HOST_NAME INTO NOME FROM DUAL;
  RETURN NOME;
END;


PROCEDURE OBJ_APARTIR_ID(ID NUMBER) AS
BEGIN
  FOR CUR IN (SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER || '.' || OBJECT_NAME AS COMA FROM (SELECT OWNER, OBJECT_NAME, OBJECT_TYPE FROM ALL_OBJECTS WHERE OBJECT_ID > ID))
      LOOP
          DBMS_OUTPUT.PUT_LINE(CUR.COMA);
          BEGIN
             EXECUTE IMMEDIATE CUR.COMA;
          EXCEPTION
            WHEN OTHERS THEN
              DBMS_OUTPUT.PUT_LINE(SQLERRM || ' EM ' || CUR.COMA);
          END;
     END LOOP;  
END;



END DBMS_ICRAFT;